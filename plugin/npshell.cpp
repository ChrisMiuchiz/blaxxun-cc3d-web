/* ----   copyright note ----------------------------------------------------

     Copyright (c) 1996 by
     blaxxun interactive, Munich, Germany
     All rights reserved

     pPlugin software is furnished under a license  and may be  used and  copied
     only in  accordance of the  terms of such license and with the inclusion
     of the above  copyright note.  pPlugin software or any  other copies therof
     may not be provided or otherwise made available to any other person.  No
     title to and ownership of the software is hereby transferred.

     The information in this software is subject to change without notice and
     should not be construed as a commitment by blaxxun interactive.

   ----   copyright note ------------------------------------------------- */

/* ----   file information  -------------------------------------------------

   Project:    Passport Pro
   Subsystem:  PLUGIN DLL
   Component:  

   Module:     npshell.cpp
   Author:     Kristof Nast-Kolb

   Revison:    $Revision $

   Date:       $Date $

   Modification History:

  $Log $
   ----   file information  ---------------------------------------------- */

#if !defined CM_NO_VERSION_STRINGS
static char NPSHELL_CPP_rcs[] = "@@(#) $Id $";
#endif /* CM_NO_VERSION_STRINGS */

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\.
////\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//.
// npshell.cpp 
// 
//              pPlugin file handles the entry points from the navigator into the
//              plugin.  pPlugin example shows a basic shell which can be used as
//              a good starting point for other plugins... 
//
//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\.
////\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//.

/*
//------------------------------------------------------------------------------
//---          INCLUDE FILES
//------------------------------------------------------------------------------
*/
#include "StdAfx.h"

#ifndef _INC_WINDOWS    
#include <windows.h>
#endif
#ifndef _INC_STRING
#include <string.h>
#endif
#include <stdio.h>

#include "npbx3d.h"

#ifdef _DEBUG 
	#include "tracewin.h"
#endif

HINSTANCE g_hDllInstance = NULL;
static bool initJavaLater = false;

BOOL WINAPI 
CC3DMain( HINSTANCE  hinstDLL,			// handle of DLL module 
						DWORD  fdwReason,	// reason for calling function 
						LPVOID  lpvReserved)
{
	switch (fdwReason) {
		case DLL_PROCESS_ATTACH:
		  g_hDllInstance = hinstDLL;
		  break;
		case DLL_THREAD_ATTACH:
		case DLL_PROCESS_DETACH:
		case DLL_THREAD_DETACH:
		break;
	}
	return TRUE;
}

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\.
////\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//.
// NPP_Initialize
//
//      Initialize the plugin library. Your DLL global initialization
//      should be here
//


extern void Private_SetJavaClass();

NPError 
NPP_Initialize(void)
{
/*
	static int firstTime=1;

	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	#ifdef _DEBUG 
		if (afxDump.m_pFile == NULL) 
			CMfxTrace::Init();
	#endif
	
		firstTime = 0;
*/

    //TRACE(("initialize the plugin \n"));
    return NPERR_NO_ERROR;
}

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\.
////\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//.
// NPP_Shutdown
//
//      shutdown the plugin library. Revert initializition
//
void 
NPP_Shutdown(void)
{
    //TRACE(("shutdown the plugin \n"));
}

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\.
////\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//.
// NPP_GetJavaClass
//
//      Return the Java class representing this plugin
//
jref 
NPP_GetJavaClass(void)
{
        //\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//.
        // get the Java environment. You need this information pretty much for
        // any jri (Java Runtime Interface) call. 
#ifdef NOJAVA
    return NULL;
#else
    JRIEnv* env = NPN_GetJavaEnv();
        //\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//.
        // init any classes that define native methods.
        // The following functions are generated by javah running on the java
        // class(es) representing this plugin. javah generates the files
        // <java class name>.h and <java class name>.c (same for any additional
        // class you may want to use)
        // Return the main java class representing this plugin (derives from
        // Plugin class on the java side)
    if (!env)
        return NULL;
    return CJavaCtrl::init(env);
        // if no java is used
        //return NULL;
#endif //NOJAVA
}

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\.
////\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//.
// NPP_New
//
//      create a new plugin instance 
//      handle any instance specific code initialization here
//
NPError NP_LOADDS
NPP_New(NPMIMEType pluginType,
                NPP instance,
                uint16 mode,
                int16 argc,
                char* argn[],
                char* argv[],
                NPSavedData* saved)
{   
    bool useJava = true;
    int noOfDownloads = 0;

    if (instance == NULL)
    {
        return NPERR_INVALID_INSTANCE_ERROR;
    }

    if (mode == NP_EMBED)
    {
        for (int i = 0; i < argc ; i++)
        {
            if (!_stricmp(argn[i], "nojava"))
            {
                useJava = false;
            }
            else if (!_stricmp(argn[i], "downloads"))
            {
                noOfDownloads = atoi(argv[i]);
            }
        }
    }

#ifdef NOJAVA
    useJava = false;
#endif

    if (useJava)
	{
		int version;
		NPN_Version(&version, &version, &version, &version);
		if( version >= NPVERS_HAS_WINDOWLESS) // communicator
		{
			OSVERSIONINFO osversion; // different check for 95 or NT
			osversion.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
			::GetVersionEx(&osversion);
			if (osversion.dwPlatformId == VER_PLATFORM_WIN32_NT) 
			{		
				initJavaLater = true;
			}
		}
		if (!initJavaLater)
		{
			Private_SetJavaClass();
		}
    }

    CNpbx3d * pPlugin;
    if (instance->pdata)
        pPlugin = (CNpbx3d *)instance->pdata;
    else
    {
        if (mode == NP_EMBED)
        {
            pPlugin = new CNpbx3d(instance, argc, argn, argv, useJava);
        }
        else
        {
            pPlugin = new CNpbx3d(instance, 0, NULL, NULL, useJava);
        }
    }
    
    if (pPlugin == NULL)
        return NPERR_OUT_OF_MEMORY_ERROR;
    instance->pdata = (void *) pPlugin;
    if (noOfDownloads)
        pPlugin->setNoDownloads(noOfDownloads);

    //
    // *Developers*: Initialize fields of your plugin
    // instance data here.  If the NPSavedData is non-
    // NULL, you can use that data (returned by you from
    // NPP_Destroy to set up the new plugin instance.
    //
        
    return NPERR_NO_ERROR;
}

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\.
////\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//.
// NPP_Destroy
//
//      Deletes a plug-in instance and releases all of its resources.
//
NPError NP_LOADDS
NPP_Destroy(NPP instance, NPSavedData** save)
{
    CNpbx3d* pPlugin = (CNpbx3d *) instance->pdata;

    //
    // *Developers*: If desired, call NP_MemAlloc to create a
    // NPSavedDate structure containing any state information
    // that you want restored if this plugin instance is later
    // recreated.
    //

    if (pPlugin != NULL)
    {
        //TRACE((" destroy plugin \n"));

        delete pPlugin;
        instance->pdata = NULL;
    }

    return NPERR_NO_ERROR;

}

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\.
////\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//.
// NPP_SetWindow
//
//      Associates a platform specific window handle with a plug-in instance.
//              Called multiple times while, e.g., scrolling.  Can be called for three
//              reasons:
//
//                      1.  A new window has been created
//                      2.  A window has been moved or resized
//                      3.  A window has been destroyed
//
//      There is also the degenerate case;  that it was called spuriously, and
//  the window handle and or coords may have or have not changed, or
//  the window handle and or coords may be ZERO.  State information
//  must be maintained by the plug-in to correctly handle the degenerate
//  case.
//
NPError NP_LOADDS
NPP_SetWindow(NPP instance, NPWindow* window)
{    
    CNpbx3d* pPlugin = (CNpbx3d*) instance->pdata;

    //TRACE((" setwindow \n"));
    if (pPlugin == NULL)
        return NPERR_INVALID_INSTANCE_ERROR;

	if (window->window == NULL)
	{
        /*HWND Wnd = NULL;
		char text[64];
        while ((Wnd = ::FindWindowEx(NULL, Wnd, NULL, NULL)) != NULL)
        {
			*text = '\0';
			::GetClassName(Wnd, text, 64);
			if (!strncmp(text, "Afx:400000:b", 12))
			{
				RECT rect;
				::GetClientRect(Wnd, &rect);
				::UpdateWindow(Wnd);
			}
		}
		*/
		return NPERR_NO_ERROR;
	}

    pPlugin->setWindow((HWND)window->window, window->x,window->y,window->width,window->height);

    if (initJavaLater)
    {
        Private_SetJavaClass();
		initJavaLater = false;
    }

    return NPERR_NO_ERROR;
}

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\.
////\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//.
// NPP_NewStream
//
//      Notifies the plugin of a new data stream.
//  The data type of the stream (a MIME name) is provided.
//  The stream object indicates whether it is seekable.
//  The plugin specifies how it wants to handle the stream.
//
//  In this case, I set the streamtype to be NPAsFile.  pPlugin tells the Navigator
//  that the plugin doesn't handle streaming and can only deal with the object as
//  a complete disk file.  It will still call the write functions but it will also
//  pass the filename of the cached file in a later NPE_StreamAsFile call when it
//  is done transfering the file.
//
//  If a plugin handles the data in a streaming manner, it should set streamtype to
//  NPNormal  (e.g. *streamtype = NPNormal)...the NPE_StreamAsFile function will
//  never be called in this case
//
NPError NP_LOADDS
NPP_NewStream(NPP instance,
              NPMIMEType type,
              NPStream *stream, 
              NPBool seekable,
              uint16 *stype)
{
    //TRACE((" new stream \n"));
    if(!instance)
    {
        //MessageBox(NULL,"Plugin: Invalid instance","blaxxun interactive", MB_ICONERROR);
        return  NPERR_INVALID_INSTANCE_ERROR;
    }

    *stype = NP_ASFILEONLY;

    CNpbx3d* pPlugin = (CNpbx3d*) instance->pdata;
    if (pPlugin)
        *stype = pPlugin->newStream(stream, type);
    return NPERR_NO_ERROR;
}

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\.
////\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//.
// NPP_StreamAsFile
//
//      The stream is done transferring and here is a pointer to the file in the cache
//      pPlugin function is only called if the streamtype was set to NPAsFile.
//
void NP_LOADDS
NPP_StreamAsFile(NPP instance, NPStream *stream, const char* fname)
{
    CNpbx3d* pPlugin = (CNpbx3d*) instance->pdata;

    if (pPlugin == NULL)
        return;

    if(fname == NULL || fname[0] == NULL)
    {
        pPlugin->notifyURL(stream, stream->url, "", CNpbx3d::NetworkError);
        TRACE("load url <%s> failed \n", stream->url);
        return;
    }
    else
    {

        //TRACE(("url <%s> loaded to <%s>\n", stream->url, fname));
        pPlugin->notifyURL(stream, stream->url, fname, CNpbx3d::LoadOK);
    }
}

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\.
////\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//.
//
//              These next 2 functions are really only directly relevant 
//              in a plug-in which handles the data in a streaming manner.  
//              For a NPAsFile stream, they are still called but can safely 
//              be ignored.
//
//              In a streaming plugin, all data handling would take place here...
//
////\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//.
//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\.

int32 STREAMBUFSIZE = 0X0FFFFFFF;   // we are reading from a file in NPAsFile mode
                                    // so we can take any size stream in our write
                                    // call (since we ignore it)
                                
//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\.
////\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//.
// NPP_WriteReady
//
//      The number of bytes that a plug-in is willing to accept in a subsequent
//      NPO_Write call.
//
int32 NP_LOADDS
NPP_WriteReady(NPP instance, NPStream *stream)
{
    return STREAMBUFSIZE;  
}

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\.
////\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//.
// NPP_Write
//
//      Provides len bytes of data.
//
int32 NP_LOADDS
NPP_Write(NPP instance, NPStream *stream, int32 offset, int32 len, void *buffer)
{   
    CNpbx3d* pPlugin = (CNpbx3d*) instance->pdata;

    if (pPlugin == NULL)
        return -1;

    pPlugin->writeStream(stream, buffer, len);
    return len;
}

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\.
////\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//.
// NPP_DestroyStream
//
//      Closes a stream object.  
//      reason indicates why the stream was closed.  Possible reasons are
//      that it was complete, because there was some error, or because 
//      the user aborted it.
//
NPError NP_LOADDS
NPP_DestroyStream(NPP instance, NPStream *stream, NPError reason)
{
    // because I am handling the stream as a file, I don't do anything here...
    // If I was streaming, I would know that I was done and do anything appropriate
    // to the end of the stream...   
    CNpbx3d* pPlugin = (CNpbx3d*) instance->pdata;

    if (pPlugin != NULL)
        pPlugin->destroyStream(stream, reason);
    return NPERR_NO_ERROR;
}

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\.
////\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//.
// NPP_Print
//
//      Printing the plugin (to be continued...)
//
void NP_LOADDS
NPP_Print(NPP instance, NPPrint* printInfo)
{
    if(printInfo == NULL)   // trap invalid parm
        return;

}

//----------------------------------------------------------------------------
// NPP_HandleEvent:
// Mac-only.
//----------------------------------------------------------------------------
int16 NPP_HandleEvent(NPP instance, void* event)
{
    NPBool eventHandled = FALSE;
    return eventHandled;
}
/*******************************************************************************
// NPP_URLNotify:
// Notifies the instance of the completion of a URL request. 
// 
// NPP_URLNotify is called when Netscape completes a NPN_GetURLNotify or
// NPN_PostURLNotify request, to inform the plug-in that the request,
// identified by url, has completed for the reason specified by reason. The most
// common reason code is NPRES_DONE, indicating simply that the request
// completed normally. Other possible reason codes are NPRES_USER_BREAK,
// indicating that the request was halted due to a user action (for example,
// clicking the "Stop" button), and NPRES_NETWORK_ERR, indicating that the
// request could not be completed (for example, because the URL could not be
// found). The complete list of reason codes is found in npapi.h. 
// 
// The parameter notifyData is the same plug-in-private value passed as an
// argument to the corresponding NPN_GetURLNotify or NPN_PostURLNotify
// call, and can be used by your plug-in to uniquely identify the request. 
 ******************************************************************************/

void
NPP_URLNotify(NPP instance, const char* url, NPReason reason, void* notifyData)
{
	//AFX_MANAGE_STATE(AfxGetStaticModuleState());
    CNpbx3d* pPlugin = (CNpbx3d*) instance->pdata;

    if (pPlugin == NULL)
        return;

    switch (reason)
    {
    case NPRES_DONE: // already notified by NPP_StreamAsFile
        //pPlugin->notifyURL(url, NULL, CNpbx3d::LoadOK);
        break; 
    case NPRES_NETWORK_ERR:
        // xx new uncommented pPlugin->notifyURL(url, NULL, CNpbx3d::NetworkError);
        break;
    case NPRES_USER_BREAK:
        pPlugin->notifyURL(NULL, url, NULL, CNpbx3d::UserBreak);
        break;
    }
}

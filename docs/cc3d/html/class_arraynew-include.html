<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta name="robots" content="noindex">
<title>ArrayNew Include File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body bgcolor="#ffffff">
<!-- Generated by Doxygen 1.0.0 on Thu Jan 27 18:15:06 2000 -->
<center>
<a class="qindex"href="index.html">Main Page</a> &nbsp; <a class="qindex"href="namespaces.html">Namespace List</a> &nbsp; <a class="qindex"href="hierarchy.html">Class Hierarchy</a> &nbsp; <a class="qindex"href="annotated.html">Compound List</a> &nbsp; <a class="qindex"href="files.html">File List</a> &nbsp; <a class="qindex"href="headers.html">Header Files</a> &nbsp; <a class="qindex"href="namespacemembers.html">Namespace Members</a> &nbsp; <a class="qindex"href="functions.html">Compound Members</a> &nbsp; <a class="qindex"href="globals.html">File Members</a> &nbsp; </center>
<hr><h1>arraynew.h</h1>This is the verbatim text of the arraynew.h include file.<div class="fragment"><pre>/*=============================================================================

This code is licensed under the Web3D-blaxxun Community Source License,
provided in distribution file LICENSE.TXT and available online at
http://www.web3D.org/TaskGroups/x3d/blaxxun/Web3D-blaxxunCommunitySourceAgreement.html
and may only be used for non-commercial use as specified in that license.

THE WEB3D CONSORTIUM AND BLAXXUN DO NOT MAKE AND HEREBY DISCLAIM ANY EXPRESS
OR IMPLIED WARRANTIES RELATING TO THIS CODE, INCLUDING BUT NOT LIMITED TO,
WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY OR FITNESS FOR A PARTICULAR
PURPOSE, OR ANY WARRANTIES THAT MIGHT ARISE FROM A COURSE OF DEALING, USAGE
OR TRADE PRACTICE.  THE COMMUNITY SOURCE CODE IS PROVIDED UNDER THIS
AGREEMENT "AS IS," WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
INCLUDING, WITHOUT LIMITATION, WARRANTIES THAT THE COMMUNITY SOURCE CODE ARE
FREE OF DEFECTS, MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE OR
NON-INFRINGING OR IN ANY WAY CONSTITUTE THE COMPLETE PRODUCT MARKETED UNDER
THE NAMES GIVEN SAID CODE.

==============================================================================*/
#ifndef _ArrayNew_H
#define _ArrayNew_H
/******************************************************************************
@doc

@module ArrayNew.h - Template based ArrayNew class |

Copyright (c) 1993 - 1995       by Holger Grahn
All rights reserved

Purpose:

Template based ArrayNew class
Designed to easily interchange with C ArrayNew notation
and "by value" elements
Derived class NumericArrayNew supports common arithmetic operators


Classes:
ArrayNew&lt;T&gt;
        NumericArrayNew&lt;T&gt;
                IntArrayNew
                FloatArrayNew


Notes:

Changes:
    change ArrayNew_EXPANSION
            if &lt; limit, only double size
    MALLOC, CALLOC, FREE debug routines


Todo :
Automatic Expansion + Expansion factor
Implementation change :
        use malloc, realloc, free instead of new &amp; delete ?
******************************************************************************/

//#include &lt;iostream.h&gt;



#ifdef __HIGHC__
pragma Off(Auto_class_member_instantiation);
//pragma On(Print_template_usage);
#endif

class <a class="code" href="class_astream.html">AStream</a>;
// Auto expand on Append(T)
#define ArrayNew_EXPANSION 1024



//\@class Template ArrayNew class
//\@tcarg class | T | A class to store in ArrayNew (by value)

template&lt;class T&gt;
class <a class="code" href="class_arraynew.html">ArrayNew</a> {
protected :
        T * p;          // Pointer to data
        int np;         // actual length
        int maxp;       // maximum allocated length np&lt;=maxp
    int byRef;  // if true, memory not owned by ArrayNew 

public:
        // constructors
        <a class="code" href="class_arraynew.html#a0">ArrayNew</a>() : np(0),maxp(0),byRef(0) { p = 0;};
        <a class="code" href="class_arraynew.html#a0">ArrayNew</a>(int n) { maxp = np = n; byRef = 0;
                     if (n == 0) p = 0; 
                                         else { p = <a class="code" href="class_array.html#a5">alloc</a>(np); }
                  };
        <a class="code" href="class_arraynew.html#a0">ArrayNew</a>(int n, const T iT);
        <a class="code" href="class_arraynew.html#a0">ArrayNew</a>(int n, const T* iT);
        <a class="code" href="class_arraynew.html#a0">ArrayNew</a>(const <a class="code" href="class_arraynew.html">ArrayNew</a>&lt;T&gt;&amp;);


        // allocation functions 
    T* <a class="code" href="class_array.html#a5">alloc</a>(int n);  
    T* <a class="code" href="class_array.html#a6">realloc</a>(T* pT, int n);
    void <a class="code" href="class_array.html#a7">free</a>(T* pT);


        //@cmember destructor
        <a class="code" href="class_arraynew.html#a8">~ArrayNew</a>();
        
        void <a class="code" href="class_astream.html#a3">Flush</a>();

        // assignment
        <a class="code" href="class_arraynew.html">ArrayNew</a>&lt;T&gt;&amp;    operator=(const <a class="code" href="class_arraynew.html">ArrayNew</a>&lt;T&gt;&amp;);

        // Set

        <a class="code" href="class_arraynew.html">ArrayNew</a>&lt;T&gt;&amp; <a class="code" href="class_array.html#a11">Set</a>(const <a class="code" href="class_arraynew.html">ArrayNew</a>&lt;T&gt;&amp; <a class="code" href="class_a.html">a</a>);
        <a class="code" href="class_arraynew.html">ArrayNew</a>&lt;T&gt;&amp; <a class="code" href="class_array.html#a14">SetByMove</a>(const <a class="code" href="class_arraynew.html">ArrayNew</a>&lt;T&gt;&amp; <a class="code" href="class_a.html">a</a>);
        <a class="code" href="class_arraynew.html">ArrayNew</a>&lt;T&gt;&amp; <a class="code" href="class_array.html#a11">Set</a>(int n, const T *iT);
        <a class="code" href="class_arraynew.html">ArrayNew</a>&lt;T&gt;&amp; <a class="code" href="class_array.html#a11">Set</a>(int n, const T val);

        <a class="code" href="class_arraynew.html">ArrayNew</a>&lt;T&gt;&amp; <a class="code" href="class_arraynew.html#a15">SetToRef</a>(const <a class="code" href="class_arraynew.html">ArrayNew</a>&lt;T&gt;&amp; <a class="code" href="class_a.html">a</a>);
    <a class="code" href="class_arraynew.html">ArrayNew</a>&lt;T&gt;&amp; <a class="code" href="class_arraynew.html#a15">SetToRef</a>(int n, const T *iT);
        <a class="code" href="class_arraynew.html">ArrayNew</a>&lt;T&gt;&amp; <a class="code" href="class_array.html#a17">UnRef</a>();

        // access
        const T*        <a class="code" href="class_array.html#a19">Data</a>() const {return p;}
        T*              <a class="code" href="class_array.html#a19">Data</a>() {return p;}
        
    int <a class="code" href="class_array.html#a21">Length</a>() const { return np; }
        int     <a class="code" href="class_array.html#a22">MaxLength</a>() const { return maxp; }
    int <a class="code" href="class_array.html#a23">ByRef</a>() const { return byRef; }

        operator T*()   { return p; }
        operator const T*() const { return p; }


        T&amp;              operator()(int i)       { return p[i]; };
        T               operator()(int i) const { return p[i]; };
        
        T&amp;              operator[](int i)
        { /* if (i&lt;0 || i&gt;=np) callerror(ArrayNew,T,1,"ArrayNew index out of range."); */
                return p[i]; 
        };
        
        T               operator[](int i) const
        {  /* if (i&lt;0 || i&gt;=np) callerror(ArrayNew,T,1,"ArrayNew index out of range."); */
                return p[i]; 
        };

        // set length to n, make sure buffer fits, exact = 1 buffer will be reallocated
        void <a class="code" href="class_array.html#a32">Resize</a>(int N,int exact=0);

        // Set Length of ArrayNew 
        void <a class="code" href="class_array.html#a33">SetLength</a>(int NewLength) { <a class="code" href="class_array.html#a32">Resize</a>(NewLength); }

        // Set Maximum Length of ArrayNew, usefull to preallocate space 
        void <a class="code" href="class_array.html#a34">SetMaxLength</a>(int NewLength) { 
               int l=<a class="code" href="class_array.html#a21">Length</a>();
                                   <a class="code" href="class_array.html#a32">Resize</a>(NewLength);
                                   if (l&lt;maxp) np=l;
                                };

        void            <a class="code" href="class_array.html#a35">Swap</a>(int i,int j);
        
        <a class="code" href="class_arraynew.html">ArrayNew</a>&lt;T&gt;&amp;    <a class="code" href="class_array.html#a36">Append</a>(const <a class="code" href="class_arraynew.html">ArrayNew</a>&lt;T&gt;&amp;);
        <a class="code" href="class_arraynew.html">ArrayNew</a>&lt;T&gt;&amp;    <a class="code" href="class_array.html#a36">Append</a>(int n, const T*);
        <a class="code" href="class_arraynew.html">ArrayNew</a>&lt;T&gt;&amp;    <a class="code" href="class_array.html#a36">Append</a>(T);
        
        <a class="code" href="class_arraynew.html">ArrayNew</a>&lt;T&gt;&amp;    <a class="code" href="class_array.html#a39">Insert</a>(int ofs, const <a class="code" href="class_arraynew.html">ArrayNew</a>&lt;T&gt;&amp; <a class="code" href="class_a.html">a</a>);
        <a class="code" href="class_arraynew.html">ArrayNew</a>&lt;T&gt;&amp;    <a class="code" href="class_array.html#a40">Delete</a>(int ofs, int cnt);

        int     <a class="code" href="class_array.html#a41">Search</a>(const T val,int start=0);

        // io
        int <a class="code" href="class_astream.html#a48">io</a>(<a class="code" href="class_astream.html">AStream</a> &amp;<a class="code" href="class_a.html">a</a>);
};


template&lt;class T&gt;
T * <a class="code" href="class_arraynew.html">ArrayNew</a>&lt;T&gt;::alloc(int n)   
{ 
        return new T[n];  
}

template&lt;class T&gt;
T * <a class="code" href="class_arraynew.html">ArrayNew</a>&lt;T&gt;::realloc(T * pT,int N)
{

   T* newArrayNew = <a class="code" href="class_array.html#a5">alloc</a>(N);
   register int i = (N&lt;=np) ? N:np;
   register const T* src = pT;
   register T* dst = newArrayNew;
   if (src) {
      while (i--) *dst++ = *src++;
      if (!byRef) <a class="code" href="class_array.html#a7">free</a>(pT);
   }
   return(newArrayNew);
}

template&lt;class T&gt;
void <a class="code" href="class_arraynew.html">ArrayNew</a>&lt;T&gt;::free(T* pT)  
{  
        delete[] pT; 
}



// constructors

template&lt;class T&gt;
<a class="code" href="class_arraynew.html">ArrayNew</a>&lt;T&gt;::<a class="code" href="class_arraynew.html">ArrayNew</a>(int n, const T iT)
{
  register int i = maxp = np = n;
  byRef=0;
  if (i == 0) { p = 0; }
  else {
        register T* dst = p = <a class="code" href="class_array.html#a5">alloc</a>(i);
        while(i--) *dst++ = iT;
  }
};

template&lt;class T&gt;
<a class="code" href="class_arraynew.html">ArrayNew</a>&lt;T&gt;::<a class="code" href="class_arraynew.html">ArrayNew</a>(const <a class="code" href="class_arraynew.html">ArrayNew</a>&lt;T&gt;&amp; <a class="code" href="class_a.html">a</a>)
{
  register int i = maxp = np = <a class="code" href="class_a.html">a</a>.np;
  byRef=0;
  if (i == 0) {
     p= 0;
  } else {
        register T* dst = p = <a class="code" href="class_array.html#a5">alloc</a>(i);
        register const T* src = <a class="code" href="class_a.html">a</a>.p;
        while (i--) *dst++ = *src++;
  }
};

template&lt;class T&gt;
<a class="code" href="class_arraynew.html">ArrayNew</a>&lt;T&gt;::<a class="code" href="class_arraynew.html">ArrayNew</a>(int n, const T *iT)
{
  register int i= maxp = np = n;
  byRef = 0;
  if (i == 0) {
     p= 0;
  } else {
        register T* dst = p = <a class="code" href="class_array.html#a5">alloc</a>(i);
        register const T* src = iT;
        if (src) while (i--) *dst++ = *src++;
  }
};

template&lt;class T&gt;
<a class="code" href="class_arraynew.html">ArrayNew</a>&lt;T&gt;::~<a class="code" href="class_arraynew.html">ArrayNew</a>() { 
        if (!byRef) <a class="code" href="class_array.html#a7">free</a>(p); p=0; byRef= 0; 
}

template&lt;class T&gt;
void <a class="code" href="class_arraynew.html">ArrayNew</a>&lt;T&gt;::Flush()       
{ 
        if (!byRef) <a class="code" href="class_array.html#a7">free</a>(p); maxp= np =0; p = 0; byRef = 0;
}


template&lt;class T&gt;
<a class="code" href="class_arraynew.html">ArrayNew</a>&lt;T&gt;&amp;
<a class="code" href="class_arraynew.html">ArrayNew</a>&lt;T&gt;::Set(const <a class="code" href="class_arraynew.html">ArrayNew</a>&lt;T&gt;&amp; <a class="code" href="class_a.html">a</a>)
{
  if(this != &amp;<a class="code" href="class_a.html">a</a>){
         <a class="code" href="class_array.html#a32">Resize</a>(a.np);
    register int i=<a class="code" href="class_a.html">a</a>.np;
    register T* dst = p ;
    register const T* src = <a class="code" href="class_a.html">a</a>.p;
    if (src) while (i--) *dst++ = *src++;
  }
  return *this;
};

// "copy" ArrayNew contents from a to self
// by taking over "a" data ptrs
// a will be empty after this operation
template&lt;class T&gt;
<a class="code" href="class_arraynew.html">ArrayNew</a>&lt;T&gt;&amp;
<a class="code" href="class_arraynew.html">ArrayNew</a>&lt;T&gt;::SetByMove(const <a class="code" href="class_arraynew.html">ArrayNew</a>&lt;T&gt;&amp; <a class="code" href="class_a.html">a</a>)
{
  if(this != &amp;<a class="code" href="class_a.html">a</a>){
        <a class="code" href="class_astream.html#a3">Flush</a>();
        np=<a class="code" href="class_a.html">a</a>.np;
        p=<a class="code" href="class_a.html">a</a>.p;
        maxp=<a class="code" href="class_a.html">a</a>.maxp;
        <a class="code" href="class_a.html">a</a>.np=<a class="code" href="class_a.html">a</a>.maxp=0; <a class="code" href="class_a.html">a</a>.p = 0;
  }
  return *this;
};

template&lt;class T&gt;
<a class="code" href="class_arraynew.html">ArrayNew</a>&lt;T&gt;&amp;
<a class="code" href="class_arraynew.html">ArrayNew</a>&lt;T&gt;::Set(int n, const T *iT)
{
  if (p != iT) {
    <a class="code" href="class_array.html#a32">Resize</a>(n);
    register int i=n;
    register T* dst = p ;
    register const T* src = iT;
    if (src) while (i--) *dst++ = *src++;
  } else <a class="code" href="class_array.html#a32">Resize</a>(n);
  return *this;
};



template&lt;class T&gt;
<a class="code" href="class_arraynew.html">ArrayNew</a>&lt;T&gt;&amp;
<a class="code" href="class_arraynew.html">ArrayNew</a>&lt;T&gt;::Set(int n, const T val)
{
    <a class="code" href="class_array.html#a32">Resize</a>(n);
    register int i=n;
    register T* dst = p ;
    while (i--) *dst++ = val;
  return *this;
};

// "copy" ArrayNew contents from a to self
// by taking over "a" data ptrs
// and set byRef flag

template&lt;class T&gt;
<a class="code" href="class_arraynew.html">ArrayNew</a>&lt;T&gt;&amp;
<a class="code" href="class_arraynew.html">ArrayNew</a>&lt;T&gt;::SetToRef(const <a class="code" href="class_arraynew.html">ArrayNew</a>&lt;T&gt;&amp; <a class="code" href="class_a.html">a</a>)
{
  if(this != &amp;<a class="code" href="class_a.html">a</a>){
        <a class="code" href="class_astream.html#a3">Flush</a>();
        np=<a class="code" href="class_a.html">a</a>.np;
        p=<a class="code" href="class_a.html">a</a>.p;
        maxp=<a class="code" href="class_a.html">a</a>.maxp;
   byRef=1;
  }
  return *this;
};

// "copy" ArrayNew contents from a to self
// by taking over "a" data ptrs
// and set byRef flag

template&lt;class T&gt;
<a class="code" href="class_arraynew.html">ArrayNew</a>&lt;T&gt;&amp;
<a class="code" href="class_arraynew.html">ArrayNew</a>&lt;T&gt;::SetToRef(int n, const T *iT)
{
        <a class="code" href="class_astream.html#a3">Flush</a>();
        np=n;
        p=iT;
        maxp=n;
   byRef=1;
  return *this;
};

// own memory
// 
template&lt;class T&gt;
<a class="code" href="class_arraynew.html">ArrayNew</a>&lt;T&gt;&amp; 
<a class="code" href="class_arraynew.html">ArrayNew</a>&lt;T&gt;::UnRef()
{
  if (byRef) <a class="code" href="class_array.html#a32">Resize</a>(np,1);
  return *this;
}



template&lt;class T&gt;
<a class="code" href="class_arraynew.html">ArrayNew</a>&lt;T&gt;&amp;
<a class="code" href="class_arraynew.html">ArrayNew</a>&lt;T&gt;::operator=(const <a class="code" href="class_arraynew.html">ArrayNew</a>&lt;T&gt;&amp; <a class="code" href="class_a.html">a</a>)
{
  return <a class="code" href="class_array.html#a11">Set</a>(<a class="code" href="class_a.html">a</a>);
};

template&lt;class T&gt;
void
<a class="code" href="class_arraynew.html">ArrayNew</a>&lt;T&gt;::Resize(int N,int exact)
{
  if (!exact) {
     if (N&lt;=maxp) {  // new size fits in buffer
            np=N;   // set length
            return;
     }
  } else {
    if (N==maxp &amp;&amp; !byRef) {
           np=N;
           return;
        }
  }
  
  if (!byRef) {   // we own the memory, call realloc
   p = <a class="code" href="class_array.html#a6">realloc</a>(p,N);
  } else {

   T* newArrayNew = <a class="code" href="class_array.html#a5">alloc</a>(N);
   register int i = (N&lt;=np) ? N:np;
   register const T* src = p;
   register T* dst = newArrayNew;
   if (src) {
      while (i--) *dst++ = *src++;
      if (!byRef) <a class="code" href="class_array.html#a7">free</a>(p);
   }
   p = newArrayNew;
   byRef=0;
  }
  maxp = np = N;
};

template&lt;class T&gt;
void
<a class="code" href="class_arraynew.html">ArrayNew</a>&lt;T&gt;::Swap(int i,int j)
{ T  tmp(p[i]);
  p[i] = p[j];
  p[j] = tmp;
};

template&lt;class T&gt;
<a class="code" href="class_arraynew.html">ArrayNew</a>&lt;T&gt;&amp;
<a class="code" href="class_arraynew.html">ArrayNew</a>&lt;T&gt;::Append(const <a class="code" href="class_arraynew.html">ArrayNew</a>&lt;T&gt;&amp; <a class="code" href="class_a.html">a</a>)
{

  return(<a class="code" href="class_array.html#a36">Append</a>(a.np,a.p));
};


template&lt;class T&gt;
<a class="code" href="class_arraynew.html">ArrayNew</a>&lt;T&gt;&amp;
<a class="code" href="class_arraynew.html">ArrayNew</a>&lt;T&gt;::Append(int n,const T* iT)
{
  register int i= n;
  register T* dst;
  register const T* src = iT;
  int start = np;
  // check for overflow ,test
  if ((np+n) &gt; maxp) {
        if (n &lt; ArrayNew_EXPANSION) {
        // new 9.04.96
        if (maxp&lt;ArrayNew_EXPANSION) 
          <a class="code" href="class_array.html#a34">SetMaxLength</a>(np+max(n,maxp*2));
                else <a class="code" href="class_array.html#a34">SetMaxLength</a>(maxp+ArrayNew_EXPANSION);
        }
        else <a class="code" href="class_array.html#a34">SetMaxLength</a>(np+n);        // expand me
  }
  np+=n;

  dst = &amp; p[start];     // point after old end
  while (i--) *dst++ = *src++;
  return(*this);
};

template&lt;class T&gt;
<a class="code" href="class_arraynew.html">ArrayNew</a>&lt;T&gt;&amp;
<a class="code" href="class_arraynew.html">ArrayNew</a>&lt;T&gt;::Append(T <a class="code" href="class_a.html">a</a>)
{
  register int i= np;
  if (np == maxp) {
      // new 9.04.96
      if (maxp&lt;ArrayNew_EXPANSION) 
          <a class="code" href="class_array.html#a32">Resize</a>(np+max(1,maxp*2));
      else
        <a class="code" href="class_array.html#a32">Resize</a>(np+ArrayNew_EXPANSION /* 1 */); // expand me
  }  
  p[i]  = <a class="code" href="class_a.html">a</a>;
  np = i+1;
  return(*this);
};

template&lt;class T&gt;
<a class="code" href="class_arraynew.html">ArrayNew</a>&lt;T&gt;&amp;
<a class="code" href="class_arraynew.html">ArrayNew</a>&lt;T&gt;::Insert(int ofs, const <a class="code" href="class_arraynew.html">ArrayNew</a>&lt;T&gt;&amp; <a class="code" href="class_a.html">a</a>)
{
  register int i;
  register T* dst;
  register T* src;
  int start = np;

  if (!<a class="code" href="class_a.html">a</a>) return(*this);
  if (ofs &lt;0) ofs = np-ofs;
  if (ofs&lt;0) ofs = 0;

  <a class="code" href="class_array.html#a32">Resize</a>(np+a.np);      // expand me

  i = start-ofs;
  // shift right to make space
  dst = &amp; p[ofs+<a class="code" href="class_a.html">a</a>.np +i-1];
  src = &amp; p[ofs+ i-1];
  while (i--) *dst-- = *src --;

  // copy over a
  dst = &amp; p[ofs];
  src = <a class="code" href="class_a.html">a</a>.p;
  i= <a class="code" href="class_a.html">a</a>.np;
  while (i--) *dst++ = *src++;
  return(*this);
};

template&lt;class T&gt;
<a class="code" href="class_arraynew.html">ArrayNew</a>&lt;T&gt;&amp;
<a class="code" href="class_arraynew.html">ArrayNew</a>&lt;T&gt;::Delete(int ofs, int cnt)
{
  register int i;
  register T* dst;
  register T* src;

  if (!p) return(*this); /* empty */
  if (ofs &lt;0) ofs = np-ofs;
  if (ofs&lt;0) ofs = 0;
  if (cnt &lt;0) cnt = np -ofs; // delete to end
  if ((ofs+cnt) &gt; np) {
        // Error invalid numbers
        cnt = np -ofs;
  }

  // shift left
  dst = &amp; p[ofs];
  src = &amp; p[ofs+cnt];
  i= np-ofs-cnt;
  while (i--) *dst++ = *src++;
  <a class="code" href="class_array.html#a32">Resize</a>(np-cnt);  // make smaller
  return(*this);
}

template&lt;class T&gt;
int
<a class="code" href="class_arraynew.html">ArrayNew</a>&lt;T&gt;::Search(const T val,int start)
{
    register int i=np;
    if (start &gt;= np) return(-1);

    register T* src = p+start ;
    do {
        if ( *src == val) return( src-p);
        src ++;
    } while ( i-- &gt; 0);
        return(-1);
};


/*
template&lt;class T&gt;
void  ArrayNew&lt;T&gt;::print(ostream &amp;os)
{
  register int i = np;
  register T* dst = p ;
  os &lt;&lt; "(";
  while(i--)  {
     os &lt;&lt; *dst++;
     if (i&gt;0) os &lt;&lt; ", ";
  }
  os &lt;&lt; ")";
};
*/
// io
template&lt;class T&gt;
int 
<a class="code" href="class_arraynew.html">ArrayNew</a>&lt;T&gt;::io(<a class="code" href="class_astream.html">AStream</a> &amp;<a class="code" href="class_a.html">a</a>)
{ int i;

  T  newelement;

  if (<a class="code" href="class_a.html">a</a>.BeginList()) {
   if (<a class="code" href="class_a.html">a</a>.isOutput()) {
     for(i=0;i&lt;np;i++) {
            if (i&gt;0) <a class="code" href="class_a.html">a</a>.ListSep();
            if ((i % 16) == 15) <a class="code" href="class_a.html">a</a>.nl();
            p[i].io(<a class="code" href="class_a.html">a</a>);
            //a.io(p[i]);
     }
   } else {
     np=0;
     /* read while ( until closing paren */
     while (<a class="code" href="class_a.html">a</a>.Skip() != <a class="code" href="class_a.html">a</a>.list_close) {
           if (<a class="code" href="class_a.html">a</a>.eof) break;
           newelement.<a class="code" href="class_astream.html#a48">io</a>(<a class="code" href="class_a.html">a</a>);
           //a.io(newelement);
           if (np==maxp)  <a class="code" href="class_array.html#a34">SetMaxLength</a>((np+8) + (np/2)); // make ArrayNew bigger 10 + 50 %
           <a class="code" href="class_array.html#a36">Append</a>(newelement);  // to do: ? no separate copy
           // to do:list separator
     }
  }

  <a class="code" href="class_a.html">a</a>.EndList();
  }
  return (<a class="code" href="class_a.html">a</a>.stat);
}

// Macro to define a templates unary operator

#define  IMPLEMENT_ArrayNewUnaryOp(OPMNAME,OP,ARGDECL,ARG) \
template&lt;class T&gt;                                       \
<a class="code" href="class_arraynew.html">ArrayNew</a>&lt;T&gt;::OPNAME(ARGDECL)                            \
{                                                       \
  register int i = np;                          \
  register T* dst = p ;                                 \
  while(i--) *dst++ OP ARG;                             \
};


template&lt;class T&gt;
class <a class="code" href="class_numericarraynew.html">NumericArrayNew</a> : public <a class="code" href="class_arraynew.html">ArrayNew</a>&lt;T&gt;
{
public:
        <a class="code" href="class_numericarraynew.html#a0">NumericArrayNew</a>() : <a class="code" href="class_arraynew.html">ArrayNew</a>&lt;T&gt;()       {};
        <a class="code" href="class_numericarraynew.html#a0">NumericArrayNew</a>(int n) : <a class="code" href="class_arraynew.html">ArrayNew</a>&lt;T&gt;(n) {};
        <a class="code" href="class_numericarraynew.html#a0">NumericArrayNew</a>(int n, const T iT): <a class="code" href="class_arraynew.html">ArrayNew</a>&lt;T&gt;(n,iT) {};
        <a class="code" href="class_numericarraynew.html#a0">NumericArrayNew</a>(int n, const T *iT): <a class="code" href="class_arraynew.html">ArrayNew</a>&lt;T&gt;(n,iT) {};
        <a class="code" href="class_numericarraynew.html#a0">NumericArrayNew</a>(const <a class="code" href="class_numericarraynew.html">NumericArrayNew</a> &amp; arg): <a class="code" href="class_arraynew.html">ArrayNew</a>&lt;T&gt;(arg) {};

        <a class="code" href="class_numericarraynew.html">NumericArrayNew</a>&lt;T&gt;&amp;    operator+=(const T Arg);
        <a class="code" href="class_numericarraynew.html">NumericArrayNew</a>&lt;T&gt;&amp;    operator-=(const T Arg);
        <a class="code" href="class_numericarraynew.html">NumericArrayNew</a>&lt;T&gt;&amp;    operator*=(const T Arg);
        <a class="code" href="class_numericarraynew.html">NumericArrayNew</a>&lt;T&gt;&amp;    operator/=(const T Arg);
   /* */
        <a class="code" href="class_numericarraynew.html">NumericArrayNew</a>&lt;T&gt;&amp;    operator+=(const <a class="code" href="class_numericarraynew.html">NumericArrayNew</a>&lt;T&gt;&amp; Arg);
        <a class="code" href="class_numericarraynew.html">NumericArrayNew</a>&lt;T&gt;&amp;    operator-=(const <a class="code" href="class_numericarraynew.html">NumericArrayNew</a>&lt;T&gt;&amp; Arg);
        <a class="code" href="class_numericarraynew.html">NumericArrayNew</a>&lt;T&gt;&amp;    operator*=(const <a class="code" href="class_numericarraynew.html">NumericArrayNew</a>&lt;T&gt;&amp; Arg);
        <a class="code" href="class_numericarraynew.html">NumericArrayNew</a>&lt;T&gt;&amp;    operator/=(const <a class="code" href="class_numericarraynew.html">NumericArrayNew</a>&lt;T&gt;&amp; Arg);
};

template&lt;class T&gt;
<a class="code" href="class_numericarraynew.html">NumericArrayNew</a>&lt;T&gt;&amp; <a class="code" href="class_numericarraynew.html">NumericArrayNew</a>&lt;T&gt;::operator*=(const T Arg)
{
  register int i = np;
  register T* dst = p ;
  while (i--) *dst++ *= Arg;
  return (*this);
};

template&lt;class T&gt;
<a class="code" href="class_numericarraynew.html">NumericArrayNew</a>&lt;T&gt;&amp; <a class="code" href="class_numericarraynew.html">NumericArrayNew</a>&lt;T&gt;::operator+=(const T Arg)
{
  register int i = np;
  register T* dst = p ;
  while(i--) *dst++ += Arg;
  return (*this);
};

template&lt;class T&gt;
<a class="code" href="class_numericarraynew.html">NumericArrayNew</a>&lt;T&gt;&amp; <a class="code" href="class_numericarraynew.html">NumericArrayNew</a>&lt;T&gt;::operator-=(const T Arg)
{
  register int i = np;
  register T* dst = p ;
  while(i--) *dst++ -= Arg;
  return (*this);
};


template&lt;class T&gt;
<a class="code" href="class_numericarraynew.html">NumericArrayNew</a>&lt;T&gt;&amp; <a class="code" href="class_numericarraynew.html">NumericArrayNew</a>&lt;T&gt;::operator/=(const T Arg)
{
  register int i = np;
  register T* dst = p ;
  while(i--) *dst++ /= Arg;
  return (*this);
};

template&lt;class T&gt;
<a class="code" href="class_numericarraynew.html">NumericArrayNew</a>&lt;T&gt;&amp; <a class="code" href="class_numericarraynew.html">NumericArrayNew</a>&lt;T&gt;::operator+=(const <a class="code" href="class_numericarraynew.html">NumericArrayNew</a>&lt;T&gt;&amp; Arg)
{
  register int i = np;
  register T* src = Arg.p ;
  register T* dst = p ;
  if (i&gt;Arg.np) i=Arg.np;
  while (i--) *dst++ += *src++;
  return (*this);
};

template&lt;class T&gt;
<a class="code" href="class_numericarraynew.html">NumericArrayNew</a>&lt;T&gt;&amp; <a class="code" href="class_numericarraynew.html">NumericArrayNew</a>&lt;T&gt;::operator*=(const <a class="code" href="class_numericarraynew.html">NumericArrayNew</a>&lt;T&gt;&amp; Arg)
{
  register int i = np;
  register T* src = Arg.p ;
  register T* dst = p ;
  if (i&gt;Arg.np) i=Arg.np;
  while (i--) *dst++ *= *src++;
  return (*this);
};

// Predifined ArrayNewclasses
// one Reason : because int &amp; float have no io member function
//

#if 0
class IntArrayNew : public <a class="code" href="class_numericarraynew.html">NumericArrayNew</a>&lt;int&gt; {
public:
        // constructors
        IntArrayNew() : <a class="code" href="class_numericarraynew.html">NumericArrayNew</a>&lt;int&gt;()  {};
        IntArrayNew(int n) : <a class="code" href="class_numericarraynew.html">NumericArrayNew</a>&lt;int&gt;(n) {};
        IntArrayNew(int n, const int iT): <a class="code" href="class_numericarraynew.html">NumericArrayNew</a>&lt;int&gt;(n,iT) {};
        IntArrayNew(int n, const int *iT): <a class="code" href="class_numericarraynew.html">NumericArrayNew</a>&lt;int&gt;(n,iT) {};
        IntArrayNew(const IntArrayNew &amp; arg): <a class="code" href="class_numericarraynew.html">NumericArrayNew</a>&lt;int&gt;(arg) {};
        int <a class="code" href="class_astream.html#a48">io</a>(<a class="code" href="class_astream.html">AStream</a> &amp;<a class="code" href="class_a.html">a</a>);

};


class FloatArrayNew : public <a class="code" href="class_numericarraynew.html">NumericArrayNew</a>&lt;float&gt; {
public:
        // constructors
        FloatArrayNew() : <a class="code" href="class_numericarraynew.html">NumericArrayNew</a>&lt;float&gt;()      {};
        FloatArrayNew(int n) : <a class="code" href="class_numericarraynew.html">NumericArrayNew</a>&lt;float&gt;(n) {};
        FloatArrayNew(int n, float iT): <a class="code" href="class_numericarraynew.html">NumericArrayNew</a>&lt;float&gt;(n,iT) {};
        FloatArrayNew(int n, float *iT): <a class="code" href="class_numericarraynew.html">NumericArrayNew</a>&lt;float&gt;(n,iT) {};
        FloatArrayNew(const FloatArrayNew &amp; arg): <a class="code" href="class_numericarraynew.html">NumericArrayNew</a>&lt;float&gt;(arg) {};
        int <a class="code" href="class_astream.html#a48">io</a>(<a class="code" href="class_astream.html">AStream</a> &amp;<a class="code" href="class_a.html">a</a>);
};




#endif
#endif

</div></pre><hr><address><small>Generated at Thu Jan 27 18:15:07 2000 for blaxxunContact3D by
<a href="http://www.stack.nl/~dimitri/doxygen/index.html">
<img src="doxygen.gif" alt="doxygen" align=center border=0 
width=118 height=53></a> 1.0.0 written by <a href="mailto:dimitri@stack.nl">Dimitri van Heesch</a>,
 &copy; 1997-1999</small></address>
</body>
</html>

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta name="robots" content="noindex">
<title>Ray Include File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body bgcolor="#ffffff">
<!-- Generated by Doxygen 1.0.0 on Thu Jan 27 18:51:22 2000 -->
<center>
<a class="qindex"href="index.html">Main Page</a> &nbsp; <a class="qindex"href="namespaces.html">Namespace List</a> &nbsp; <a class="qindex"href="hierarchy.html">Class Hierarchy</a> &nbsp; <a class="qindex"href="annotated.html">Compound List</a> &nbsp; <a class="qindex"href="files.html">File List</a> &nbsp; <a class="qindex"href="headers.html">Header Files</a> &nbsp; <a class="qindex"href="namespacemembers.html">Namespace Members</a> &nbsp; <a class="qindex"href="functions.html">Compound Members</a> &nbsp; <a class="qindex"href="globals.html">File Members</a> &nbsp; </center>
<hr><h1>point.h</h1>This is the verbatim text of the point.h include file.<div class="fragment"><pre>/*=============================================================================

This code is licensed under the Web3D-blaxxun Community Source License,
provided in distribution file LICENSE.TXT and available online at
http://www.web3D.org/TaskGroups/x3d/blaxxun/Web3D-blaxxunCommunitySourceAgreement.html
and may only be used for non-commercial use as specified in that license.

THE WEB3D CONSORTIUM AND BLAXXUN DO NOT MAKE AND HEREBY DISCLAIM ANY EXPRESS
OR IMPLIED WARRANTIES RELATING TO THIS CODE, INCLUDING BUT NOT LIMITED TO,
WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY OR FITNESS FOR A PARTICULAR
PURPOSE, OR ANY WARRANTIES THAT MIGHT ARISE FROM A COURSE OF DEALING, USAGE
OR TRADE PRACTICE.  THE COMMUNITY SOURCE CODE IS PROVIDED UNDER THIS
AGREEMENT "AS IS," WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
INCLUDING, WITHOUT LIMITATION, WARRANTIES THAT THE COMMUNITY SOURCE CODE ARE
FREE OF DEFECTS, MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE OR
NON-INFRINGING OR IN ANY WAY CONSTITUTE THE COMPLETE PRODUCT MARKETED UNDER
THE NAMES GIVEN SAID CODE.

==============================================================================*/
#ifndef _point_h
#define _point_h

/******************************************************************************
@doc
@module point.h - Generic Point + Vector (= Normal) class |     

Copyright (c) 1995 - 1998       by Holger Grahn
All rights reserved

Purpose:
Generic Point + Vector (= Normal) class 

Classes:
&lt;c Point&gt;               three element vector x,y,z
        &lt;c Vector&gt;

&lt;c Plane&gt;               a plane defined by normal and distance from origin

&lt;c BBox&gt;                a box defined by min and may points

&lt;c Ray&gt;

Notes:

Changes:

Todo :

******************************************************************************/



//#include "array.h"
#include &lt;math.h&gt;

#include "gutils.h"


class <a class="code" href="class_astream.html">AStream</a>;
class <a class="code" href="class_matrix.html">Matrix</a>;
//class ostream;




// assuming Point = point
// used for static initializer
typedef struct { 
        float x,y,z; 
} <a class="code" href="class_point_.html">point_</a>;


/*

Point
@class
a 3d point without virtual functions
*/

class <a class="code" href="class_point.html">Point</a> {
        public:
        
        float x,y,z;

        // constructors
        inline <a class="code" href="class_point.html#a0">Point</a>(float v_=0.0) { x=v_; y=v_; z=v_; }
        inline <a class="code" href="class_point.html#a0">Point</a>(const float v[3]) { x=v[0]; y=v[1]; z=v[2];}
        inline <a class="code" href="class_point.html#a0">Point</a>(float x_, float y_, float z_=0.0) { x=x_; y=y_; z=z_; }
        inline <a class="code" href="class_point.html#a0">Point</a>(const <a class="code" href="class_point.html">Point</a> &amp;p) { x=p.x; y=p.y; z=p.z; }

        // Access
        inline float&amp; operator[] (int i) {
                //if (i == 0) return x; else if (i == 1) return y; else return z;
                return *((&amp;x)+i); // assume continous memory
        }

        inline const float&amp; operator[] (int i) const {
                // if (i == 0) return x; else if (i == 1) return y;else return z;
                return *((&amp;x)+i); // assume continous memory
        }

#ifdef _D3D
    inline operator D3DVECTOR&amp;() { return * ((D3DVECTOR *) &amp;x); } 
    inline operator const D3DVECTOR&amp;() const  { return * ((D3DVECTOR *) &amp;x); } 

    // convert to/ from D3D colorvalue 
        inline void <a class="code" href="class_point.html#a6">Set</a>(const D3DCOLORVALUE &amp;p) { x=p.r; y=p.g; z=p.b; }
        inline void Get(D3DCOLORVALUE &amp;p,D3DVALUE alpha=1.0) const { p.r=x; p.g=y; p.b =z; p.a = alpha;}

#endif

        /* assigments */
        inline void <a class="code" href="class_point.html#a6">Set</a>(float x_=0.0, float y_=0.0, float z_=0.0) { x=x_; y=y_; z=z_; }
        inline void <a class="code" href="class_point.html#a6">Set</a>(const <a class="code" href="class_point.html">Point</a> &amp;p) { x=p.x; y=p.y; z=p.z; }
        inline void <a class="code" href="class_point.html#a6">Set</a>(const float v[3]) { x=v[0]; y=v[1]; z=v[2]; }

        inline <a class="code" href="class_point.html">Point</a> &amp; <a class="code" href="class_point.html#a9">Zero</a>() { x=y=z=0.0; return(*this); }
        inline <a class="code" href="class_point.html">Point</a> &amp; <a class="code" href="class_point.html#a10">One</a>() { x=y=z=1.0; return(*this); }

        const char *<a class="code" href="class_point.html#a11">ClassName</a>() const { return ("Point"); }


        /* misc */
        inline float <a class="code" href="class_point.html#a12">Len2</a>() const { return (x*x + y*y + z*z); }         // squared length
        inline float <a class="code" href="class_point.html#a13">Len</a>() const { return sqrt(<a class="code" href="class_point.html#a12">Len2</a>()); }               // vector length
        inline float <a class="code" href="class_point.html#a14">Length</a>() const { return sqrt(<a class="code" href="class_point.html#a12">Len2</a>()); }            // vector length
        inline float <a class="code" href="class_point.html#a15">ManhattanLen</a>() const { return (fabs(x)+fabs(y)+fabs(z)); } // vector length

        /* operators */

        // Unary operators returning a new point
        <a class="code" href="class_point.html">Point</a> operator- () const;
        <a class="code" href="class_point.html">Point</a> operator+ () const;


        // Assignment operators
        <a class="code" href="class_point.html">Point</a>&amp; operator+= (const <a class="code" href="class_point.html">Point</a>&amp; A);
        <a class="code" href="class_point.html">Point</a>&amp; operator-= (const <a class="code" href="class_point.html">Point</a>&amp; A);
        <a class="code" href="class_point.html">Point</a>&amp; operator*= (const <a class="code" href="class_point.html">Point</a>&amp; A);
        <a class="code" href="class_point.html">Point</a>&amp; operator/= (const <a class="code" href="class_point.html">Point</a>&amp; A);
        <a class="code" href="class_point.html">Point</a>&amp; operator+= (float A);
        <a class="code" href="class_point.html">Point</a>&amp; operator-= (float A);
        <a class="code" href="class_point.html">Point</a>&amp; operator*= (float A);
        <a class="code" href="class_point.html">Point</a>&amp; operator/= (float A);


        // normalize point
        inline <a class="code" href="class_point.html">Point</a>&amp; <a class="code" href="class_point.html#a26">Normalize</a>()       { float l=<a class="code" href="class_point.html#a13">Len</a>();
                if (l != 0.0) l= 1.0/l; else l=1.0;
                x *= l; y *=l; z*=l; return(*this);
                }

        // Binary operators returning a new point
        friend <a class="code" href="class_point.html">Point</a> operator+ (const <a class="code" href="class_point.html">Point</a>&amp; A, const <a class="code" href="class_point.html">Point</a>&amp; B);
        friend <a class="code" href="class_point.html">Point</a> operator- (const <a class="code" href="class_point.html">Point</a>&amp; A, const <a class="code" href="class_point.html">Point</a>&amp; B);
        friend <a class="code" href="class_point.html">Point</a> operator* (const <a class="code" href="class_point.html">Point</a>&amp; A, const <a class="code" href="class_point.html">Point</a>&amp; B);
        friend <a class="code" href="class_point.html">Point</a> operator* (const <a class="code" href="class_point.html">Point</a>&amp; A, float B);
        friend <a class="code" href="class_point.html">Point</a> operator* (float A, const <a class="code" href="class_point.html">Point</a>&amp; B);
        friend <a class="code" href="class_point.html">Point</a> operator* (const <a class="code" href="class_matrix.html">Matrix</a>&amp;, const <a class="code" href="class_point.html">Point</a>&amp;);
        friend <a class="code" href="class_point.html">Point</a> operator/ (const <a class="code" href="class_point.html">Point</a>&amp; A, const <a class="code" href="class_point.html">Point</a>&amp; B);
        friend <a class="code" href="class_point.html">Point</a> operator/ (const <a class="code" href="class_point.html">Point</a>&amp; A, float B);

        friend int operator&lt; (const <a class="code" href="class_point.html">Point</a>&amp; A, const <a class="code" href="class_point.html">Point</a>&amp; B);

        friend int operator== (const <a class="code" href="class_point.html">Point</a>&amp; A, const <a class="code" href="class_point.html">Point</a>&amp; B);
        friend int operator!= (const <a class="code" href="class_point.html">Point</a>&amp; A, const <a class="code" href="class_point.html">Point</a>&amp; B);

        friend int <a class="code" href="class_point.html#l11">Equal</a>(const <a class="code" href="class_point.html">Point</a>&amp; A, const <a class="code" href="class_point.html">Point</a>&amp; B,float Epsilon=EPS);

        <a class="code" href="class_point.html">Point</a>&amp; operator*= (const <a class="code" href="class_matrix.html">Matrix</a> &amp;A) { <a class="code" href="class_point.html#a6">Set</a>(A* *this); return(*this); }

        inline float <a class="code" href="class_point.html#a28">Dot</a>(const <a class="code" href="class_point.html">Point</a>&amp; B) const
        {
                return x * B.x + y * B.y + z * B.z;
        }

        // return Dot Product

        friend float <a class="code" href="class_point.html#l12">DotProd</a>(const <a class="code" href="class_point.html">Point</a>&amp; A, const <a class="code" href="class_point.html">Point</a>&amp; B);
        
        inline <a class="code" href="class_point.html">Point</a>&amp; <a class="code" href="class_point.html#a29">Cross</a> (const <a class="code" href="class_point.html">Point</a>&amp; A, const <a class="code" href="class_point.html">Point</a>&amp; B)
        {
           <a class="code" href="class_point.html#a6">Set</a>(A.y * B.z - A.z * B.y,
                        A.z * B.x - A.x * B.z,
                        A.x * B.y - A.y * B.x);
        return(*this);
        }


        friend <a class="code" href="class_point.html">Point</a> <a class="code" href="class_point.html#l13">CrossProd</a> (const <a class="code" href="class_point.html">Point</a>&amp; A, const <a class="code" href="class_point.html">Point</a>&amp; B);

        friend <a class="code" href="class_point.html">Point</a> <a class="code" href="class_point.html#l14">NormCrossProd</a> (const <a class="code" href="class_point.html">Point</a>&amp; A, const <a class="code" href="class_point.html">Point</a>&amp; B);

        inline <a class="code" href="class_point.html">Point</a>&amp; <a class="code" href="class_point.html#a30">Interpolate</a> (float ta, const <a class="code" href="class_point.html">Point</a>&amp; B,float tb, <a class="code" href="class_point.html">Point</a> &amp;Result);

        friend inline <a class="code" href="class_point.html">Point</a> <a class="code" href="class_point.html#a30">Interpolate</a> (const <a class="code" href="class_point.html">Point</a>&amp; A, float ta, const <a class="code" href="class_point.html">Point</a>&amp; B,float tb);
        friend inline <a class="code" href="class_point.html">Point</a>&amp; <a class="code" href="class_point.html#a30">Interpolate</a> (const <a class="code" href="class_point.html">Point</a>&amp; A, float ta, const <a class="code" href="class_point.html">Point</a>&amp; B,float tb,<a class="code" href="class_point.html">Point</a> &amp;Result);

        // update minmax
        void <a class="code" href="class_point.html#a31">MinMax</a>(<a class="code" href="class_point.html">Point</a> &amp;mi,<a class="code" href="class_point.html">Point</a> &amp;ma) const;


    // Determine the dominant axis of point or normal
    inline int <a class="code" href="class_point.html#a32">Dominant</a>() const  {
        int axis = 0;
        float tMax = fabs(x);
        if (fabs(y) &gt; tMax) { 
                tMax = fabs(y);   
                axis = 1;
        }
        if (fabs(z) &gt; tMax)     
                axis = 2;               
        return(axis);
    }


    inline void <a class="code" href="class_point.html#a33">Project</a>(float&amp; px, float&amp; py, int axis) const {

        switch (axis) {
          case 0:
            px = y; py = z;
            break;
          case 1:
            px = x; py = z;
            break;
          default:
            px = x; py = y;
            break;
        }
    }
        
    inline void <a class="code" href="class_point.html#a34">ProjectIndex</a>(int&amp; px, int&amp; py, int axis) const {

        switch (axis) {
          case 0:
            px = 1; py = 2;
            break;
          case 1:
            px = 0; py = 2;
            break;
          default:
            px = 0; py = 1;
            break;
        }
    }


        void <a class="code" href="class_point.html#a35">Rotate</a>(const <a class="code" href="class_point.html">Point</a>&amp; AxisDir, float angle);
        void <a class="code" href="class_point.html#a35">Rotate</a>(const <a class="code" href="class_point.html">Point</a>&amp; AxisPt, const <a class="code" href="class_point.html">Point</a>&amp; AxisDir,float angle);

        friend class <a class="code" href="class_point.html">Point</a> RotateOnly(const <a class="code" href="class_matrix.html">Matrix</a>&amp; M, const <a class="code" href="class_point.html">Point</a>&amp; v);

    float <a class="code" href="class_point.html#a37">Angle</a>(const <a class="code" href="class_point.html">Point</a> &amp;v1) const {
                // return (double)acos(dot(v1)/v1.length()/v.length());

                float xx = y*v1.z - z*v1.y;
                float yy = z*v1.x - x*v1.z;
                float zz = x*v1.y - y*v1.x;
                float cross = sqrt(xx*xx + yy*yy + zz*zz);

                return fabs(atan2(cross, <a class="code" href="class_point.html#a28">Dot</a>(v1)));
    }



        /* io */
        //friend ostream&amp; operator&lt;&lt; (ostream &amp;os,const Point &amp;a);

        int <a class="code" href="class_point.html#a38">io</a>(<a class="code" href="class_astream.html">AStream</a> &amp;<a class="code" href="class_a.html">a</a>);
};

inline float <a class="code" href="point4.h.html#a0">Magnitude</a>(const <a class="code" href="class_point.html">Point</a>&amp; v)
{
        return sqrt(v.x*v.x + v.y*v.y + v.z*v.z);
}

inline <a class="code" href="class_point.html">Point</a> <a class="code" href="point4.h.html#a1">Normalize</a>(const <a class="code" href="class_point.html">Point</a>&amp; A)
{
        return A / <a class="code" href="point4.h.html#a0">Magnitude</a>(A);
}

inline float <a class="code" href="point4.h.html#a2">DotProd</a> (const <a class="code" href="class_point.html">Point</a>&amp; A, const <a class="code" href="class_point.html">Point</a>&amp; B)
{
        return A.x * B.x + A.y * B.y + A.z * B.z;
}

inline <a class="code" href="class_point.html">Point</a> Point::operator+ () const
{
        return *this;
}

inline <a class="code" href="class_point.html">Point</a> Point::operator- () const
{
        return Point(-x, -y, -z);
}

inline <a class="code" href="class_point.html">Point</a>&amp; Point::operator+= (const <a class="code" href="class_point.html">Point</a>&amp; A)
{
        x += A.x;  y += A.y; z += A.z;
        return *this;
}

inline <a class="code" href="class_point.html">Point</a>&amp; Point::operator-= (const <a class="code" href="class_point.html">Point</a>&amp; A)
{
        x -= A.x;  y -= A.y;  z -= A.z;
        return *this;
}

inline <a class="code" href="class_point.html">Point</a>&amp; Point::operator+= (float A)
{
        x += A;  y += A;  z += A;
        return *this;
}

inline <a class="code" href="class_point.html">Point</a>&amp; Point::operator-= (float A)
{
        x -= A;  y -= A;  z -= A;
        return *this;
}

inline <a class="code" href="class_point.html">Point</a>&amp; Point::operator*= (float A)
{
        x *= A;  y *= A;  z *= A;
        return *this;
}

inline <a class="code" href="class_point.html">Point</a>&amp; Point::operator/= (float A)
{
        x /= A;  y /= A;  z /= A;
        return *this;
}

inline <a class="code" href="class_point.html">Point</a>&amp; Point::operator*= (const <a class="code" href="class_point.html">Point</a>&amp; A)
{
        x *= A.x;  y *= A.y;  z *= A.z;
        return *this;
}

inline <a class="code" href="class_point.html">Point</a>&amp; Point::operator/= (const <a class="code" href="class_point.html">Point</a>&amp; A)
{
        x /= A.x;  y /= A.y;  z /= A.z;
        return *this;
}

inline <a class="code" href="class_point.html">Point</a> operator+ (const <a class="code" href="class_point.html">Point</a>&amp; A, const <a class="code" href="class_point.html">Point</a>&amp; B)
{
        return Point(A.x + B.x, A.y + B.y, A.z + B.z);
}

inline <a class="code" href="class_point.html">Point</a> operator- (const <a class="code" href="class_point.html">Point</a>&amp; A, const <a class="code" href="class_point.html">Point</a>&amp; B)
{
        return Point(A.x - B.x, A.y - B.y, A.z - B.z);
}

inline <a class="code" href="class_point.html">Point</a> operator* (const <a class="code" href="class_point.html">Point</a>&amp; A, const <a class="code" href="class_point.html">Point</a>&amp; B)
{
        return Point(A.x * B.x, A.y * B.y, A.z * B.z);
}

inline <a class="code" href="class_point.html">Point</a> operator* (const <a class="code" href="class_point.html">Point</a>&amp; A, float B)
{
        return Point(A.x * B, A.y * B, A.z * B);
}

inline <a class="code" href="class_point.html">Point</a> operator* (float A, const <a class="code" href="class_point.html">Point</a>&amp; B)
{
        return B * A;
}

inline <a class="code" href="class_point.html">Point</a> operator/ (const <a class="code" href="class_point.html">Point</a>&amp; A, const <a class="code" href="class_point.html">Point</a>&amp; B)
{
        return Point(A.x / B.x, A.y / B.y, A.z / B.z);
}

inline <a class="code" href="class_point.html">Point</a> operator/ (const <a class="code" href="class_point.html">Point</a>&amp; A, float B)
{
        return Point(A.x / B, A.y / B, A.z / B);
}

inline int operator&lt; (const <a class="code" href="class_point.html">Point</a>&amp; A, const <a class="code" href="class_point.html">Point</a>&amp; B)
{
        return A.x &lt; B.x &amp;&amp; A.y &lt; B.y &amp;&amp; A.z &lt; B.z;
}

inline int operator== (const <a class="code" href="class_point.html">Point</a>&amp; A, const <a class="code" href="class_point.html">Point</a>&amp; B)
{
        return (A.x == B.x) &amp;&amp; (A.y == B.y) &amp;&amp; (A.z == B.z);
}

inline int operator!= (const <a class="code" href="class_point.html">Point</a>&amp; A, const <a class="code" href="class_point.html">Point</a>&amp; B)
{
        return !(A == B);
}

inline int <a class="code" href="point4.h.html#a13">Equal</a>(const <a class="code" href="class_point.html">Point</a>&amp; A, const <a class="code" href="class_point.html">Point</a>&amp; B,float Epsilon)
{
        return  fabs(A.x - B.x) &lt;= Epsilon &amp;&amp;
                fabs(A.y -  B.y) &lt;= Epsilon &amp;&amp;
                fabs(A.z - B.z) &lt;= Epsilon;
}

inline <a class="code" href="class_point.html">Point</a> <a class="code" href="point4.h.html#a14">CrossProd</a> (const <a class="code" href="class_point.html">Point</a>&amp; A, const <a class="code" href="class_point.html">Point</a>&amp; B)
{
        return Point(A.y * B.z - A.z * B.y,
                        A.z * B.x - A.x * B.z,
                        A.x * B.y - A.y * B.x);
}

inline <a class="code" href="class_point.html">Point</a> <a class="code" href="point4.h.html#a15">NormCrossProd</a> (const <a class="code" href="class_point.html">Point</a>&amp; A, const <a class="code" href="class_point.html">Point</a>&amp; B)
{
        return (Point(A.y * B.z - A.z * B.y,
                        A.z * B.x - A.x * B.z,
                        A.x * B.y - A.y * B.x).Normalize());
}


inline <a class="code" href="class_point.html">Point</a>&amp; <a class="code" href="class_point.html#a30">Point::Interpolate</a> (float ta, const <a class="code" href="class_point.html">Point</a>&amp; B,float tb, <a class="code" href="class_point.html">Point</a> &amp;Result)
{
  Result = *this;
  Result *= ta;
  Result += B*tb;
  return(Result);
}

// a + (b-a) * t  == a * (1-t) + b * t
inline <a class="code" href="class_point.html">Point</a>&amp; <a class="code" href="point4.h.html#a16">Interpolate</a> (const <a class="code" href="class_point.html">Point</a>&amp; A, float ta, const <a class="code" href="class_point.html">Point</a>&amp; B,float tb, <a class="code" href="class_point.html">Point</a> &amp;Result)
{ Result = A;
  Result *= ta;
  Result += B*tb;
  return(Result);
}

inline <a class="code" href="class_point.html">Point</a> <a class="code" href="point4.h.html#a16">Interpolate</a> (const <a class="code" href="class_point.html">Point</a>&amp; A, float ta, const <a class="code" href="class_point.html">Point</a>&amp; B,float tb)
{ <a class="code" href="class_point.html">Point</a> result(A);
  result *= ta;
  result += B*tb;
  return(result);
}


// update minmax
inline void <a class="code" href="class_point.html#a31">Point::MinMax</a>(<a class="code" href="class_point.html">Point</a> &amp;mi,<a class="code" href="class_point.html">Point</a> &amp;ma) const
{
  if (x &lt; mi.x) mi.x = x; else if (x&gt;ma.x) ma.x=x;
  if (y &lt; mi.y) mi.y = y; else if (y&gt;ma.y) ma.y=y;
  if (z &lt; mi.z) mi.z = z; else if (z&gt;ma.z) ma.z=z;
}


class <a class="code" href="class_vector.html">Vector</a>    : public <a class="code" href="class_point.html">Point</a> {
public:
        // constructors

        <a class="code" href="class_vector.html#a0">Vector</a>(float v_=0.0) { x=v_; y=v_; z=v_; }
        <a class="code" href="class_vector.html#a0">Vector</a>(float x_, float y_, float z_=0.0) { x=x_; y=y_; z=z_; }
        <a class="code" href="class_vector.html#a0">Vector</a>(const <a class="code" href="class_point.html">Point</a> &amp;p) { x=p.x; y=p.y; z=p.z; }
        <a class="code" href="class_vector.html#a0">Vector</a>(const <a class="code" href="class_vector.html">Vector</a> &amp;p) { x=p.x; y=p.y; z=p.z; }

        <a class="code" href="class_vector.html">Vector</a> <a class="code" href="class_vector.html#a4">Reflect</a>(const <a class="code" href="class_vector.html">Vector</a> &amp; Normal) {
                return (Normal * ( 2.0 * <a class="code" href="class_point.html#l12">DotProd</a>(Normal,- *this )) + *this);
                }


//      friend Vector operator* (const Matrix&amp;, const Vector&amp;);

};



class <a class="code" href="class_plane.html">Plane</a>     {
public:
        <a class="code" href="class_vector.html">Vector</a> n;               
        float d;                

        inline <a class="code" href="class_plane.html#a0">Plane</a>() {}

        inline <a class="code" href="class_plane.html#a0">Plane</a>(const <a class="code" href="class_vector.html">Vector</a> &amp;normal,float D) : n(normal),d(D) {}
        
        inline <a class="code" href="class_plane.html#a0">Plane</a>(float A,float B,float C,float D): n(A,B,C),d(D) {}

        inline <a class="code" href="class_plane.html#a0">Plane</a>(const <a class="code" href="class_plane.html">Plane</a> &amp;p): n(p.n),d(p.d) {}

        inline <a class="code" href="class_vector.html">Vector</a>&amp; <a class="code" href="class_plane.html#a4">Normal</a>() { return(n); }

        inline void <a class="code" href="class_point.html#a6">Set</a>(const <a class="code" href="class_point.html">Point</a> &amp;p, const <a class="code" href="class_vector.html">Vector</a> &amp;N) {
                n=N;
                n.<a class="code" href="class_point.html#a26">Normalize</a>();
                d = -<a class="code" href="class_point.html#l12">DotProd</a>(p,n);
        }

        inline void <a class="code" href="class_point.html#a6">Set</a>(const <a class="code" href="class_plane.html">Plane</a> &amp;p) { n = p.n, d=p.d; }

        
        inline void <a class="code" href="class_point.html#a6">Set</a>(const <a class="code" href="class_vector.html">Vector</a> &amp;normal,float D) { n.<a class="code" href="class_point.html#a6">Set</a>(normal), d = D; }

        inline void <a class="code" href="class_point.html#a6">Set</a>(const <a class="code" href="class_point.html">Point</a> &amp;p0,const <a class="code" href="class_point.html">Point</a> &amp;p1,const <a class="code" href="class_point.html">Point</a> &amp;p2) { <a class="code" href="class_point.html#a6">Set</a>(<a class="code" href="class_plane.html#l1">Plane3</a>(p0,p1,p2)); }

        inline void <a class="code" href="class_point.html#a6">Set</a>(float A,float B,float C,float D) { n.<a class="code" href="class_point.html#a6">Set</a>(A,B,C),d=D; }

        inline void <a class="code" href="class_plane.html#a10">SetZ</a>() { <a class="code" href="class_point.html#a6">Set</a>(0,0,1,0); }

        int <a class="code" href="class_plane.html#a11">Intersect</a>(const <a class="code" href="class_point.html">Point</a> &amp;rayP,const <a class="code" href="class_vector.html">Vector</a> &amp;rayD,float &amp;t)
        {
                float dot = <a class="code" href="class_point.html#l12">DotProd</a>(n,rayD);
                //if (fabs(dot) &lt; EPSILON) 
                if (<a class="code" href="gutils.h.html#a32">iszero</a>(dot)) 
                        return(0);
            // compute the t-parameter
                t = (d - <a class="code" href="class_point.html#l12">DotProd</a>(n,rayP)) / dot;
                return(1);
        }



        friend <a class="code" href="class_plane.html">Plane</a> operator* (const <a class="code" href="class_matrix.html">Matrix</a>&amp;, const <a class="code" href="class_plane.html">Plane</a>&amp;);
        // compute plane from 3 pts 
        friend <a class="code" href="class_plane.html">Plane</a> <a class="code" href="class_plane.html#l1">Plane3</a>(const <a class="code" href="class_point.html">Point</a> &amp;p0,const <a class="code" href="class_point.html">Point</a> &amp;p1,const <a class="code" href="class_point.html">Point</a> &amp;p2);

        int <a class="code" href="class_point.html#a38">io</a>(<a class="code" href="class_astream.html">AStream</a> &amp;<a class="code" href="class_a.html">a</a>);

};

#define BBOX_MAX FLT_MAX 
#define BBOX_MIN FLT_MIN

/*
! Bounding box
holds a axis aligned extent as two points
*/

class <a class="code" href="class_bbox.html">BBox</a> {
public:
        <a class="code" href="class_point.html">Point</a> mi,ma;

        <a class="code" href="class_bbox.html#a0">BBox</a>() : mi(BBOX_MAX),ma(BBOX_MIN) {};

        <a class="code" href="class_bbox.html#a0">BBox</a>(const <a class="code" href="class_point.html">Point</a> &amp;p) : mi(p),ma(p) {} ;

        <a class="code" href="class_bbox.html#a0">BBox</a>(const <a class="code" href="class_point.html">Point</a> &amp;pMin,const <a class="code" href="class_point.html">Point</a> &amp;pMax) : mi(pMin),ma(pMax) {} ;


        <a class="code" href="class_bbox.html#a0">BBox</a>(const <a class="code" href="class_bbox.html">BBox</a> &amp;b) { mi=b.mi,ma=b.ma; }

        inline void <a class="code" href="class_point.html#a6">Set</a>(const <a class="code" href="class_point.html">Point</a> &amp;p) { mi.<a class="code" href="class_point.html#a6">Set</a>(p); ma.<a class="code" href="class_point.html#a6">Set</a>(p); }

        inline void <a class="code" href="class_bbox.html#a5">SetSize</a>(const <a class="code" href="class_point.html">Point</a> &amp;p) { ma = mi + p; }

        inline void <a class="code" href="class_point.html#a6">Set</a>(const <a class="code" href="class_bbox.html">BBox</a> &amp;b) { mi=b.mi,ma=b.ma; }

        inline void <a class="code" href="class_bbox.html#a7">SetCenterSize</a>(const <a class="code" href="class_point.html">Point</a> &amp;center,const <a class="code" href="class_point.html">Point</a> &amp;size) { 
                <a class="code" href="class_point.html">Point</a> s2 = size * 0.5;
                mi = center - s2;
                ma = center + s2;
        }

        inline void <a class="code" href="class_bbox.html#a8">SetEmpty</a>() { mi.<a class="code" href="class_point.html#a6">Set</a>(BBOX_MAX); ma.<a class="code" href="class_point.html#a6">Set</a>(BBOX_MIN); }

        inline gbool <a class="code" href="class_bbox.html#a9">Empty</a>() const { return(ma.x &lt; mi.x); }
        inline gbool <a class="code" href="class_bbox.html#a10">IsEmpty</a>() const { return(ma.x &lt; mi.x); }

        inline <a class="code" href="class_point.html">Point</a> <a class="code" href="class_bbox.html#a11">Size</a>() const { return(ma-mi); }

        void <a class="code" href="class_bbox.html#a12">ScaleCenter</a>(const <a class="code" href="class_point.html">Point</a> &amp;scale) 
                        { <a class="code" href="class_point.html">Point</a> s(<a class="code" href="class_bbox.html#a11">Size</a>());
                          <a class="code" href="class_point.html">Point</a> center(mi+s * 0.5);
                          s *= scale*0.5;
                          mi.<a class="code" href="class_point.html#a6">Set</a>(center-s);
                          ma.<a class="code" href="class_point.html#a6">Set</a>(center+s);
                         }
         

        inline <a class="code" href="class_point.html">Point</a> <a class="code" href="class_bbox.html#a13">Center</a>() const { return(mi + (ma-mi)*0.5); }

    

        inline <a class="code" href="class_bbox.html">BBox</a>&amp; <a class="code" href="class_bbox.html#a14">Union</a>(const <a class="code" href="class_point.html">Point</a> &amp;p) { p.<a class="code" href="class_point.html#a31">MinMax</a>(mi,ma); return(*this); }

        inline 
        <a class="code" href="class_bbox.html">BBox</a>&amp; <a class="code" href="class_bbox.html#a14">Union</a>(const <a class="code" href="class_bbox.html">BBox</a> &amp;b) { b.mi.<a class="code" href="class_point.html#a31">MinMax</a>(mi,ma);
                                                                b.ma.<a class="code" href="class_point.html#a31">MinMax</a>(mi,ma);
                                                                return(*this);
                                                          }

    inline gbool <a class="code" href="class_bbox.html#a16">Inside</a>(const <a class="code" href="class_point.html">Point</a> &amp;p) const {
                                return( (p.x&gt;=mi.x) &amp;&amp; (p.x &lt;=ma.x)
                                                &amp;&amp; (p.y&gt;=mi.y) &amp;&amp; (p.y &lt;= ma.y)
                                                &amp;&amp; (p.z&gt;=mi.z) &amp;&amp; (p.z &lt;= ma.z));

        }

    inline gbool <a class="code" href="class_bbox.html#a16">Inside</a>(const <a class="code" href="class_bbox.html">BBox</a> &amp;b) const { return( <a class="code" href="class_bbox.html#a16">Inside</a>(b.mi) &amp;&amp; <a class="code" href="class_bbox.html#a16">Inside</a>(b.ma)); }

        inline gbool <a class="code" href="class_bbox.html#a18">Outside</a>(const <a class="code" href="class_point.html">Point</a> &amp;p) const {
                                return( (p.x &lt; mi.x) || (p.x  &gt; ma.x)
                                                || (p.y &lt; mi.y) || (p.y &gt; ma.y)
                                                || (p.z &lt; mi.z) || (p.z &gt; ma.z));

        }

    inline gbool  <a class="code" href="class_bbox.html#a18">Outside</a>(const <a class="code" href="class_bbox.html">BBox</a> &amp;b) const {
                                return( (b.ma.x &lt; mi.x) || (b.mi.x      &gt; ma.x)
                                                || (b.ma.y &lt; mi.y) || (b.mi.y &gt; ma.y)
                                                || (b.ma.z &lt; mi.z) || (b.mi.z &gt; ma.z));

        };

        friend <a class="code" href="class_bbox.html">BBox</a> operator* (const <a class="code" href="class_matrix.html">Matrix</a>&amp;, const <a class="code" href="class_bbox.html">BBox</a>&amp; b);

        <a class="code" href="class_bbox.html">BBox</a>&amp; operator *= (const <a class="code" href="class_matrix.html">Matrix</a> &amp;m);

        int <a class="code" href="class_bbox.html#a21">InsidePlane</a>(const <a class="code" href="class_plane.html">Plane</a> &amp;plane) const ;
                                                                                         

        int <a class="code" href="class_point.html#a38">io</a>(<a class="code" href="class_astream.html">AStream</a> &amp;<a class="code" href="class_a.html">a</a>);


};


class <a class="code" href="class_ray.html">Ray</a> {
public:
        <a class="code" href="class_point.html">Point</a> p;
        
        <a class="code" href="class_vector.html">Vector</a> d;
        
        int dominantAxis; 

        inline <a class="code" href="class_ray.html#a0">Ray</a>() { };

        // construct given point  &amp; direction
        inline <a class="code" href="class_ray.html#a0">Ray</a>(const <a class="code" href="class_point.html">Point</a> &amp;P,const <a class="code" href="class_vector.html">Vector</a> &amp;D) : p(P),d(D) { 
                dominantAxis = d.<a class="code" href="class_point.html#a32">Dominant</a>(); 
        };

        inline <a class="code" href="class_point.html">Point</a> <a class="code" href="class_ray.html#a2">Eval</a>(float t)  const { return(p + d*t); };

    void <a class="code" href="class_ray.html#a3">SetByPoints</a>(const <a class="code" href="class_point.html">Point</a> &amp;start,const <a class="code" href="class_point.html">Point</a> &amp;end) {
            p = start;
            d = end - start;
                        dominantAxis = d.<a class="code" href="class_point.html#a32">Dominant</a>(); 
    }

    void <a class="code" href="class_point.html#a6">Set</a>(const <a class="code" href="class_point.html">Point</a> &amp;start,const <a class="code" href="class_vector.html">Vector</a> &amp;dir) {
            p = start;
            d = dir;
                        dominantAxis = d.<a class="code" href="class_point.html#a32">Dominant</a>(); 
    }

        
/*
        float Map(const Point &amp;pt) const  {
                for (int i = 0; i &lt; 3; i++)
                   if (fabs(d[i]) &gt; EPS) return (pt[i] - p[i]) / d[i];
                return(0.0);
                   };
*/

        inline float <a class="code" href="class_ray.html#a5">Map</a>(const <a class="code" href="class_point.html">Point</a> &amp;pt) const  {
                 return (pt[dominantAxis] - p[dominantAxis]) / d[dominantAxis];
                };
        
        <a class="code" href="class_vector.html">Vector</a> <a class="code" href="class_ray.html#a6">Reflect</a>(const <a class="code" href="class_vector.html">Vector</a> &amp; Normal) const {
                return (Normal * ( 2.0 * <a class="code" href="class_point.html#l12">DotProd</a>(Normal,-d)) +d);
                }

        inline void <a class="code" href="class_point.html#a26">Normalize</a>() { 
                d.<a class="code" href="class_point.html#a26">Normalize</a>();          
                dominantAxis = d.<a class="code" href="class_point.html#a32">Dominant</a>(); 
        }

        <a class="code" href="class_ray.html">Ray</a>&amp; operator *= (const <a class="code" href="class_matrix.html">Matrix</a> &amp;m) { 
                        p*=m;
                        d=<a class="code" href="class_point.html#l17">RotateOnly</a>(m,d); 
                        dominantAxis = d.<a class="code" href="class_point.html#a32">Dominant</a>(); 
                        return(*this);
        };
};


// in addition to ray an range is stored, and direction is normalized
class <a class="code" href="class_rayrange.html">RayRange</a> : public <a class="code" href="class_ray.html">Ray</a> {

public:

    float tmin,tmax;        


    // constructors 

    inline <a class="code" href="class_rayrange.html#a0">RayRange</a>() : <a class="code" href="class_ray.html">Ray</a>(),tmin(0),tmax(1) {};

    inline <a class="code" href="class_rayrange.html#a0">RayRange</a>(const <a class="code" href="class_point.html">Point</a> &amp;P,const <a class="code" href="class_vector.html">Vector</a> &amp;D, float _tmin =0.0, float _tmax=1.0) : <a class="code" href="class_ray.html">Ray</a>(P,D),tmin(_tmin),tmax(_tmax) {};

    inline void <a class="code" href="class_ray.html#a3">SetByPoints</a>(const <a class="code" href="class_point.html">Point</a> &amp;start,const <a class="code" href="class_point.html">Point</a> &amp;end) {
            p = start;
            d = end - start;
            tmin = 0.0;
            tmax =  d.<a class="code" href="class_point.html#a14">Length</a>();
            d.<a class="code" href="class_point.html#a26">Normalize</a>();
                        dominantAxis = d.<a class="code" href="class_point.html#a32">Dominant</a>(); 
    }

    inline void <a class="code" href="class_point.html#a6">Set</a>(const <a class="code" href="class_point.html">Point</a> &amp;start,const <a class="code" href="class_vector.html">Vector</a> &amp;dir) {
            p = start;
            d = dir;
            tmin = 0.0;
            tmax =  d.<a class="code" href="class_point.html#a14">Length</a>();
            d.<a class="code" href="class_point.html#a26">Normalize</a>();
                        dominantAxis = d.<a class="code" href="class_point.html#a32">Dominant</a>(); 
    }

    inline gbool <a class="code" href="class_rayrange.html#a4">InRange</a>(float t) { return(t&gt;=tmin &amp;&amp; t &lt;=tmax); }

        void <a class="code" href="class_point.html#a26">Normalize</a>() { 
        float magnitude = d.<a class="code" href="class_point.html#a14">Length</a>();
        
        if (magnitude &gt; 0.0) {
            float f = (1.0/ magnitude); // scale direction to unit
            d *= f;
            tmin *= magnitude;  // adapt range
            tmax *= magnitude;
        }
                dominantAxis = d.<a class="code" href="class_point.html#a32">Dominant</a>(); 
    }

    // is this ok ???? 
        <a class="code" href="class_rayrange.html">RayRange</a>&amp; operator *= (const <a class="code" href="class_matrix.html">Matrix</a> &amp;m) { 
            p*=m;
                        d=<a class="code" href="class_point.html#l17">RotateOnly</a>(m,d); 
            <a class="code" href="class_point.html#a26">Normalize</a>();
            return(*this);
    };

};


#endif


</div></pre><hr><address><small>Generated at Thu Jan 27 18:51:22 2000 for blaxxunContact3D by
<a href="http://www.stack.nl/~dimitri/doxygen/index.html">
<img src="doxygen.gif" alt="doxygen" align=center border=0 
width=118 height=53></a> 1.0.0 written by <a href="mailto:dimitri@stack.nl">Dimitri van Heesch</a>,
 &copy; 1997-1999</small></address>
</body>
</html>

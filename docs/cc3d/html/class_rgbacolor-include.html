<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta name="robots" content="noindex">
<title>RGBAColor Include File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body bgcolor="#ffffff">
<!-- Generated by Doxygen 1.0.0 on Thu Jan 27 18:51:21 2000 -->
<center>
<a class="qindex"href="index.html">Main Page</a> &nbsp; <a class="qindex"href="namespaces.html">Namespace List</a> &nbsp; <a class="qindex"href="hierarchy.html">Class Hierarchy</a> &nbsp; <a class="qindex"href="annotated.html">Compound List</a> &nbsp; <a class="qindex"href="files.html">File List</a> &nbsp; <a class="qindex"href="headers.html">Header Files</a> &nbsp; <a class="qindex"href="namespacemembers.html">Namespace Members</a> &nbsp; <a class="qindex"href="functions.html">Compound Members</a> &nbsp; <a class="qindex"href="globals.html">File Members</a> &nbsp; </center>
<hr><h1>grenderbase.h</h1>This is the verbatim text of the grenderbase.h include file.<div class="fragment"><pre>/*=============================================================================

This code is licensed under the Web3D-blaxxun Community Source License,
provided in distribution file LICENSE.TXT and available online at
http://www.web3D.org/TaskGroups/x3d/blaxxun/Web3D-blaxxunCommunitySourceAgreement.html
and may only be used for non-commercial use as specified in that license.

THE WEB3D CONSORTIUM AND BLAXXUN DO NOT MAKE AND HEREBY DISCLAIM ANY EXPRESS
OR IMPLIED WARRANTIES RELATING TO THIS CODE, INCLUDING BUT NOT LIMITED TO,
WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY OR FITNESS FOR A PARTICULAR
PURPOSE, OR ANY WARRANTIES THAT MIGHT ARISE FROM A COURSE OF DEALING, USAGE
OR TRADE PRACTICE.  THE COMMUNITY SOURCE CODE IS PROVIDED UNDER THIS
AGREEMENT "AS IS," WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
INCLUDING, WITHOUT LIMITATION, WARRANTIES THAT THE COMMUNITY SOURCE CODE ARE
FREE OF DEFECTS, MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE OR
NON-INFRINGING OR IN ANY WAY CONSTITUTE THE COMPLETE PRODUCT MARKETED UNDER
THE NAMES GIVEN SAID CODE.

==============================================================================*/

#ifndef _GRenderBase_
#define _GRenderBase_

/******************************************************************************
@doc

@module GRenderBase.h - GLView RenderState base classes  |

Copyright (c) 1996-1999 by Holger Grahn
All rights reserved

Purpose:

Classes:

Notes:

Changes:

$Revision: 1.2 $
$Log: grenderbase.h,v $
Revision 1.2  1999/07/06 16:54:45  tom
*** empty log message ***


Todo :

******************************************************************************/


// forwards 
class GRenderStateBase;
class <a class="code" href="class_gtexturehandle.html">GTextureHandle</a>;
class <a class="code" href="class_grenderer2d.html">GRenderer2D</a>;

typedef struct <a class="code" href="class_image_.html">image_</a> <a class="code" href="class_image_.html">image</a>;



//@class a simple transform stored component wise
class <a class="code" href="class_transform3.html">Transform3</a> {
public :

        <a class="code" href="class_point.html">Point</a> scale;
        <a class="code" href="class_point.html">Point</a> rotate;
        <a class="code" href="class_point.html">Point</a> translate;

        <a class="code" href="class_transform3.html#a0">Transform3</a>() : scale(1.0),rotate(0.0), translate(0.0) {};

        <a class="code" href="class_transform3.html#a0">Transform3</a>(<a class="code" href="class_point.html">Point</a> Scale,<a class="code" href="class_point.html">Point</a> Rotate, <a class="code" href="class_point.html">Point</a> Translate) :
                scale(Scale),rotate(Rotate),translate(Translate) {} ;
        
        void <a class="code" href="class_transform3.html#a2">Identity</a>() { scale.<a class="code" href="class_point.html#a6">Set</a>(1.0,1.0,1.0);
                                          rotate.<a class="code" href="class_point.html#a6">Set</a>(0.0,0.0,0.0);
                                          translate.<a class="code" href="class_point.html#a6">Set</a>(0.0,0.0,0.0);
                                         };

        gbool <a class="code" href="class_transform3.html#a3">IsIdentity</a>() const { return scale == Point(1.0,1.0,1.0) &amp;&amp; 
                                                           rotate == Point(0.0,0.0,0.0) &amp;&amp;
                                                           translate == Point(0.0,0.0,0.0);
                                          }
        
        <a class="code" href="class_matrix.html">Matrix</a> <a class="code" href="class_transform3.html#a4">Eval</a>() const
        {  <a class="code" href="class_matrix.html">Matrix</a> m;
                m=ScaleMatrix(scale);
                m*=RotationMatrix(rotate);
                m*=TranslationMatrix(translate);
                return(m);
        }


};



//@class Red Green Blue Alpha color in float
class <a class="code" href="class_rgbacolor.html">RGBAColor</a> 

#ifdef _D3D
: public D3DCOLORVALUE 
#endif

{
public:


#ifndef _D3D
        float r,g,b,a;
#endif


  

        RGBAColor(float R=0.0,float G=0.0, float B=0.0,float A=1.0) { r=R,g=G,b=B,<a class="code" href="class_a.html">a</a>=A; };
        RGBAColor(const <a class="code" href="class_point.html">Point</a> &amp;p,float A=1.0) { r=p.x,g=p.y,b=p.z,<a class="code" href="class_a.html">a</a>=A; };

#ifdef _D3D
        RGBAColor(const D3DCOLORVALUE &amp;c) { * ((D3DCOLORVALUE*) this) = c; };
#endif

        <a class="code" href="class_rgbacolor.html">RGBAColor</a>&amp; Set(float R,float G, float B,float A=1.0) { r=R,g=G,b=B,<a class="code" href="class_a.html">a</a>=A; return(*this); };

        <a class="code" href="class_rgbacolor.html">RGBAColor</a>&amp; Set(const <a class="code" href="class_point.html">Point</a> &amp;p,float A=1.0) { r=p.x,g=p.y,b=p.z,<a class="code" href="class_a.html">a</a>=A; return(*this); };
        <a class="code" href="class_rgbacolor.html">RGBAColor</a>&amp; Get(<a class="code" href="class_point.html">Point</a> &amp;p) { p.<a class="code" href="class_point.html#a6">Set</a>(r,g,b); return(*this); };
        <a class="code" href="class_rgbacolor.html">RGBAColor</a>&amp; SetAlpha(float A=1.0) { <a class="code" href="class_a.html">a</a>=A; return(*this); };

        <a class="code" href="class_rgbacolor.html">RGBAColor</a>&amp; White() { r=g=b=1.0; <a class="code" href="class_a.html">a</a>=1.0; return (*this); };
        <a class="code" href="class_rgbacolor.html">RGBAColor</a>&amp; Black() { r=g=b=0.0; <a class="code" href="class_a.html">a</a>=1.0; return (*this); };
        <a class="code" href="class_rgbacolor.html">RGBAColor</a>&amp; Gray(float gray) { r=g=b=gray; <a class="code" href="class_a.html">a</a>=1.0; return (*this);};

#ifdef _D3D
        // convert to packed color format
        //operator D3DCOLOR() const { return(D3DRGBA_X(r, g, b,a )); } 
#endif


        operator float* () {return &amp;r;};                // type convert to float * (float[4]) 
        
        // input/ouput
        int io(<a class="code" href="class_astream.html">AStream</a> &amp;<a class="code" href="class_a.html">a</a>,int fmt=0);

        // Unary operators returning a new RGBAColor
        <a class="code" href="class_rgbacolor.html">RGBAColor</a> operator- () const;
        <a class="code" href="class_rgbacolor.html">RGBAColor</a> operator+ () const;


        // Assignment operators
        <a class="code" href="class_rgbacolor.html">RGBAColor</a>&amp; operator+= (const <a class="code" href="class_rgbacolor.html">RGBAColor</a>&amp; A);
        <a class="code" href="class_rgbacolor.html">RGBAColor</a>&amp; operator-= (const <a class="code" href="class_rgbacolor.html">RGBAColor</a>&amp; A);
        <a class="code" href="class_rgbacolor.html">RGBAColor</a>&amp; operator*= (const <a class="code" href="class_rgbacolor.html">RGBAColor</a>&amp; A);
        <a class="code" href="class_rgbacolor.html">RGBAColor</a>&amp; operator/= (const <a class="code" href="class_rgbacolor.html">RGBAColor</a>&amp; A);
        <a class="code" href="class_rgbacolor.html">RGBAColor</a>&amp; operator+= (float A);
        <a class="code" href="class_rgbacolor.html">RGBAColor</a>&amp; operator-= (float A);
        <a class="code" href="class_rgbacolor.html">RGBAColor</a>&amp; operator*= (float A);
        <a class="code" href="class_rgbacolor.html">RGBAColor</a>&amp; operator/= (float A);

        // Binary operators returning a new RGBAColor
        friend <a class="code" href="class_rgbacolor.html">RGBAColor</a> operator+ (const <a class="code" href="class_rgbacolor.html">RGBAColor</a>&amp; A, const <a class="code" href="class_rgbacolor.html">RGBAColor</a>&amp; B);
        friend <a class="code" href="class_rgbacolor.html">RGBAColor</a> operator- (const <a class="code" href="class_rgbacolor.html">RGBAColor</a>&amp; A, const <a class="code" href="class_rgbacolor.html">RGBAColor</a>&amp; B);
        friend <a class="code" href="class_rgbacolor.html">RGBAColor</a> operator* (const <a class="code" href="class_rgbacolor.html">RGBAColor</a>&amp; A, const <a class="code" href="class_rgbacolor.html">RGBAColor</a>&amp; B);
        friend <a class="code" href="class_rgbacolor.html">RGBAColor</a> operator* (const <a class="code" href="class_rgbacolor.html">RGBAColor</a>&amp; A, float B);
        friend <a class="code" href="class_rgbacolor.html">RGBAColor</a> operator* (float A, const <a class="code" href="class_rgbacolor.html">RGBAColor</a>&amp; B);
        friend <a class="code" href="class_rgbacolor.html">RGBAColor</a> operator* (const <a class="code" href="class_matrix.html">Matrix</a>&amp;, const <a class="code" href="class_rgbacolor.html">RGBAColor</a>&amp;);
        friend <a class="code" href="class_rgbacolor.html">RGBAColor</a> operator/ (const <a class="code" href="class_rgbacolor.html">RGBAColor</a>&amp; A, const <a class="code" href="class_rgbacolor.html">RGBAColor</a>&amp; B);
        friend <a class="code" href="class_rgbacolor.html">RGBAColor</a> operator/ (const <a class="code" href="class_rgbacolor.html">RGBAColor</a>&amp; A, float B);

        friend int operator&lt; (const <a class="code" href="class_rgbacolor.html">RGBAColor</a>&amp; A, const <a class="code" href="class_rgbacolor.html">RGBAColor</a>&amp; B);



};

// io to AStream 
//int io(D3DCOLORVALUE &amp;this_,AStream &amp;a,int fmt=0);

// set color to a gray value
//void SetGray(D3DCOLORVALUE &amp;v, float gray,float alpha=1.0);

inline <a class="code" href="class_rgbacolor.html">RGBAColor</a> RGBAColor::operator+ () const
{
        return *this;
}

inline <a class="code" href="class_rgbacolor.html">RGBAColor</a> RGBAColor::operator- () const
{
        return RGBAColor(-r, -g, -b, -<a class="code" href="class_a.html">a</a>);
}

inline <a class="code" href="class_rgbacolor.html">RGBAColor</a>&amp; RGBAColor::operator+= (const <a class="code" href="class_rgbacolor.html">RGBAColor</a>&amp; A)
{
        r += A.r;  g += A.g; b += A.b; <a class="code" href="class_a.html">a</a> += A.a;
        return *this;
}

inline <a class="code" href="class_rgbacolor.html">RGBAColor</a>&amp; RGBAColor::operator-= (const <a class="code" href="class_rgbacolor.html">RGBAColor</a>&amp; A)
{
        r -= A.r;  g -= A.g; b -= A.b; <a class="code" href="class_a.html">a</a> -= A.a;
        return *this;
}

inline <a class="code" href="class_rgbacolor.html">RGBAColor</a>&amp; RGBAColor::operator+= (float A)
{
        r += A;  g += A;  b += A;  <a class="code" href="class_a.html">a</a> += A;
        return *this;
}

inline <a class="code" href="class_rgbacolor.html">RGBAColor</a>&amp; RGBAColor::operator-= (float A)
{
        r -= A;  g -= A;  b -= A;  <a class="code" href="class_a.html">a</a> -= A;
        return *this;
}

inline <a class="code" href="class_rgbacolor.html">RGBAColor</a>&amp; RGBAColor::operator*= (float A)
{
        r *= A;  g *= A;  b *= A; <a class="code" href="class_a.html">a</a> *= A;
        return *this;
}

inline <a class="code" href="class_rgbacolor.html">RGBAColor</a>&amp; RGBAColor::operator/= (float A)
{
        r /= A;  g /= A;  b /= A; <a class="code" href="class_a.html">a</a> /= A;
        return *this;
}

inline <a class="code" href="class_rgbacolor.html">RGBAColor</a>&amp; RGBAColor::operator*= (const <a class="code" href="class_rgbacolor.html">RGBAColor</a>&amp; A)
{
        r *= A.r;  g *= A.g;  b *= A.b; <a class="code" href="class_a.html">a</a> *= A.a;
        return *this;
}

inline <a class="code" href="class_rgbacolor.html">RGBAColor</a>&amp; RGBAColor::operator/= (const <a class="code" href="class_rgbacolor.html">RGBAColor</a>&amp; A)
{
        r /= A.r;  g /= A.g;  b /= A.b;  <a class="code" href="class_a.html">a</a> /= A.a;
        return *this;
}

inline <a class="code" href="class_rgbacolor.html">RGBAColor</a> operator+ (const <a class="code" href="class_rgbacolor.html">RGBAColor</a>&amp; A, const <a class="code" href="class_rgbacolor.html">RGBAColor</a>&amp; B)
{
        return RGBAColor(A.r + B.r, A.g + B.g, A.b + B.b, A.<a class="code" href="class_a.html">a</a> + B.<a class="code" href="class_a.html">a</a>);
}

inline <a class="code" href="class_rgbacolor.html">RGBAColor</a> operator- (const <a class="code" href="class_rgbacolor.html">RGBAColor</a>&amp; A, const <a class="code" href="class_rgbacolor.html">RGBAColor</a>&amp; B)
{
        return RGBAColor(A.r - B.r, A.g - B.g, A.b - B.b , A.<a class="code" href="class_a.html">a</a> - B.<a class="code" href="class_a.html">a</a>);
}

inline <a class="code" href="class_rgbacolor.html">RGBAColor</a> operator* (const <a class="code" href="class_rgbacolor.html">RGBAColor</a>&amp; A, const <a class="code" href="class_rgbacolor.html">RGBAColor</a>&amp; B)
{
        return RGBAColor(A.r * B.r, A.g * B.g, A.b * B.b, A.<a class="code" href="class_a.html">a</a> * B.<a class="code" href="class_a.html">a</a>);
}

inline <a class="code" href="class_rgbacolor.html">RGBAColor</a> operator* (const <a class="code" href="class_rgbacolor.html">RGBAColor</a>&amp; A, float B)
{
        return RGBAColor(A.r * B, A.g * B, A.b * B, A.<a class="code" href="class_a.html">a</a> * B);
}

inline <a class="code" href="class_rgbacolor.html">RGBAColor</a> operator* (float A, const <a class="code" href="class_rgbacolor.html">RGBAColor</a>&amp; B)
{
        return B * A;
}

inline <a class="code" href="class_rgbacolor.html">RGBAColor</a> operator/ (const <a class="code" href="class_rgbacolor.html">RGBAColor</a>&amp; A, const <a class="code" href="class_rgbacolor.html">RGBAColor</a>&amp; B)
{
        return RGBAColor(A.r / B.r, A.g / B.g, A.b / B.b, A.<a class="code" href="class_a.html">a</a> / B.<a class="code" href="class_a.html">a</a>);
}

inline <a class="code" href="class_rgbacolor.html">RGBAColor</a> operator/ (const <a class="code" href="class_rgbacolor.html">RGBAColor</a>&amp; A, float B)
{
        return RGBAColor(A.r / B, A.g / B, A.b / B, A.<a class="code" href="class_a.html">a</a> / B);
}

inline int operator&lt; (const <a class="code" href="class_rgbacolor.html">RGBAColor</a>&amp; A, const <a class="code" href="class_rgbacolor.html">RGBAColor</a>&amp; B)
{
        return A.r &lt; B.r &amp;&amp; A.g &lt; B.g &amp;&amp; A.b &lt; B.b &amp;&amp; A.a &lt; B.a;
}

inline int operator== (const <a class="code" href="class_rgbacolor.html">RGBAColor</a>&amp; A, const <a class="code" href="class_rgbacolor.html">RGBAColor</a>&amp; B)
{
        return (A.r == B.r) &amp;&amp; (A.g == B.g) &amp;&amp; (A.b == B.b) &amp;&amp; (A.a == B.a);
}

inline int operator!= (const <a class="code" href="class_rgbacolor.html">RGBAColor</a>&amp; A, const <a class="code" href="class_rgbacolor.html">RGBAColor</a>&amp; B)
{
        return !(A == B);
}


#ifdef _D3D

// standard versions
// slow
/*
#define D3DRGB(r, g, b) \
    (0xff000000L | ( ((long)((r) * 255)) &lt;&lt; 16) | (((long)((g) * 255)) &lt;&lt; 8) | (long)((b) * 255))

#define D3DRGBA(r, g, b, a) \
    (   (((long)((a) * 255)) &lt;&lt; 24) | (((long)((r) * 255)) &lt;&lt; 16) \
    |   (((long)((g) * 255)) &lt;&lt; 8) | (long)((b) * 255) \
    )
*/



inline long D3DRGBA_X(float r,float g,float b, float <a class="code" href="class_a.html">a</a>)
{
  return <a class="code" href="gutils.h.html#a23">float2int</a>(<a class="code" href="class_a.html">a</a>*255.0f)&lt;&lt;24 | <a class="code" href="gutils.h.html#a23">float2int</a>(r*255.0f)&lt;&lt;16 | <a class="code" href="gutils.h.html#a23">float2int</a>(g*255.0f)&lt;&lt; 8 | <a class="code" href="gutils.h.html#a23">float2int</a>(b*255.0f);
}

inline long D3DRGBA_X(const <a class="code" href="class_rgbacolor.html">RGBAColor</a> &amp;color)
{
        return D3DRGBA_X(color.r,color.g,color.b,color.<a class="code" href="class_a.html">a</a>);
}

//inline long operator D3DCOLOR(RGBAColor &amp;color) { return D3DRGBA_X(color); } 
inline long D3DRGBA_CLAMPED(float r,float g,float b, float <a class="code" href="class_a.html">a</a>)
{
  return <a class="code" href="gutils.h.html#a29">limit</a>(<a class="code" href="gutils.h.html#a23">float2int</a>(<a class="code" href="class_a.html">a</a>*255.0f),0,255)&lt;&lt;24 | <a class="code" href="gutils.h.html#a29">limit</a>(<a class="code" href="gutils.h.html#a23">float2int</a>(r*255.0f),0,255)&lt;&lt;16 | <a class="code" href="gutils.h.html#a29">limit</a>(<a class="code" href="gutils.h.html#a23">float2int</a>(g*255.0f),0,255)&lt;&lt; 8 | <a class="code" href="gutils.h.html#a29">limit</a>(<a class="code" href="gutils.h.html#a23">float2int</a>(b*255.0f),0,255);
}


#endif



//
// GTextureHandle
// @class maintains a handle to a texture
//
class <a class="code" href="class_gtexturehandle.html">GTextureHandle</a> {
public: 

    int refCnt;                 
    
        <a class="code" href="class_gtexturehandle.html">GTextureHandle</a> *next;    
    <a class="code" href="class_gtexturehandle.html">GTextureHandle</a> *prev;

        <a class="code" href="class_gtexturehandle.html#a0">GTextureHandle</a>() {  
                        fileFormat = 0; 
                        hasAlpha = 0; 
                        hasColorKey = 0; 
                        isGrayscale = 0; 
                        rendered = 0;
                        refCnt = 0; next = prev = NULL; 
                        cannotLoad = 0;  
                        inVideoMem = 1; 
                        rendered = 0;
                        lastRenderedFrame = 0;
                        textureFormat = -1;
                        components=sizeX=sizeY=bytesPerPix = 0;
        }

        virtual <a class="code" href="class_gtexturehandle.html#a1">~GTextureHandle</a>() { <a class="code" href="class_gtexturehandle.html#a3">Release</a>(); }

        <a class="code" href="class_gtexturehandle.html">GTextureHandle</a> * <a class="code" href="class_gtexturehandle.html#a2">Next</a>() { return  next; }

    
    virtual void <a class="code" href="class_gtexturehandle.html#a3">Release</a>() { 
                inVideoMem = TRUE;
        }

        gbool <a class="code" href="class_gtexturehandle.html#a4">CheckSurfaceLost</a>() 
        {
        return(FALSE);
        }

        inline gbool <a class="code" href="class_gtexturehandle.html#a5">CheckInVideoMem</a>()  { return inVideoMem; }

  
        CString                             fileName;                   // file name
        CString                             fileUrl;                    // file name url, in order to early lookup textures

        int                                             fileFormat;                     /* type of file */      
        
        BEGIN_PACKED_STRUCT
        
        BOOL                                    cannotLoad:1;           /* no success loading the file  */
        BOOL                                    hasAlpha:1;                     /* has color key or alpha channel */
        BOOL                                    hasColorKey:1;          /* has color key or alpha channel */
        BOOL                                    isGrayscale:1;          /* is grayscale image */
        BOOL                                    inVideoMem:1;       /* texture is in video memory, false it  doesn't fit  */
        BOOL                                    rendered:1;                     /* texture was rendered */ 
        unsigned char                   components;                     // number of components 
        unsigned char                   bytesPerPix;
        short                                   sizeX,sizeY;            // current size 
        short                                   textureFormat;          // index into texture format // D3D
        
        END_PACKED_STRUCT


        DWORD                                   lastRenderedFrame;      // frame counter of frame this texture has been used

        // texture can't be loaded due to some problem ?
        inline gbool <a class="code" href="class_gtexturehandle.html#a6">CantLoad</a>() { return (cannotLoad); }        

        // alpha component ?
        inline gbool <a class="code" href="class_gtexturehandle.html#a7">HasAlpha</a>() { return (hasAlpha); }  

        // color key ?
        inline gbool <a class="code" href="class_gtexturehandle.html#a8">HasColorKey</a>() { return (hasColorKey); }    
    
        // is texture a grayscale image ?
        inline gbool <a class="code" href="class_gtexturehandle.html#a9">IsGrayscale</a>() { return (isGrayscale); }

        inline gbool <a class="code" href="class_gtexturehandle.html#a10">Rendered</a>() { return (rendered); }

        gbool <a class="code" href="class_gtexturehandle.html#a11">MatchFileName</a>(LPCTSTR name) const { return fileName.Compare(name) == 0; }
        gbool <a class="code" href="class_gtexturehandle.html#a12">MatchFileUrl</a>(LPCTSTR name) const { return fileUrl.Compare(name) == 0; }


    virtual gbool <a class="code" href="class_gtexturehandle.html#a13">Ok</a>() = 0;

    void <a class="code" href="class_gtexturehandle.html#a14">Ref</a>() { refCnt++; }

    void <a class="code" href="class_gtexturehandle.html#a15">UnRef</a>() { refCnt--;  if (refCnt == 0) <a class="code" href="class_gtexturehandle.html#a3">Release</a>(); }

        gbool <a class="code" href="class_gtexturehandle.html#a16">Set</a>(GRenderStateBase &amp;state, LPCTSTR fileName,int format=0, LPCTSTR fileUrl=NULL);

        // !set texture from image data
        gbool <a class="code" href="class_gtexturehandle.html#a16">Set</a>(GRenderStateBase &amp;state, int format,int width,int height,int numComponents,unsigned char *data, char *colorTable=NULL);

        // set texture surface from image data
        // gbool SetTexture(RenderState &amp;state,
        //              int format,int width,int height,
        //              unsigned char *data, char *colorTable=NULL);

        // set by image 
        gbool <a class="code" href="class_gtexturehandle.html#a16">Set</a>(GRenderStateBase &amp;state,<a class="code" href="class_image_.html">image</a> *im,gbool checkScale=TRUE,gbool checkFormat=TRUE,gbool filteredScale=TRUE);

#ifdef _D3D
        // set by DDraw Surface
        gbool <a class="code" href="class_gtexturehandle.html#a16">Set</a>(GRenderStateBase &amp;state,LPDIRECTDRAWSURFACE srcSurface,IDirectDrawPalette *srcPalette,DDSURFACEDESC &amp;srcDdsd, RECT &amp;srcRect,gbool checkScale=TRUE,gbool checkFormat=TRUE,gbool filteredScale=TRUE);
#endif


        // helper for optimizer 
        // return image 
        // gbool GetImage(image &amp;im);

};

//
// GTextureRef
//
// holds a pointer to a GTextureHandleBase

class <a class="code" href="class_gtextureref.html">GTextureRef</a>
{

/* protected: */
public : 

        // ! pointer to a GTextureHandleBase or derived structure, reference counted !
    <a class="code" href="class_gtexturehandle.html">GTextureHandle</a> *handle;

public:

    <a class="code" href="class_gtextureref.html#a0">GTextureRef</a>() : handle(NULL) { };

    gbool <a class="code" href="class_gtextureref.html#a1">Ok</a>() { return (handle &amp;&amp; handle-&gt;<a class="code" href="class_gtexturehandle.html#a13">Ok</a>()); }

    gbool <a class="code" href="class_gtextureref.html#a2">CantLoad</a>() { return (handle &amp;&amp; handle-&gt;<a class="code" href="class_gtexturehandle.html#a6">CantLoad</a>()); }

        gbool <a class="code" href="class_gtextureref.html#a3">HasAlpha</a>() { return (handle &amp;&amp; handle-&gt;<a class="code" href="class_gtexturehandle.html#a7">HasAlpha</a>()); }

        gbool <a class="code" href="class_gtextureref.html#a4">HasColorKey</a>() { return (handle &amp;&amp; handle-&gt;<a class="code" href="class_gtexturehandle.html#a8">HasColorKey</a>()); }

        gbool <a class="code" href="class_gtextureref.html#a5">IsGrayscale</a>() { return (handle &amp;&amp; handle-&gt;<a class="code" href="class_gtexturehandle.html#a9">IsGrayscale</a>()); }

    void <a class="code" href="class_gtextureref.html#a6">Release</a>() {
        if (handle) handle-&gt;<a class="code" href="class_gtexturehandle.html#a15">UnRef</a>();
        handle = NULL;
    }

    <a class="code" href="class_gtextureref.html#a7">~GTextureRef</a>() {
        if (handle) handle-&gt;<a class="code" href="class_gtexturehandle.html#a15">UnRef</a>();
        handle = NULL;
    }

    friend class <a class="code" href="class_grenderstate.html">GRenderState</a>;
};


typedef enum {
        GR_UNKNKOWN_DEVICE,
        GR_NULL_DEVICE,
        GR_OGL_DEVICE,
        GR_D3D_RAMP_DEVICE,
        GR_D3D_DEVICE,
        GR_D3D7_DEVICE

} G_RENDER_DEVICE;



class <a class="code" href="class_grenderdevice.html">GRenderDevice</a> 
{
public :

        int type;

        gbool <a class="code" href="class_grenderdevice.html#a0">Init</a>() {return gfalse; }
        void <a class="code" href="class_grenderdevice.html#a1">Term</a>() {}

};



class <a class="code" href="class_grenderstate.html">GRenderState</a>
{
public:

        <a class="code" href="class_grenderstate.html#a0">GRenderState</a>() {

                textureMatrixIdentity=gtrue;              
                textureMatrixVersion=0;
                textureMatrixVersionMax=0;
                
                doTextureDownscale = gtrue;

        }       


        //  ********** Texture  support **********


        virtual gbool <a class="code" href="class_grenderstate.html#a1">SetTexture</a>(<a class="code" href="class_gtextureref.html">GTextureRef</a> &amp;ref,
                                                                LPCTSTR fileName,
                                                                LPCTSTR fileUrl,
                                                                int format = 0,gbool reload=gfalse)=0; 
        
        virtual gbool <a class="code" href="class_grenderstate.html#a2">FindTextureByUrl</a>(<a class="code" href="class_gtextureref.html">GTextureRef</a> &amp;ref,LPCTSTR fileUrl)=0; 

        virtual gbool <a class="code" href="class_grenderstate.html#a1">SetTexture</a>(<a class="code" href="class_gtextureref.html">GTextureRef</a> &amp;ref,int glFormat,int width,int height,int numComponents,unsigned char *data)=0;

        virtual gbool <a class="code" href="class_grenderstate.html#a1">SetTexture</a>(<a class="code" href="class_gtextureref.html">GTextureRef</a> &amp;ref,<a class="code" href="class_image_.html">image</a> *im,gbool checkScale=TRUE)=0;


    virtual gbool <a class="code" href="class_grenderstate.html#a1">SetTexture</a>(<a class="code" href="class_gtextureref.html">GTextureRef</a> &amp;ref) = 0;

        
        // ********** texture matrix support **********
        /*
                Direct 3D has no texture matrix,
                so texture coordinates need to contain effects of the matrix
                for speed reasons lowe level must detect texture matrix changes via the textureMatrixVersion
        */
        
        gbool textureMatrixIdentity;              
    
        unsigned long  textureMatrixVersion; 
        
        unsigned long  textureMatrixVersionMax;


        virtual void <a class="code" href="class_grenderstate.html#a6">SetTextureMatrix</a>(const <a class="code" href="class_matrix.html">Matrix</a> &amp;m) = 0;

        // set texture matrix, together with version ID, ID = 0, matrix is identity
        virtual void <a class="code" href="class_grenderstate.html#a6">SetTextureMatrix</a>(const <a class="code" href="class_matrix.html">Matrix</a> &amp;m, unsigned long version) = 0;

        virtual void <a class="code" href="class_grenderstate.html#a8">SetTextureMatrixIdentity</a>() = 0;

        unsigned long <a class="code" href="class_grenderstate.html#a9">GetTextureMatrixVersion</a>() { if (textureMatrixIdentity) return(0); else return textureMatrixVersion; }

        unsigned long <a class="code" href="class_grenderstate.html#a10">GetNewTextureMatrixVersion</a>() {  
                 textureMatrixVersionMax++; 
                 if (textureMatrixVersionMax == 0) textureMatrixVersionMax=1;  
                 return textureMatrixVersionMax; 
        }

        gbool <a class="code" href="class_grenderstate.html#a11">TextureMatrixVersionOk</a>(unsigned long version) { return(version == <a class="code" href="class_grenderstate.html#a9">GetTextureMatrixVersion</a>()); }


        // ********** texture matrix support **********

        gbool doTextureDownscale;

    //virtual GTextureHandle* CreateTexture() = 0;

    //virtual void DeleteTexture(GTextureHandle *m)= 0;


        virtual void <a class="code" href="class_grenderstate.html#a12">GetTextureTargetSize</a>(int &amp;width,int &amp;height,int roundUpLimit=128) = 0;
    

    virtual void <a class="code" href="class_grenderstate.html#a13">ReleaseTextures</a>() = 0;

    virtual gbool <a class="code" href="class_grenderstate.html#a14">ReleaseUnrenderedTextures</a>(int max=1) = 0;

    virtual gbool <a class="code" href="class_grenderstate.html#a15">ReleaseLargeTextures</a>(int max=1) = 0;

        virtual gbool <a class="code" href="class_grenderstate.html#a16">GetMaxUsedTextureSize</a>(int &amp;sizeX,int &amp;sizeY, int &amp;bytesPerPix) = 0;

    virtual void <a class="code" href="class_grenderstate.html#a17">DeleteTextures</a>() = 0;

    virtual gbool <a class="code" href="class_grenderstate.html#a18">DeleteUnusedTextures</a>() = 0;

        virtual gbool <a class="code" href="class_grenderstate.html#a19">OnTextureMemoryOverflow</a>(<a class="code" href="class_gtexturehandle.html">GTextureHandle</a> &amp;overflowHandle) = 0;


        virtual <a class="code" href="class_grenderer2d.html">GRenderer2D</a>* <a class="code" href="class_grenderstate.html#a20">getRenderer2D</a>() = 0;


};

enum GRender2DMode 
{
        G_EDGE = 1,
        G_FILL = 2,
};



// abstract interface

class <a class="code" href="class_grenderer2d.html">GRenderer2D</a>
{
public :

        virtual void <a class="code" href="class_grenderer2d.html#a0">DrawPolyline</a>(int np, const <a class="code" href="class_point.html">Point</a> *pts) = 0;

        virtual void <a class="code" href="class_grenderer2d.html#a1">DrawPolygon</a>(int np, const <a class="code" href="class_point.html">Point</a> *pts) = 0;

        virtual void <a class="code" href="class_grenderer2d.html#a2">DrawPoint</a>(int np, const <a class="code" href="class_point.html">Point</a> *pts) = 0;

        virtual void <a class="code" href="class_grenderer2d.html#a3">DrawGrid</a>(const <a class="code" href="class_point.html">Point</a> &amp;pmin,const <a class="code" href="class_point.html">Point</a> &amp;pmax,int xsteps,int ysteps,gbool lines=gtrue) = 0;


        virtual void <a class="code" href="class_grenderer2d.html#a4">BeginContour</a>()= 0;
        virtual void <a class="code" href="class_grenderer2d.html#a5">EndContour</a>()= 0;

        virtual void <a class="code" href="class_grenderer2d.html#a6">BeginPolygon</a>()= 0;

        virtual void <a class="code" href="class_grenderer2d.html#a7">EndPolygon</a>()= 0;

        // attributes
        

        virtual void <a class="code" href="class_grenderer2d.html#a8">SetEdgeColor</a>(const <a class="code" href="class_rgbacolor.html">RGBAColor</a> &amp;color) = 0;
        virtual void <a class="code" href="class_grenderer2d.html#a9">SetColor</a>(const <a class="code" href="class_rgbacolor.html">RGBAColor</a> &amp;color) = 0;

        virtual void <a class="code" href="class_grenderer2d.html#a10">SetDrawStyle</a>(int style) = 0;

        virtual void <a class="code" href="class_grenderer2d.html#a11">SetPointSize</a>(float radius) = 0;

        
};


#endif _GRenderBase_


</div></pre><hr><address><small>Generated at Thu Jan 27 18:51:21 2000 for blaxxunContact3D by
<a href="http://www.stack.nl/~dimitri/doxygen/index.html">
<img src="doxygen.gif" alt="doxygen" align=center border=0 
width=118 height=53></a> 1.0.0 written by <a href="mailto:dimitri@stack.nl">Dimitri van Heesch</a>,
 &copy; 1997-1999</small></address>
</body>
</html>

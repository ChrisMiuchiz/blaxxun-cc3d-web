<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta name="robots" content="noindex">
<title>GDExecutionContext Include File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body bgcolor="#ffffff">
<!-- Generated by Doxygen 1.0.0 on Thu Jan 27 18:44:26 2000 -->
<center>
<a class="qindex"href="index.html">Main Page</a> &nbsp; <a class="qindex"href="namespaces.html">Namespace List</a> &nbsp; <a class="qindex"href="hierarchy.html">Class Hierarchy</a> &nbsp; <a class="qindex"href="annotated.html">Compound List</a> &nbsp; <a class="qindex"href="files.html">File List</a> &nbsp; <a class="qindex"href="headers.html">Header Files</a> &nbsp; <a class="qindex"href="namespacemembers.html">Namespace Members</a> &nbsp; <a class="qindex"href="functions.html">Compound Members</a> &nbsp; <a class="qindex"href="globals.html">File Members</a> &nbsp; </center>
<hr><h1>gdisplaylist.h</h1>This is the verbatim text of the gdisplaylist.h include file.<div class="fragment"><pre>
#ifndef _gdisplaylist_h
#define _gdisplaylist_h

/*

GDisplaylist

*/

#include "stack.h"

#include "gstream.h"


typedef SHORT GDRelOffset;
typedef USHORT GDAbsOffset;

typedef INT32 GDRelOffset32;
typedef UINT32 GDAbsOffset32;


typedef USHORT GDOpCode;

// points to an instruction block
#define GDOP_ALIGN 2

typedef GDOpCode *GDOpPtr;

typedef USHORT GDId;

typedef USHORT GDMatId;
typedef USHORT GDTexId;
typedef USHORT GDAppId;
typedef USHORT GDVbId;

typedef USHORT GDCnt;
typedef USHORT GDIndex;
typedef USHORT GDNumIndex;


typedef enum {
        GDOP_NOP,               // NO-OP
        GDOP_EXIT,              // exit current block
        GDOP_RETURN,    // return from call 
        
        GDOP_JUMP,              //&lt;relOffset&gt;   // jump relative
        GDOP_JUMPL,             //&lt;relOffset32&gt; // jump relative
        GDOP_JUMP_ABS,  //&lt;absOffset&gt;   // jump absolute
        GDOP_JUMPL_ABS, //&lt;absOffset32&gt; // jump absolute

        GDOP_CALL,              //&lt;relOffset&gt; // call relative
        GDOP_CALLL,             //&lt;relOffset32&gt; // call relative
        GDOP_CALL_ABS,  //&lt;absOffset&gt; // call absolute
        GDOP_CALLL_ABS, //&lt;absOffset32&gt; // call absolute

        GDOP_CALL_PACKET,       // &lt;PacketId&gt; &lt;absOffset&gt;       // call packet at offset if present
        GDOP_CALLL_PACKET,      // &lt;PacketId32&gt; &lt;absOffset32&gt;

        GDOP_JUMP_IF_VB_NOT_VISIBLE, //&lt;relOffset&gt; // jump relative if current VB vertices not visible
        GDOP_JUMP_IF_BBOX_NOT_VISIBLE, //&lt;relOffset&gt; &lt;bbox&gt; // jump relative if bbox not visible

        
        GDOP_PUSH,              // push state stack
        GDOP_POP,               // pop state stack

        GDOP_TRANSFORM_ID,      // &lt;TransformId&gt;  // multiply with transform Id
        
        GDOP_TRANSFORM, // &lt;matrix&gt;     // muliply with modelling matrix immidiate
        GDOP_TRANSLATE, // &lt;float3&gt;     // muliply with translation matrix immidiate
        GDOP_ROTATE,    // &lt;float3&gt;     // muliply with rotationxyz matrix immidiate
        GDOP_ROTATE_AXIS,       // &lt;float4&gt;     // muliply with quaternation immidiate
        GDOP_SCALE,     // &lt;float3&gt;     // muliply with scale matrix immidiate
        
        // set cullding &amp; handed ness 
        GDOP_SET_CCW_SOLID,                     // set ccw TRUE, solid TRUE
        GDOP_SET_CCW_NOT_SOLID,         // set ccw TRUE, solid FALSE
        
        GDOP_SET_NOT_CCW_SOLID,         // set ccw FALSE, solid TRUE
        GDOP_SET_NOT_CCW_NOT_SOLID,     // set ccw FALSE, solid FALSE

        GDOP_SET_MATERIAL,              // &lt;MatId&gt; // set material 
        GDOP_SET_TEXTURE,               // &lt;TexId&gt; // set texture
        GDOP_SET_APPEARANCE,    // &lt;AppId&gt; // set appearance

        GDOP_SET_VB,                    // &lt;VbId&gt;  // set current vertex buffer,
        
        GDOP_SET_VB_IM,                 // &lt;vertexFormat&gt; &lt;bbox&gt; &lt;cnt&gt; &lt;bytesPerVertex&gt; &lt;align4&gt; &lt;vertexData&gt;

    GDOP_DRAW_PRIM, // &lt;primType&gt; &lt;vertexOffset&gt; &lt;vertexCount&gt; &lt;Option&gt; // Drawprimitive
    GDOP_DRAW_POLY, // &lt;plane&gt; &lt;vertexOffset&gt; &lt;vertexCount&gt;  // Drawprimitive

    GDOP_DRAW_INDEXED_PRIM, // &lt;primType&gt; &lt;vertexOffset&gt; &lt;vertexCount&gt; &lt;Option&gt; &lt;numIndex&gt; &lt;indices&gt; // Drawprimitive
        
        GDOP_SET_RENDER_OP,             // &lt;OpID&gt; &lt;data&gt; // set render operation
        GDOP_SET_TEXTURE_OP,    // &lt;OpID&gt; &lt;data&gt; // set texture operation
        GDOP_SET_TRANSFORM_OP,  // &lt;OpID&gt; &lt;data&gt; // set transform operation
        
        GDOP_SET_SELECTION_CD_ON,               // set coll detection on
        GDOP_SET_SELECTION_CD_OFF,              // set coll detection off

        GDOP_JUMP_IF_SELECTION,    //&lt;relOffset&gt; // jump relative if currently in selection processing mode
        
        GDOP_SET_ANCHOR,        //  &lt;AnchorInfo&gt;
        GDOP_BSP_PLANE,         // &lt;plane&gt; left&lt;relOffset&gt; on&lt;relOffset&gt; right&lt;relOffset&gt;       // BspTree node
        GDOP_BSP_PLANE_B2F, // &lt;plane&gt; left&lt;relOffset&gt; on&lt;relOffset&gt; right&lt;relOffset&gt;// BspTree back 2 front 

        GDOP_RANGE_LOD,         // &lt;cnt&gt; &lt;levels&gt; &lt;relOffsets&gt;          // LOD node
        GDOP_SWITCH,            // &lt;ChoiceId&gt; &lt;cnt&gt; &lt;relOffsets&gt;        // Switch  node
        
        GDOP_BILLBOARD,         // axisOfRotion                 // BillBoard
        GDOP_BILLBOARD_SCREEN,  //      // BillBoard screen aligned


} GDOpCode_Enum;


// exactly maps  D3DPRIMITIVETYPE
typedef enum {
    GDPT_POINTLIST     = 1,
    GDPT_LINELIST       = 2,
    GDPT_LINESTRIP     = 3,
    GDPT_TRIANGLELIST  = 4,
    GDPT_TRIANGLESTRIP = 5,
    GDPT_TRIANGLEFAN   = 6,
} GDPrimType;

// Flexible vertex format bits
// maps D3D level 7 bits
#define GDFVF_RESERVED0        0x001
#define GDFVF_POSITION_MASK    0x00E
#define GDFVF_XYZ              0x002
#define GDFVF_XYZRHW           0x004
#define GDFVF_XYZB1            0x006
#define GDFVF_XYZB2            0x008
#define GDFVF_XYZB3            0x00a
#define GDFVF_XYZB4            0x00c
#define GDFVF_XYZB5            0x00e
#define GDFVF_NORMAL           0x010
#define GDFVF_RESERVED1        0x020
#define GDFVF_DIFFUSE          0x040
#define GDFVF_SPECULAR         0x080

#define GDFVF_TEXCOUNT_MASK    0xf00
#define GDFVF_TEXCOUNT_SHIFT   8
#define GDFVF_TEX0             0x000
#define GDFVF_TEX1             0x100
#define GDFVF_TEX2             0x200
#define GDFVF_TEX3             0x300
#define GDFVF_TEX4             0x400
#define GDFVF_TEX5             0x500
#define GDFVF_TEX6             0x600
#define GDFVF_TEX7             0x700
#define GDFVF_TEX8             0x800

#define GDFVF_RESERVED2        0xf000  // 4 reserved bits


class <a class="code" href="class_gbufferstream.html">GBufferStream</a> 
{
public :

};


class <a class="code" href="class_gdexecutioncontext.html">GDExecutionContext</a> : public <a class="code" href="class_gmemmap.html">GMemMap</a> {
public :

        <a class="code" href="class_stack.html">Stack</a> &lt;GMemPtr&gt; callStack; 

        <a class="code" href="class_gdexecutioncontext.html#a0">GDExecutionContext</a>(size_t       size, GMemPtr base);
        <a class="code" href="class_gdexecutioncontext.html#a1">~GDExecutionContext</a>();

        gbool <a class="code" href="class_gdexecutioncontext.html#a2">VerifyEx</a>();
        gbool <a class="code" href="class_gdexecutioncontext.html#a3">VerifyCallStack</a>() { return callStack.Length()&gt;0; }


        GDFloatEncoding bboxEncoding;
        GDFloatEncoding planeEncoding;
        GDFloatEncoding coordEncoding;
        GDFloatEncoding texCoordEncoding;
        GDFloatEncoding normalEncoding;
        GDFloatEncoding matrixEncoding;

        inline GDOpCode_Enum <a class="code" href="class_gdexecutioncontext.html#a4">getOp</a>() { return (GDOpCode_Enum) *((GDOpCode *&amp;)current)++;; }

        inline void <a class="code" href="class_gdexecutioncontext.html#a5">jumpRel</a>(GDRelOffset offset) { current = current + (((INT32) offset) * GDOP_ALIGN); }
        
        inline void <a class="code" href="class_gdexecutioncontext.html#a6">jumpAbs</a>(GDAbsOffset offset) { current = base + (((UINT32) offset) * GDOP_ALIGN); }

        inline void <a class="code" href="class_gdexecutioncontext.html#a7">callRel</a>(GDRelOffset offset) { <a class="code" href="class_gdexecutioncontext.html#a9">push</a>(); current = current + (((INT32) offset) * GDOP_ALIGN); }
        
        inline void <a class="code" href="class_gdexecutioncontext.html#a8">callAbs</a>(GDAbsOffset offset) { <a class="code" href="class_gdexecutioncontext.html#a9">push</a>(); current = base + (((INT32) offset) * GDOP_ALIGN); }

        // ! push instruction pointer
        inline void <a class="code" href="class_gdexecutioncontext.html#a9">push</a>() { callStack.<a class="code" href="class_stack.html#a5">Push</a>(current); }
        
        // ! pop instruction pointer
        inline void <a class="code" href="class_gdexecutioncontext.html#a10">pop</a>() { current = callStack.<a class="code" href="class_stack.html#a8">Pop</a>(); }
        
        inline void <a class="code" href="class_gdexecutioncontext.html#a11">return_</a>() { <a class="code" href="class_gdexecutioncontext.html#a10">pop</a>(); }
        
        // ! get an relative instruction offset
        inline GDRelOffset <a class="code" href="class_gdexecutioncontext.html#a12">getRelOffset</a>() { return *((GDRelOffset *&amp;)current)++; }
        inline GDRelOffset32 <a class="code" href="class_gdexecutioncontext.html#a13">getRelOffset32</a>() { return *((GDRelOffset32 *&amp;)current)++; }
        
        // ! get an absolute instruction offset TO DO Alignment ?
        inline GDAbsOffset <a class="code" href="class_gdexecutioncontext.html#a14">getAbsOffset</a>() { return *((GDAbsOffset *&amp;)current)++; }
        inline GDAbsOffset32 <a class="code" href="class_gdexecutioncontext.html#a15">getAbsOffset32</a>() { return *((GDAbsOffset32 *&amp;)current)++; }

        inline GDId <a class="code" href="class_gdexecutioncontext.html#a16">getId</a>() { return *((GDId *&amp;)current)++; }

        void <a class="code" href="class_gmemmap.html#a15">align4</a>() { // UINT32 *&amp;p = ((UINT32 *)current);
                                        if (((UINT32) current) &amp; 2) current+=1;
        }
        void <a class="code" href="class_gmemmap.html#a16">align8</a>() { }
        void <a class="code" href="class_gmemmap.html#a17">align16</a>() { }
        void <a class="code" href="class_gmemmap.html#a18">align32</a>() { }

        inline void <a class="code" href="class_gmemmap.html#a19">getFloats</a>(GDFloatEncoding encoding, size_t cnt, float *buffer) 
        {

                switch (encoding) {
                case GDF_FLOAT : { size_t s=cnt*sizeof(float);
                                                   <a class="code" href="class_gmemmap.html#a15">align4</a>(); 
                                                   memcpy(buffer,current,s); 
                                                   ((UINT32 *&amp;)current) +=s;
                                                   return; 
                                                 }
                case GDF_DOUBLE : { 
                                                   size_t s=cnt*sizeof(double);
                                                   <a class="code" href="class_gmemmap.html#a16">align8</a>(); 
                                                   const double *p= (const double *) current;
                                                   if (cnt&gt;0) 
                                                   do {
                                                          *buffer++ = *p++;     
                                                   } while (cnt--);        

                                                   ((UINT32 *&amp;)current) +=s;
                                                   
                                                   return; 
                                                 }
                case GDF_SHORT : { 
                                                   size_t s=cnt*sizeof(SHORT);
                                                   const SHORT *p= (const SHORT *) current;
                                                   if (cnt&gt;0) 
                                                   do {
                                                          *buffer++ = *p++;     
                                                   } while (cnt--);        

                                                   ((UINT32 *&amp;)current) +=s;
                                                   
                                                   return; 
                                                 }
                case GDF_FIX_8_8 : { 
                                                   size_t s=cnt*sizeof(SHORT);
                                                   const SHORT *p= (const SHORT *) current;
                                                   if (cnt&gt;0) 
                                                   do {
                                                          *buffer++ = <a class="code" href="gstream.h.html#a0">Fix8_8</a>(*p++);     
                                                   } while (cnt--);        

                                                   ((UINT32 *&amp;)current) +=s;
                                                   
                                                   return; 
                                                 }

                case GDF_FIX_13_3 : { 
                                                   size_t s=cnt*sizeof(SHORT);
                                                   const SHORT *p= (const SHORT *) current;
                                                   if (cnt&gt;0) 
                                                   do {
                                                          *buffer++ = <a class="code" href="gstream.h.html#a1">Fix13_3</a>(*p++);    
                                                   } while (cnt--);        

                                                   ((UINT32 *&amp;)current) +=s;
                                                   
                                                   return; 
                                                 }
                }
        }

        void <a class="code" href="class_gdexecutioncontext.html#a22">getPlane</a> (<a class="code" href="class_plane.html">Plane</a> &amp;p) {
                <a class="code" href="class_gmemmap.html#a19">getFloats</a>(planeEncoding,4,&amp;p.n.x);
        }

        void <a class="code" href="class_gdexecutioncontext.html#a23">getPoint</a> (<a class="code" href="class_point.html">Point</a> &amp;p) {
                <a class="code" href="class_gmemmap.html#a19">getFloats</a>(matrixEncoding,3,&amp;p.x);
        }
        void <a class="code" href="class_gdexecutioncontext.html#a24">getAngle</a>(float &amp;<a class="code" href="class_a.html">a</a>) {
                <a class="code" href="class_gmemmap.html#a19">getFloats</a>(matrixEncoding,1,&amp;<a class="code" href="class_a.html">a</a>);
        }

        void <a class="code" href="class_gdexecutioncontext.html#a25">getAxisAngle</a>(<a class="code" href="class_point.html">Point</a> &amp;p,float &amp;<a class="code" href="class_a.html">a</a>) {
                <a class="code" href="class_gmemmap.html#a19">getFloats</a>(matrixEncoding,3,&amp;p.x);
                <a class="code" href="class_gdexecutioncontext.html#a24">getAngle</a>(<a class="code" href="class_a.html">a</a>);
        }
        
        void <a class="code" href="class_gdexecutioncontext.html#a26">getBBox</a> (<a class="code" href="class_bbox.html">BBox</a> &amp;p) {
                <a class="code" href="class_gmemmap.html#a19">getFloats</a>(bboxEncoding,6,&amp;p.mi.x);
        }

        void <a class="code" href="class_gdexecutioncontext.html#a27">getMatrix</a> (<a class="code" href="class_matrix.html">Matrix</a> &amp;m) {
                <a class="code" href="class_gmemmap.html#a19">getFloats</a>(matrixEncoding,16,&amp;m.x[0][0]);
                // contents is anything by default 
        }

        // return a string pointer 
        void <a class="code" href="class_gmemmap.html#a13">getString</a>(const char * &amp;string) {

           UINT32 s=<a class="code" href="class_gmemmap.html#a10">getCnt</a>(); 
           string = (const char *) current;
           if (s&amp;1) s+=1; // 2 byte aligned 
           ((UINT32 *&amp;)current) +=s;
        }


};



/*
        chunks
        
        MaterialTable
        TextureTable 
        SoundTable
        


*/

#endif _gdisplaylist_h

</div></pre><hr><address><small>Generated at Thu Jan 27 18:44:26 2000 for blaxxunContact3D by
<a href="http://www.stack.nl/~dimitri/doxygen/index.html">
<img src="doxygen.gif" alt="doxygen" align=center border=0 
width=118 height=53></a> 1.0.0 written by <a href="mailto:dimitri@stack.nl">Dimitri van Heesch</a>,
 &copy; 1997-1999</small></address>
</body>
</html>

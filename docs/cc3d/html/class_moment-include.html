<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta name="robots" content="noindex">
<title>moment Include File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body bgcolor="#ffffff">
<!-- Generated by Doxygen 1.0.0 on Thu Jan 27 18:55:58 2000 -->
<center>
<a class="qindex"href="index.html">Main Page</a> &nbsp; <a class="qindex"href="namespaces.html">Namespace List</a> &nbsp; <a class="qindex"href="hierarchy.html">Class Hierarchy</a> &nbsp; <a class="qindex"href="annotated.html">Compound List</a> &nbsp; <a class="qindex"href="files.html">File List</a> &nbsp; <a class="qindex"href="headers.html">Header Files</a> &nbsp; <a class="qindex"href="namespacemembers.html">Namespace Members</a> &nbsp; <a class="qindex"href="functions.html">Compound Members</a> &nbsp; <a class="qindex"href="globals.html">File Members</a> &nbsp; </center>
<hr><h1>moments.h</h1>This is the verbatim text of the moments.h include file.<div class="fragment"><pre>#ifndef MOMENTS_H
#define MOMENTS_H

#include "matvec.h"
#include "obb.h"

struct <a class="code" href="class_moment.html">moment</a>
{
  float A;  
  float m[3];
  float s[3][3];
};

struct <a class="code" href="class_accum.html">accum</a>
{
  float A;
  float m[3];
  float s[3][3];
};

inline
void
<a class="code" href="moments.h.html#a0">print_moment</a>(<a class="code" href="class_moment.html">moment</a> &amp;M)
{
  fprintf(stderr, "A: %g, m: %g %g %g, s: %g %g %g %g %g %g\n",
          M.A,
          M.m[0], M.m[1], M.m[2],
          M.s[0][0], M.s[0][1], M.s[0][2], M.s[1][1], M.s[1][2], M.s[2][2]);
}


inline
void
<a class="code" href="moments.h.html#a1">clear_accum</a>(<a class="code" href="class_accum.html">accum</a> &amp;<a class="code" href="class_a.html">a</a>)
{
  <a class="code" href="class_a.html">a</a>.m[0] = <a class="code" href="class_a.html">a</a>.m[1] = <a class="code" href="class_a.html">a</a>.m[2] = 0.0;
  <a class="code" href="class_a.html">a</a>.s[0][0] = <a class="code" href="class_a.html">a</a>.s[0][1] = <a class="code" href="class_a.html">a</a>.s[0][2] = 0.0;
  <a class="code" href="class_a.html">a</a>.s[1][0] = <a class="code" href="class_a.html">a</a>.s[1][1] = <a class="code" href="class_a.html">a</a>.s[1][2] = 0.0;
  <a class="code" href="class_a.html">a</a>.s[2][0] = <a class="code" href="class_a.html">a</a>.s[2][1] = <a class="code" href="class_a.html">a</a>.s[2][2] = 0.0;
  <a class="code" href="class_a.html">a</a>.A = 0.0;
}

inline
void
<a class="code" href="moments.h.html#a2">accum_moment</a>(<a class="code" href="class_accum.html">accum</a> &amp;<a class="code" href="class_a.html">a</a>, <a class="code" href="class_moment.html">moment</a> &amp;b)
{
  <a class="code" href="class_a.html">a</a>.m[0] += b.m[0] * b.A;
  <a class="code" href="class_a.html">a</a>.m[1] += b.m[1] * b.A;
  <a class="code" href="class_a.html">a</a>.m[2] += b.m[2] * b.A;
  
  <a class="code" href="class_a.html">a</a>.s[0][0] += b.s[0][0];
  <a class="code" href="class_a.html">a</a>.s[0][1] += b.s[0][1];
  <a class="code" href="class_a.html">a</a>.s[0][2] += b.s[0][2];
  <a class="code" href="class_a.html">a</a>.s[1][0] += b.s[1][0];
  <a class="code" href="class_a.html">a</a>.s[1][1] += b.s[1][1];
  <a class="code" href="class_a.html">a</a>.s[1][2] += b.s[1][2];
  <a class="code" href="class_a.html">a</a>.s[2][0] += b.s[2][0];
  <a class="code" href="class_a.html">a</a>.s[2][1] += b.s[2][1];
  <a class="code" href="class_a.html">a</a>.s[2][2] += b.s[2][2];

  <a class="code" href="class_a.html">a</a>.A += b.A;
}

inline
void
<a class="code" href="moments.h.html#a3">mean_from_moment</a>(float M[3], <a class="code" href="class_moment.html">moment</a> &amp;m)
{
  M[0] = m.m[0];
  M[1] = m.m[1];
  M[2] = m.m[2];
}

inline
void
<a class="code" href="moments.h.html#a4">mean_from_accum</a>(float M[3], <a class="code" href="class_accum.html">accum</a> &amp;<a class="code" href="class_a.html">a</a>)
{
  M[0] = <a class="code" href="class_a.html">a</a>.m[0] / <a class="code" href="class_a.html">a</a>.A;
  M[1] = <a class="code" href="class_a.html">a</a>.m[1] / <a class="code" href="class_a.html">a</a>.A;
  M[2] = <a class="code" href="class_a.html">a</a>.m[2] / <a class="code" href="class_a.html">a</a>.A;
}

inline
void
<a class="code" href="moments.h.html#a5">covariance_from_accum</a>(float C[3][3], <a class="code" href="class_accum.html">accum</a> &amp;<a class="code" href="class_a.html">a</a>)
{
  int i,j;
  for(i=0; i&lt;3; i++)
    for(j=0; j&lt;3; j++)
      C[i][j] = <a class="code" href="class_a.html">a</a>.s[i][j] - <a class="code" href="class_a.html">a</a>.m[i]*<a class="code" href="class_a.html">a</a>.m[j]/<a class="code" href="class_a.html">a</a>.A;
}



inline
void
<a class="code" href="moments.h.html#a6">compute_moment</a>(<a class="code" href="class_moment.html">moment</a> &amp;M, const float p[3], const float q[3], const float r[3])
{
  float u[3], v[3], w[3];

  // compute the area of the triangle
  <a class="code" href="matvec.h.html#a23">VmV</a>(u, q, p);
  <a class="code" href="matvec.h.html#a23">VmV</a>(v, r, p);
  <a class="code" href="matvec.h.html#a27">VcrossV</a>(w, u, v);
  M.A = 0.5 * <a class="code" href="matvec.h.html#a28">Vlength</a>(w);

  if (M.A == 0.0)
    {
      // This triangle has zero area.  The second order components
      // would be eliminated with the usual formula, so, for the 
      // sake of robustness we use an alternative form.  These are the 
      // centroid and second-order components of the triangle's vertices.

      // centroid
      M.m[0] = (p[0] + q[0] + r[0]) /3;
      M.m[1] = (p[1] + q[1] + r[1]) /3;
      M.m[2] = (p[2] + q[2] + r[2]) /3;

      // second-order components
      M.s[0][0] = (p[0]*p[0] + q[0]*q[0] + r[0]*r[0]);
      M.s[0][1] = (p[0]*p[1] + q[0]*q[1] + r[0]*r[1]);
      M.s[0][2] = (p[0]*p[2] + q[0]*q[2] + r[0]*r[2]);
      M.s[1][1] = (p[1]*p[1] + q[1]*q[1] + r[1]*r[1]);
      M.s[1][2] = (p[1]*p[2] + q[1]*q[2] + r[1]*r[2]);
      M.s[2][2] = (p[2]*p[2] + q[2]*q[2] + r[2]*r[2]);      
      M.s[2][1] = M.s[1][2];
      M.s[1][0] = M.s[0][1];
      M.s[2][0] = M.s[0][2];

      return;
    }

  // get the centroid
  M.m[0] = (p[0] + q[0] + r[0])/3;
  M.m[1] = (p[1] + q[1] + r[1])/3;
  M.m[2] = (p[2] + q[2] + r[2])/3;

  // get the second order components -- note the weighting by the area
  M.s[0][0] = M.A*(9*M.m[0]*M.m[0]+p[0]*p[0]+q[0]*q[0]+r[0]*r[0])/12;
  M.s[0][1] = M.A*(9*M.m[0]*M.m[1]+p[0]*p[1]+q[0]*q[1]+r[0]*r[1])/12;
  M.s[1][1] = M.A*(9*M.m[1]*M.m[1]+p[1]*p[1]+q[1]*q[1]+r[1]*r[1])/12;
  M.s[0][2] = M.A*(9*M.m[0]*M.m[2]+p[0]*p[2]+q[0]*q[2]+r[0]*r[2])/12;
  M.s[1][2] = M.A*(9*M.m[1]*M.m[2]+p[1]*p[2]+q[1]*q[2]+r[1]*r[2])/12;
  M.s[2][2] = M.A*(9*M.m[2]*M.m[2]+p[2]*p[2]+q[2]*q[2]+r[2]*r[2])/12;
  M.s[2][1] = M.s[1][2];
  M.s[1][0] = M.s[0][1];
  M.s[2][0] = M.s[0][2];
}

inline
void
<a class="code" href="moments.h.html#a7">compute_moments</a>(<a class="code" href="class_moment.html">moment</a> *M, <a class="code" href="class_tri.html">tri</a> *tris, int num_tris)
{
  int i;

  // first collect all the moments, and obtain the area of the 
  // smallest nonzero area triangle.

  float Amin = 0.0;
  int zero = 0;
  int nonzero = 0;
  for(i=0; i&lt;num_tris; i++)
    {
      <a class="code" href="moments.h.html#a6">compute_moment</a>(M[i], 
                     tris[i].p1,
                     tris[i].p2, 
                     tris[i].p3);  
      if (M[i].A == 0.0)
        {
          zero = 1;
        }
      else
        {
          nonzero = 1;
          if (Amin == 0.0) Amin = M[i].A;
          else if (M[i].A &lt; Amin) Amin = M[i].A;
        }
    }

  if (zero)
    {
      fprintf(stderr, "----\n");
      fprintf(stderr, "Warning!  Some triangles have zero area!\n");
      fprintf(stderr, "----\n");

      // if there are any zero area triangles, go back and set their area
      
      // if ALL the triangles have zero area, then set the area thingy
      // to some arbitrary value.
      if (Amin == 0.0) Amin = 1.0;

      for(i=0; i&lt;num_tris; i++)
        {
          if (M[i].A == 0.0) M[i].A = Amin;
        }
      
    }
}

#endif
</div></pre><hr><address><small>Generated at Thu Jan 27 18:55:58 2000 for blaxxunContact3D by
<a href="http://www.stack.nl/~dimitri/doxygen/index.html">
<img src="doxygen.gif" alt="doxygen" align=center border=0 
width=118 height=53></a> 1.0.0 written by <a href="mailto:dimitri@stack.nl">Dimitri van Heesch</a>,
 &copy; 1997-1999</small></address>
</body>
</html>

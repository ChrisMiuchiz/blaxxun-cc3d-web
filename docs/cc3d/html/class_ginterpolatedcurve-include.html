<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta name="robots" content="noindex">
<title>GInterpolatedCurve Include File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body bgcolor="#ffffff">
<!-- Generated by Doxygen 1.0.0 on Thu Jan 27 18:45:40 2000 -->
<center>
<a class="qindex"href="index.html">Main Page</a> &nbsp; <a class="qindex"href="namespaces.html">Namespace List</a> &nbsp; <a class="qindex"href="hierarchy.html">Class Hierarchy</a> &nbsp; <a class="qindex"href="annotated.html">Compound List</a> &nbsp; <a class="qindex"href="files.html">File List</a> &nbsp; <a class="qindex"href="headers.html">Header Files</a> &nbsp; <a class="qindex"href="namespacemembers.html">Namespace Members</a> &nbsp; <a class="qindex"href="functions.html">Compound Members</a> &nbsp; <a class="qindex"href="globals.html">File Members</a> &nbsp; </center>
<hr><h1>gsurface.h</h1>This is the verbatim text of the gsurface.h include file.<div class="fragment"><pre>/*=============================================================================

This code is licensed under the Web3D-blaxxun Community Source License,
provided in distribution file LICENSE.TXT and available online at
http://www.web3D.org/TaskGroups/x3d/blaxxun/Web3D-blaxxunCommunitySourceAgreement.html
and may only be used for non-commercial use as specified in that license.

THE WEB3D CONSORTIUM AND BLAXXUN DO NOT MAKE AND HEREBY DISCLAIM ANY EXPRESS
OR IMPLIED WARRANTIES RELATING TO THIS CODE, INCLUDING BUT NOT LIMITED TO,
WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY OR FITNESS FOR A PARTICULAR
PURPOSE, OR ANY WARRANTIES THAT MIGHT ARISE FROM A COURSE OF DEALING, USAGE
OR TRADE PRACTICE.  THE COMMUNITY SOURCE CODE IS PROVIDED UNDER THIS
AGREEMENT "AS IS," WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
INCLUDING, WITHOUT LIMITATION, WARRANTIES THAT THE COMMUNITY SOURCE CODE ARE
FREE OF DEFECTS, MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE OR
NON-INFRINGING OR IN ANY WAY CONSTITUTE THE COMPLETE PRODUCT MARKETED UNDER
THE NAMES GIVEN SAID CODE.

==============================================================================*/
#ifndef _GSurface_h_
#define _GSurface_h_

// HG 
#include &lt;gvsfenum.h&gt;
#include &lt;gvsfvec2f.h&gt;
#include &lt;gvsfvec3f.h&gt;
#include &lt;gvsffloat.h&gt;
#include &lt;gvsfbool.h&gt;
#include &lt;gvsflong.h&gt;
#include &lt;gvgroup.h&gt;
#include &lt;gvsubnode.h&gt;
#include &lt;gvsfnode.h&gt;
#include &lt;gvmfnode.h&gt;
#include &lt;gvnodeshell.h&gt;


class <a class="code" href="class_gcurve.html">GCurve</a> : public <a class="code" href="class_gvnode.html">GvNode</a>
{
   <a class="code" href="class_gcurve.html#c0">GV_NODE_HEADER</a>(<a class="code" href="class_gcurve.html">GCurve</a>);
public:

   <a class="code" href="class_gvsfvec2f.html">GvSFVec2f</a>    urange;
   
   int dim; // 1 1d 2: 2d 3 : 3d
   int <a class="code" href="class_gcurve.html#a0">Dim</a>()  { return(dim); }

   // evaluate point at paratmer (u) 
   virtual int <a class="code" href="class_gvnode.html#a59">Eval</a>(const float *<a class="code" href="class_parameter.html">parameter</a>,<a class="code" href="class_point.html">Point</a> &amp;p);
        
   // Evaluate normal at parameter (u)
   virtual int <a class="code" href="class_gcurve.html#a2">EvalNormal</a>(const float *<a class="code" href="class_parameter.html">parameter</a>,<a class="code" href="class_point.html">Point</a> &amp;n);


};

class <a class="code" href="class_gmodulatedcurve.html">GModulatedCurve</a> : public <a class="code" href="class_gcurve.html">GCurve</a>
{
   <a class="code" href="class_gcurve.html#c0">GV_NODE_HEADER</a>(<a class="code" href="class_gmodulatedcurve.html">GModulatedCurve</a>);
public:
   <a class="code" href="class_gvsfnode.html">GvSFNode</a> curve;
   <a class="code" href="class_gvsfnode.html">GvSFNode</a> modulator;
};

class <a class="code" href="class_gtransformedcurve.html">GTransformedCurve</a> : public <a class="code" href="class_gcurve.html">GCurve</a>
{
   <a class="code" href="class_gcurve.html#c0">GV_NODE_HEADER</a>(<a class="code" href="class_gtransformedcurve.html">GTransformedCurve</a>);
public:
   <a class="code" href="class_gvsfnode.html">GvSFNode</a> curve;
   <a class="code" href="class_gvsfnode.html">GvSFNode</a> transformation;
};

class <a class="code" href="class_gconcatenatedcurve.html">GConcatenatedCurve</a> : public <a class="code" href="class_gcurve.html">GCurve</a>
{
   <a class="code" href="class_gcurve.html#c0">GV_NODE_HEADER</a>(<a class="code" href="class_gconcatenatedcurve.html">GConcatenatedCurve</a>);

public:
   <a class="code" href="class_gvmfnode.html">GvMFNode</a> curves;
};

class <a class="code" href="class_ginterpolatedcurve.html">GInterpolatedCurve</a> : public <a class="code" href="class_gcurve.html">GCurve</a>
{
   <a class="code" href="class_gcurve.html#c0">GV_NODE_HEADER</a>(<a class="code" href="class_ginterpolatedcurve.html">GInterpolatedCurve</a>);

public:
   <a class="code" href="class_gvsffloat.html">GvSFFloat</a> t;
   <a class="code" href="class_gvmfnode.html">GvMFNode</a> curves;

};


class <a class="code" href="class_gcircle.html">GCircle</a> : public <a class="code" href="class_gcurve.html">GCurve</a>
{
   <a class="code" href="class_gcurve.html#c0">GV_NODE_HEADER</a>(<a class="code" href="class_gcircle.html">GCircle</a>);
public:
   <a class="code" href="class_gvsffloat.html">GvSFFloat</a> r;  // 1.0
        int <a class="code" href="class_gvnode.html#a59">Eval</a>(const float *<a class="code" href="class_parameter.html">parameter</a>,<a class="code" href="class_point.html">Point</a> &amp;p);
        int <a class="code" href="class_gcurve.html#a2">EvalNormal</a>(const float *<a class="code" href="class_parameter.html">parameter</a>,<a class="code" href="class_point.html">Point</a> &amp;n);

};


class <a class="code" href="class_gspiral.html">GSpiral</a> : public <a class="code" href="class_gcurve.html">GCurve</a>
{
   <a class="code" href="class_gcurve.html#c0">GV_NODE_HEADER</a>(<a class="code" href="class_gspiral.html">GSpiral</a>);
public:
   <a class="code" href="class_gvsffloat.html">GvSFFloat</a> r0;
   <a class="code" href="class_gvsffloat.html">GvSFFloat</a> r1;
   <a class="code" href="class_gvsffloat.html">GvSFFloat</a> angle0;
   <a class="code" href="class_gvsffloat.html">GvSFFloat</a> angle1;
   <a class="code" href="class_gvsffloat.html">GvSFFloat</a> z0;
   <a class="code" href="class_gvsffloat.html">GvSFFloat</a> z1;

};

class <a class="code" href="class_gsinus.html">GSinus</a> : public <a class="code" href="class_gcurve.html">GCurve</a>
{
   <a class="code" href="class_gcurve.html#c0">GV_NODE_HEADER</a>(<a class="code" href="class_gsinus.html">GSinus</a>);
public:
   <a class="code" href="class_gvsffloat.html">GvSFFloat</a> r0;
   <a class="code" href="class_gvsffloat.html">GvSFFloat</a> r1;

};

class <a class="code" href="class_gpointoncurve.html">GPointOnCurve</a> : public <a class="code" href="class_gvnode.html">GvNode</a>
{
   <a class="code" href="class_gcurve.html#c0">GV_NODE_HEADER</a>(<a class="code" href="class_gpointoncurve.html">GPointOnCurve</a>);
public:
        // fields
        <a class="code" href="class_gvsfnode.html">GvSFNode</a>        curve; // the curve

        // EventIn
        <a class="code" href="class_gvsffloat.html">GvSFFloat</a>       fraction;       // parameter to evaluate cuve

        // EventOut
        <a class="code" href="class_gvsfvec3f.html">GvSFVec3f</a>       value;          // evaluated point

};

// Point on Curve2


// ********** GSurface
class <a class="code" href="class_gsurface.html">GSurface</a> : public <a class="code" href="class_gvnode.html">GvNode</a> {
   <a class="code" href="class_gcurve.html#c0">GV_NODE_HEADER</a>(<a class="code" href="class_gsurface.html">GSurface</a>);
public:

        // Evaluate a point at parameter(u,v)
        virtual int <a class="code" href="class_gvnode.html#a59">Eval</a>(const <a class="code" href="class_point.html">Point</a> &amp;<a class="code" href="class_parameter.html">parameter</a>,<a class="code" href="class_point.html">Point</a> &amp;p);
        
        // Evaluate normal at parameter(u,v)
        virtual int <a class="code" href="class_gcurve.html#a2">EvalNormal</a>(const <a class="code" href="class_point.html">Point</a> &amp;<a class="code" href="class_parameter.html">parameter</a>,<a class="code" href="class_point.html">Point</a> &amp;n);

        // Evaluate a point &amp; normal at parameter(u,v)
        virtual int <a class="code" href="class_gvnode.html#a59">Eval</a>(const <a class="code" href="class_point.html">Point</a> &amp;<a class="code" href="class_parameter.html">parameter</a>,<a class="code" href="class_point.html">Point</a> &amp;p,<a class="code" href="class_point.html">Point</a> &amp;n);
        
        // Map point to parameter
        virtual int <a class="code" href="class_gsurface.html#a3">Map</a>(const <a class="code" href="class_point.html">Point</a> &amp;p,<a class="code" href="class_point.html">Point</a> &amp;<a class="code" href="class_parameter.html">parameter</a>);

        // Ray intersection
        virtual int <a class="code" href="class_gsurface.html#a4">Intersect</a>(const <a class="code" href="class_ray.html">Ray</a> &amp;ray,float &amp;t); 

        virtual int <a class="code" href="class_gsurface.html#a4">Intersect</a>(const <a class="code" href="class_ray.html">Ray</a> &amp;r,<a class="code" href="class_point.html">Point</a> &amp;p);

        // is Eval(0,x) == Eval(1,x) ?
        virtual int <a class="code" href="class_gsurface.html#a6">ClosedInU</a>() { return(0); };
        // is Eval(x,0) == Eval(x,1) ?
        virtual int <a class="code" href="class_gsurface.html#a7">ClosedInV</a>() { return(0); };

        // get bbox
        // Inside
        // Distance(const Point *p)

};

class <a class="code" href="class_gskinsurface.html">GSkinSurface</a> : public <a class="code" href="class_gsurface.html">GSurface</a> {
   <a class="code" href="class_gcurve.html#c0">GV_NODE_HEADER</a>(<a class="code" href="class_gskinsurface.html">GSkinSurface</a>);
public:

   <a class="code" href="class_gvmfnode.html">GvMFNode</a> curves;  // a set of profiles to connect

};

class <a class="code" href="class_gsweepsurface.html">GSweepSurface</a> : public <a class="code" href="class_gsurface.html">GSurface</a> {
   <a class="code" href="class_gcurve.html#c0">GV_NODE_HEADER</a>(<a class="code" href="class_gsweepsurface.html">GSweepSurface</a>);
public:

   <a class="code" href="class_gvsfnode.html">GvSFNode</a> profile;  //profile
   <a class="code" href="class_gvsfnode.html">GvSFNode</a> path;     // sweep profile along path
   <a class="code" href="class_gvsfbool.html">GvSFBool</a> tangential; // flag
   
   <a class="code" href="class_gvsfnode.html">GvSFNode</a> modulator;  // optional 1d modulator curve 


};


// coons bpathc
class <a class="code" href="class_gbilinearsurface.html">GBilinearSurface</a> : public <a class="code" href="class_gsurface.html">GSurface</a> 
{
   <a class="code" href="class_gcurve.html#c0">GV_NODE_HEADER</a>(<a class="code" href="class_gbilinearsurface.html">GBilinearSurface</a>);
public:

   <a class="code" href="class_gvsfnode.html">GvSFNode</a> left,right;
   <a class="code" href="class_gvsfnode.html">GvSFNode</a> top,bottom;

};


class <a class="code" href="class_gmodulatedsurface.html">GModulatedSurface</a> : public <a class="code" href="class_gsurface.html">GSurface</a>

{
   <a class="code" href="class_gcurve.html#c0">GV_NODE_HEADER</a>(<a class="code" href="class_gmodulatedsurface.html">GModulatedSurface</a>);
public:

   <a class="code" href="class_gvsfnode.html">GvSFNode</a> surface;
   <a class="code" href="class_gvsfnode.html">GvSFNode</a> modulator;  // 1 D curve
};

class <a class="code" href="class_gtransformedsurface.html">GTransformedSurface</a> : public <a class="code" href="class_gsurface.html">GSurface</a>
{
   <a class="code" href="class_gcurve.html#c0">GV_NODE_HEADER</a>(<a class="code" href="class_gtransformedsurface.html">GTransformedSurface</a>);
public:

   <a class="code" href="class_gvsfnode.html">GvSFNode</a> curve;
   <a class="code" href="class_gvsfnode.html">GvSFNode</a> transformation;
};

class <a class="code" href="class_gconcatenatedsurface.html">GConcatenatedSurface</a> : public <a class="code" href="class_gsurface.html">GSurface</a>
{
   <a class="code" href="class_gcurve.html#c0">GV_NODE_HEADER</a>(<a class="code" href="class_gconcatenatedsurface.html">GConcatenatedSurface</a>);
public:

   <a class="code" href="class_gvsflong.html">GvSFLong</a> rows;
   <a class="code" href="class_gvsflong.html">GvSFLong</a> cols;

   <a class="code" href="class_gvmfnode.html">GvMFNode</a> surfaces;
};


class <a class="code" href="class_ginterpolatedsurface.html">GInterpolatedSurface</a> : public <a class="code" href="class_gsurface.html">GSurface</a>
{
   <a class="code" href="class_gcurve.html#c0">GV_NODE_HEADER</a>(<a class="code" href="class_ginterpolatedsurface.html">GInterpolatedSurface</a>);
public:

   <a class="code" href="class_gvsffloat.html">GvSFFloat</a> t;
   <a class="code" href="class_gvmfnode.html">GvMFNode</a> surfaces;

};




class <a class="code" href="class_gspheresurface.html">GSphereSurface</a> : public <a class="code" href="class_gsurface.html">GSurface</a> {


   <a class="code" href="class_gcurve.html#c0">GV_NODE_HEADER</a>(<a class="code" href="class_gspheresurface.html">GSphereSurface</a>);


public:
        
        <a class="code" href="class_gvsffloat.html">GvSFFloat</a> r;    // Default : 1.0

        int <a class="code" href="class_gsurface.html#a6">ClosedInU</a>() { return(1); };
        int <a class="code" href="class_gsurface.html#a7">ClosedInV</a>() { return(1); };


        int <a class="code" href="class_gvnode.html#a59">Eval</a>(const <a class="code" href="class_point.html">Point</a> &amp;<a class="code" href="class_parameter.html">parameter</a>,<a class="code" href="class_point.html">Point</a> &amp;p) 
        {
           float u = (<a class="code" href="class_parameter.html">parameter</a>.x+0.25) * TWOPI;
           float v = (<a class="code" href="class_parameter.html">parameter</a>.y-0.0 ) * PI;
           p.<a class="code" href="class_point.html#a6">Set</a>(r*cos(u)*sin(v),r*sin(u)*sin(v),r*cos(v));
           return(1);
        };
        
        int <a class="code" href="class_gcurve.html#a2">EvalNormal</a>(const <a class="code" href="class_point.html">Point</a> &amp;<a class="code" href="class_parameter.html">parameter</a>,<a class="code" href="class_point.html">Point</a> &amp;n) {
           <a class="code" href="class_gvnode.html#a59">Eval</a>(<a class="code" href="class_parameter.html">parameter</a>,n);
           n.<a class="code" href="class_point.html#a26">Normalize</a>();
           return(1);
        };

        // Evaluate a point &amp; normal at parameter(u,v)
        int <a class="code" href="class_gvnode.html#a59">Eval</a>(const <a class="code" href="class_point.html">Point</a> &amp;<a class="code" href="class_parameter.html">parameter</a>,<a class="code" href="class_point.html">Point</a> &amp;p,<a class="code" href="class_point.html">Point</a> &amp;n)
        {
           float u = (<a class="code" href="class_parameter.html">parameter</a>.x+0.25) * TWOPI;
           float v = (<a class="code" href="class_parameter.html">parameter</a>.y-0.0 ) * PI;
           n.<a class="code" href="class_point.html#a6">Set</a>(cos(u)*sin(v),sin(u)*sin(v),cos(v));
           p = n * r;
           return(1);
        }

        
        int <a class="code" href="class_gsurface.html#a3">Map</a>(const <a class="code" href="class_point.html">Point</a> &amp;p,<a class="code" href="class_point.html">Point</a> &amp;<a class="code" href="class_parameter.html">parameter</a>); 
        int <a class="code" href="class_gsurface.html#a4">Intersect</a>(const <a class="code" href="class_ray.html">Ray</a> &amp;ray,float &amp;t); 


}; // Sphere Surface


// cylinder surface
class <a class="code" href="class_gcylindersurface.html">GCylinderSurface</a> : public <a class="code" href="class_gsurface.html">GSurface</a> {
   <a class="code" href="class_gcurve.html#c0">GV_NODE_HEADER</a>(<a class="code" href="class_gcylindersurface.html">GCylinderSurface</a>);
public:

public:
        <a class="code" href="class_gvsffloat.html">GvSFFloat</a> r;    // default : 1.0
        <a class="code" href="class_gvsffloat.html">GvSFFloat</a> h;    // default : 2.0
        

        int <a class="code" href="class_gsurface.html#a6">ClosedInU</a>() { return(1); };

        int <a class="code" href="class_gvnode.html#a59">Eval</a>(const <a class="code" href="class_point.html">Point</a> &amp;<a class="code" href="class_parameter.html">parameter</a>,<a class="code" href="class_point.html">Point</a> &amp;p) 
        {
           float u = (<a class="code" href="class_parameter.html">parameter</a>.x+0.25) * TWOPI;
           float v = (<a class="code" href="class_parameter.html">parameter</a>.y-0.5) * h;
           p.<a class="code" href="class_point.html#a6">Set</a>(r*cos(u),r*sin(u),v);
           return(1);
        };
        
        int <a class="code" href="class_gcurve.html#a2">EvalNormal</a>(const <a class="code" href="class_point.html">Point</a> &amp;<a class="code" href="class_parameter.html">parameter</a>,<a class="code" href="class_point.html">Point</a> &amp;n) {
           float u = (<a class="code" href="class_parameter.html">parameter</a>.x+0.25) * TWOPI;
           n.<a class="code" href="class_point.html#a6">Set</a>(cos(u),sin(u),0);
           return(1);
        };


        int <a class="code" href="class_gvnode.html#a59">Eval</a>(const <a class="code" href="class_point.html">Point</a> &amp;<a class="code" href="class_parameter.html">parameter</a>,<a class="code" href="class_point.html">Point</a> &amp;p,<a class="code" href="class_point.html">Point</a> &amp;n) {
           float u = (<a class="code" href="class_parameter.html">parameter</a>.x+0.25) * TWOPI;
           float v = (<a class="code" href="class_parameter.html">parameter</a>.y-0.5) * h;
           n.<a class="code" href="class_point.html#a6">Set</a>(cos(u),sin(u),0);
           p.<a class="code" href="class_point.html#a6">Set</a>(r*n.x,r*n.y,v);
           return(1);
        }

    int <a class="code" href="class_gsurface.html#a3">Map</a>(const <a class="code" href="class_point.html">Point</a> &amp;p,<a class="code" href="class_point.html">Point</a> &amp;<a class="code" href="class_parameter.html">parameter</a>);
        int <a class="code" href="class_gsurface.html#a4">Intersect</a>(const <a class="code" href="class_ray.html">Ray</a> &amp;ray,float &amp;t);


};


// Simple xy-plane surface, 
class <a class="code" href="class_gxyplanesurface.html">GXYPlaneSurface</a> : public <a class="code" href="class_gsurface.html">GSurface</a> {
   <a class="code" href="class_gcurve.html#c0">GV_NODE_HEADER</a>(<a class="code" href="class_gxyplanesurface.html">GXYPlaneSurface</a>);
public:

        <a class="code" href="class_gvsfvec2f.html">GvSFVec2f</a> scale;

public:

        int <a class="code" href="class_gvnode.html#a59">Eval</a>(const <a class="code" href="class_point.html">Point</a> &amp;<a class="code" href="class_parameter.html">parameter</a>,<a class="code" href="class_point.html">Point</a> &amp;p) 
        {
           p.<a class="code" href="class_point.html#a6">Set</a>(scale[0]*parameter.x,scale[1]*parameter.y,0);
           return(1);
        };
        
        int <a class="code" href="class_gcurve.html#a2">EvalNormal</a>(const <a class="code" href="class_point.html">Point</a> &amp;<a class="code" href="class_parameter.html">parameter</a>,<a class="code" href="class_point.html">Point</a> &amp;n) {
           n.<a class="code" href="class_point.html#a6">Set</a>(0.0,0.0,1.0);
           return(1);
        };

        int <a class="code" href="class_gvnode.html#a59">Eval</a>(const <a class="code" href="class_point.html">Point</a> &amp;<a class="code" href="class_parameter.html">parameter</a>,<a class="code" href="class_point.html">Point</a> &amp;p,<a class="code" href="class_point.html">Point</a> &amp;n)
        {
           p.<a class="code" href="class_point.html#a6">Set</a>(scale[0]*parameter.x,scale[1]*parameter.y,0);
           n.<a class="code" href="class_point.html#a6">Set</a>(0.0,0.0,1.0);
           return(1);
        }


    int <a class="code" href="class_gsurface.html#a3">Map</a>(const <a class="code" href="class_point.html">Point</a> &amp;p,<a class="code" href="class_point.html">Point</a> &amp;<a class="code" href="class_parameter.html">parameter</a>) { <a class="code" href="class_parameter.html">parameter</a>.<a class="code" href="class_point.html#a6">Set</a>(p.x/scale[0],p.y/scale[1],0.0); return(1); }

        int <a class="code" href="class_gsurface.html#a4">Intersect</a>(const <a class="code" href="class_ray.html">Ray</a> &amp;ray,float &amp;t);

};


class <a class="code" href="class_gtorussurface.html">GTorusSurface</a> : public <a class="code" href="class_gsurface.html">GSurface</a> {
   <a class="code" href="class_gcurve.html#c0">GV_NODE_HEADER</a>(<a class="code" href="class_gtorussurface.html">GTorusSurface</a>);
public:

        <a class="code" href="class_gvsffloat.html">GvSFFloat</a> rMajor;
        <a class="code" href="class_gvsffloat.html">GvSFFloat</a> rMinor;
        
//      GTorusSurface(float RMajor=1.0,float RMinor=0.25) : rMajor(RMajor),rMinor(RMinor) {};
        int <a class="code" href="class_gsurface.html#a6">ClosedInU</a>() { return(1); };
        int <a class="code" href="class_gsurface.html#a7">ClosedInV</a>() { return(1); };

};

//
//  a point evaluated on a surface 
// 


class <a class="code" href="class_gpointonsurface.html">GPointOnSurface</a> : public <a class="code" href="class_gvnode.html">GvNode</a>
{
   <a class="code" href="class_gcurve.html#c0">GV_NODE_HEADER</a>(<a class="code" href="class_gpointonsurface.html">GPointOnSurface</a>);
public:
        // fields
        <a class="code" href="class_gvsfnode.html">GvSFNode</a>        surface; // the surface

        // EventIn
        <a class="code" href="class_gvsfvec2f.html">GvSFVec2f</a>       <a class="code" href="class_parameter.html">parameter</a>;      // parameter to evaluate surface

        // EventOut
        <a class="code" href="class_gvsfvec3f.html">GvSFVec3f</a>       value;          // evaluated point on surface

};

//
//  a curve evaluated on a surface 
// 

class <a class="code" href="class_gcurveonsurface.html">GCurveOnSurface</a> : public <a class="code" href="class_gcurve.html">GCurve</a>
{
   <a class="code" href="class_gcurve.html#c0">GV_NODE_HEADER</a>(<a class="code" href="class_gcurveonsurface.html">GCurveOnSurface</a>);
public:
        // fields
        <a class="code" href="class_gvsfnode.html">GvSFNode</a>        surface; // the surface

        <a class="code" href="class_gvsfnode.html">GvSFNode</a>        parameterCurve; // curve in parameter space 


};


class <a class="code" href="class_gcurvedisplay.html">GCurveDisplay</a> : public <a class="code" href="class_gvnodeshell.html">GvNodeShell</a>
{
   <a class="code" href="class_gcurve.html#c0">GV_NODE_HEADER</a>(<a class="code" href="class_gcurvedisplay.html">GCurveDisplay</a>);
public:
        // fields
        <a class="code" href="class_gvsfvec2f.html">GvSFVec2f</a>       range;  // the range to display (default 0,1)
        <a class="code" href="class_gvsffloat.html">GvSFFloat</a>       parameterStep;  //  parameter stepping value  (default 0.1)
        <a class="code" href="class_gvsfnode.html">GvSFNode</a>        curve; // the curve

        int     <a class="code" href="class_gvnodeshell.html#a13">BuildShell</a>(<a class="code" href="class_gtraversal.html">GTraversal</a> &amp;state);

};

class <a class="code" href="class_gsurfacedisplay.html">GSurfaceDisplay</a> : public <a class="code" href="class_gvnodeshell.html">GvNodeShell</a>
{
   <a class="code" href="class_gcurve.html#c0">GV_NODE_HEADER</a>(<a class="code" href="class_gsurfacedisplay.html">GSurfaceDisplay</a>);
public:

        // fields
        <a class="code" href="class_gvsfvec2f.html">GvSFVec2f</a>       urange; // the u range to display (default 0,1)
        <a class="code" href="class_gvsfvec2f.html">GvSFVec2f</a>       vrange; // the v range to display (default 0,1)
        <a class="code" href="class_gvsfvec2f.html">GvSFVec2f</a>       parameterStep;  //  parameter stepping value 
        <a class="code" href="class_gvsfnode.html">GvSFNode</a>        surface; // the surface

        int     <a class="code" href="class_gvnodeshell.html#a13">BuildShell</a>(<a class="code" href="class_gtraversal.html">GTraversal</a> &amp;state);

};


#endif
</div></pre><hr><address><small>Generated at Thu Jan 27 18:45:42 2000 for blaxxunContact3D by
<a href="http://www.stack.nl/~dimitri/doxygen/index.html">
<img src="doxygen.gif" alt="doxygen" align=center border=0 
width=118 height=53></a> 1.0.0 written by <a href="mailto:dimitri@stack.nl">Dimitri van Heesch</a>,
 &copy; 1997-1999</small></address>
</body>
</html>

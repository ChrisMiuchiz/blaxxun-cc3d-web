<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta name="robots" content="noindex">
<title>gugr::Dump Include File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body bgcolor="#ffffff">
<!-- Generated by Doxygen 1.0.0 on Thu Jan 27 18:54:53 2000 -->
<center>
<a class="qindex"href="index.html">Main Page</a> &nbsp; <a class="qindex"href="namespaces.html">Namespace List</a> &nbsp; <a class="qindex"href="hierarchy.html">Class Hierarchy</a> &nbsp; <a class="qindex"href="annotated.html">Compound List</a> &nbsp; <a class="qindex"href="files.html">File List</a> &nbsp; <a class="qindex"href="headers.html">Header Files</a> &nbsp; <a class="qindex"href="namespacemembers.html">Namespace Members</a> &nbsp; <a class="qindex"href="functions.html">Compound Members</a> &nbsp; <a class="qindex"href="globals.html">File Members</a> &nbsp; </center>
<hr><h1>gugr_io.h</h1>This is the verbatim text of the gugr_io.h include file.<div class="fragment"><pre>/* 
 * This code is licensed under the Web3D-blaxxun Community Source License, 
 * provided in distribution file LICENSE.TXT and available online at 
 * http://www.web3D.org/TaskGroups/x3d/blaxxun/Web3D-blaxxunCommunitySourceAgreement.html 
 * and may only be used for non-commercial use as specified in that license. 
 * 
 * THE WEB3D CONSORTIUM AND BLAXXUN DO NOT MAKE AND HEREBY DISCLAIM ANY EXPRESS 
 * OR IMPLIED WARRANTIES RELATING TO THIS CODE, INCLUDING BUT NOT LIMITED TO, 
 * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY OR FITNESS FOR A PARTICULAR 
 * PURPOSE, OR ANY WARRANTIES THAT MIGHT ARISE FROM A COURSE OF DEALING, USAGE 
 * OR TRADE PRACTICE.  THE COMMUNITY SOURCE CODE IS PROVIDED UNDER THIS 
 * AGREEMENT "AS IS," WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, 
 * INCLUDING, WITHOUT LIMITATION, WARRANTIES THAT THE COMMUNITY SOURCE CODE ARE 
 * FREE OF DEFECTS, MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE OR 
 * NON-INFRINGING OR IN ANY WAY CONSTITUTE THE COMPLETE PRODUCT MARKETED UNDER 
 * THE NAMES GIVEN SAID CODE. 
 */ 

/* LIBGUL - Geometry Utility Library
 * Copyright (c) 1999 by Norbert Irmer and Blaxxun Interactive 
 * All rights reserved 
 */ 
 
#ifndef GUGR_IO_H
#define GUGR_IO_H

#include &lt;iostream.h&gt;
#include &lt;iomanip.h&gt;

namespace gugr {

using gul::Assert;
using <a class="code" href="class_gul__ptr.html">gul::Ptr</a>;
using <a class="code" href="class_gul__rtr.html">gul::rtr</a>;
using guar::uint64;
using <a class="code" href="class_gul__point2.html">gul::point2</a>;
using <a class="code" href="class_gul__line2.html">gul::line2</a>;
using <a class="code" href="class_gul__polyline2.html">gul::polyline2</a>;
using <a class="code" href="class_gul__triangle2.html">gul::triangle2</a>;


template&lt; class T &gt;
inline int coord2int( const T&amp; f, unsigned long *<a class="code" href="class_buf.html">buf</a> );

template&lt;&gt;
inline int coord2int&lt;double&gt;( const double&amp; f, unsigned long *<a class="code" href="class_buf.html">buf</a> )
{
  uint64 i;
  unsigned long hi,lo;
  
  gul::Assert&lt;<a class="code" href="class_gul__internalerror.html">gul::InternalError</a>&gt;( ndebug | (1.0 &lt;= f &amp;&amp; f &lt;= 2.0) );
  i = (uint64)(f*<a class="code" href="class_gul__rtr.html">gul::rtr</a>&lt;double&gt;::epsilon_inv());
  i -= (uint64)<a class="code" href="class_gul__rtr.html">gul::rtr</a>&lt;double&gt;::epsilon_inv();
  hi = (i &gt;&gt; 32) &amp; <a class="code" href="guar_exact.h.html#a0">LL</a>(0xffffffff);
  lo = i &amp; <a class="code" href="guar_exact.h.html#a0">LL</a>(0xffffffff); 
  if( !hi )
  {
    if( !lo ) return 0;
    <a class="code" href="class_buf.html">buf</a>[0] = lo;
    return 1;
  }
  <a class="code" href="class_buf.html">buf</a>[0] = lo;
  <a class="code" href="class_buf.html">buf</a>[1] = hi;
  return 2; 
}

template&lt;&gt;
inline int coord2int&lt;float&gt;( const float&amp; f, unsigned long *<a class="code" href="class_buf.html">buf</a> )
{
  unsigned long i;
  
  gul::Assert&lt;InternalError&gt;( ndebug | (1.0f &lt;= f &amp;&amp; f &lt;= 2.0f) );
  i = (unsigned long)(f * <a class="code" href="class_gul__rtr.html">gul::rtr</a>&lt;float&gt;::epsilon_inv());
  i -= (unsigned long)<a class="code" href="class_gul__rtr.html">gul::rtr</a>&lt;float&gt;::epsilon_inv();
  if( !i ) return 0;
  <a class="code" href="class_buf.html">buf</a>[0] = i;
  return 1;
}


template&lt; class T &gt;
T cnv2coord( const T&amp; i )
{
  return i * <a class="code" href="class_gul__rtr.html">gul::rtr</a>&lt;T&gt;::epsilon() + (T)1.0;
}


/*-------------------------------------------------------------------------
  Converts simple polygon to a DCEL (doubly connected edge list, winged edge
  list)
--------------------------------------------------------------------------*/
template&lt; class T &gt;
void PolygonToGraph( 
      const int n, Ptr&lt; point2&lt;T&gt; &gt; P,
      const T orgx, const T orgy,
      const T scalex, const T scaley,
      int fleft, int fright,
      graph_edge_list *E, graph_vertex_list *V );


/*------------------------------------------------------------------------
  output functions for debugging
------------------------------------------------------------------------*/
template&lt; class T &gt;
class Dump
{
public:
  static T orgx,orgy,scalex,scaley; 
public:
  static void set_transformation( T aorgx, T aorgy, T ascalex, T ascaley )
  {
    orgx = aorgx; 
    orgy = aorgy;
    scalex = ascalex;
    scaley = ascaley;
  }
  static void dump_vertice( graph_vertex *v )
  {
    double dx1,dy1;
    T x1,y1;
  
    if( v != NULL )
    {
      v-&gt;v.v().m_x.Dump(dx1);
      v-&gt;v.v().m_y.Dump(dy1);
      x1 = (T)dx1;
      y1 = (T)dy1; 

      x1 = cnv2coord&lt;T&gt;(x1)*scalex + orgx; 
      y1 = cnv2coord&lt;T&gt;(y1)*scaley + orgy;  
      std::cout &lt;&lt; (void *)v &lt;&lt; ": (" &lt;&lt;
                std::setprecision(8) &lt;&lt; x1 &lt;&lt; ", " &lt;&lt; y1 &lt;&lt; 
                "), " &lt;&lt; (void *)v-&gt;e &lt;&lt; "\n";
    }
    std::cout.flush();
  }
  static void dump_vertices( graph_vertex *V )
  {
    graph_vertex *v;
    double dx1,dy1;
    T x1,y1;
  
    v = V;
    std::cout &lt;&lt; "VERTICES\n";
    while( v != NULL )
    {
      v-&gt;v.v().m_x.Dump(dx1);
      v-&gt;v.v().m_y.Dump(dy1);
      x1 = (T)dx1;
      y1 = (T)dy1; 

      x1 = cnv2coord&lt;T&gt;(x1)*scalex + orgx; 
      y1 = cnv2coord&lt;T&gt;(y1)*scaley + orgy;  
      std::cout &lt;&lt; (void *)v &lt;&lt; ": (" &lt;&lt;
                std::setprecision(8) &lt;&lt; x1 &lt;&lt; ", " &lt;&lt; y1 &lt;&lt; 
                "), " &lt;&lt; (void *)v-&gt;e &lt;&lt; "\n";
      v = v-&gt;next;
    }
    std::cout.flush();
  }
  static void dump_edges( graph_edge *E )
  {
    graph_edge *e;
    double dx1,dx2,dy1,dy2;
    T x1,x2,y1,y2;
    
    e = E;
    std::cout &lt;&lt; "EDGES\n";    
    while( e != NULL )
    {
      e-&gt;v[0]-&gt;v.v().m_x.Dump(dx1);
      e-&gt;v[0]-&gt;v.v().m_y.Dump(dy1);
      e-&gt;v[1]-&gt;v.v().m_x.Dump(dx2);
      e-&gt;v[1]-&gt;v.v().m_y.Dump(dy2);

      x1 = (T)dx1; x2 = (T)dx2; y1 = (T)dy1; y2 = (T)dy2;
      
      x1 = cnv2coord&lt;T&gt;(x1)*scalex + orgx; 
      x2 = cnv2coord&lt;T&gt;(x2)*scalex + orgx; 
      y1 = cnv2coord&lt;T&gt;(y1)*scaley + orgy; 
      y2 = cnv2coord&lt;T&gt;(y2)*scaley + orgy; 

      std::cout &lt;&lt; (void *)e &lt;&lt; ": [" &lt;&lt; e-&gt;f[0] &lt;&lt; "," &lt;&lt; e-&gt;f[1] &lt;&lt; "] [" &lt;&lt;
                (void *)e-&gt;v[0] &lt;&lt; "=(" &lt;&lt; std::setprecision(8) &lt;&lt;
                x1 &lt;&lt; ", " &lt;&lt; y1 &lt;&lt; "), " &lt;&lt; (void *)e-&gt;e[0] &lt;&lt;
                "]  [" &lt;&lt; (void *)e-&gt;v[1] &lt;&lt; "=(" &lt;&lt;
                x2 &lt;&lt; ", " &lt;&lt; y2 &lt;&lt; "), " &lt;&lt; (void *)e-&gt;e[1];
      if( e-&gt;l.IsNULL() )
        std::cout &lt;&lt; "]\n";
      else
      {
        e-&gt;l.v().m_x.Dump(dx1);
        e-&gt;l.v().m_y.Dump(dy1);
        x1 = (T)dx1; y1 = (T)dy1;
        x1 = cnv2coord&lt;T&gt;(x1)*scalex + orgx; 
        y1 = cnv2coord&lt;T&gt;(y1)*scaley + orgy; 
 
        e-&gt;l.dx().Dump(dx2);
        e-&gt;l.dy().Dump(dy2);
        x2 = (T)dx2; y2 = (T)dy2;

        std::cout &lt;&lt; "]  L: (" &lt;&lt; x1 &lt;&lt; ", " &lt;&lt; y1 &lt;&lt; "), dx=" &lt;&lt;
                  x2 &lt;&lt; ", dy=" &lt;&lt; y2 &lt;&lt; "\n";
      }
      e = e-&gt;next;
    }
    std::cout.flush();
  }
};

EXP
extern void (*DrawMarkFunc) ( point2&lt;double&gt; P1, point2&lt;double&gt; P2, 
                       point2&lt;double&gt; P3 );
EXP
extern void (*DrawLineFunc) ( point2&lt;double&gt; P1, point2&lt;double&gt; P2 );

void SetDumpTransformation( double aorgx, double aorgy, 
                       double ascalex, double ascaley );
void DumpVertices( graph_vertex *V );
void DumpEdges( graph_edge *E );
void DrawEdges( graph_edge *E );
void DrawTriangles( FILE *out, triangle_list *T, double orgx, double orgy, 
                    double scalex, double scaley );
/*-----------------------------------------------------------------------
  Convert Triangles to array with double points
------------------------------------------------------------------------*/
void ConvertTriangles( triangle_list *TL, 
                       double orgx, double orgy, 
                       double scalex, double scaley,
                       int *nTA, Ptr&lt; triangle2&lt;double&gt; &gt; *TA  );
/*-----------------------------------------------------------------------
  Convert list of Edges to array of line segments (with double coordinates)
  (for debugging)
------------------------------------------------------------------------*/
void ConvertEdges( graph_edge_list *E, 
                   double orgx, double orgy, 
                   double scalex, double scaley,
                   int *nLA, Ptr&lt; line2&lt;double&gt; &gt; *LA  );

}

#endif
</div></pre><hr><address><small>Generated at Thu Jan 27 18:54:54 2000 for blaxxunContact3D by
<a href="http://www.stack.nl/~dimitri/doxygen/index.html">
<img src="doxygen.gif" alt="doxygen" align=center border=0 
width=118 height=53></a> 1.0.0 written by <a href="mailto:dimitri@stack.nl">Dimitri van Heesch</a>,
 &copy; 1997-1999</small></address>
</body>
</html>

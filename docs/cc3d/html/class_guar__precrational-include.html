<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta name="robots" content="noindex">
<title>guar::PrecRational Include File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body bgcolor="#ffffff">
<!-- Generated by Doxygen 1.0.0 on Thu Jan 27 18:54:51 2000 -->
<center>
<a class="qindex"href="index.html">Main Page</a> &nbsp; <a class="qindex"href="namespaces.html">Namespace List</a> &nbsp; <a class="qindex"href="hierarchy.html">Class Hierarchy</a> &nbsp; <a class="qindex"href="annotated.html">Compound List</a> &nbsp; <a class="qindex"href="files.html">File List</a> &nbsp; <a class="qindex"href="headers.html">Header Files</a> &nbsp; <a class="qindex"href="namespacemembers.html">Namespace Members</a> &nbsp; <a class="qindex"href="functions.html">Compound Members</a> &nbsp; <a class="qindex"href="globals.html">File Members</a> &nbsp; </center>
<hr><h1>guar_exact.h</h1>This is the verbatim text of the guar_exact.h include file.<div class="fragment"><pre>/* 
 * This code is licensed under the Web3D-blaxxun Community Source License, 
 * provided in distribution file LICENSE.TXT and available online at 
 * http://www.web3D.org/TaskGroups/x3d/blaxxun/Web3D-blaxxunCommunitySourceAgreement.html 
 * and may only be used for non-commercial use as specified in that license. 
 * 
 * THE WEB3D CONSORTIUM AND BLAXXUN DO NOT MAKE AND HEREBY DISCLAIM ANY EXPRESS 
 * OR IMPLIED WARRANTIES RELATING TO THIS CODE, INCLUDING BUT NOT LIMITED TO, 
 * WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY OR FITNESS FOR A PARTICULAR 
 * PURPOSE, OR ANY WARRANTIES THAT MIGHT ARISE FROM A COURSE OF DEALING, USAGE 
 * OR TRADE PRACTICE.  THE COMMUNITY SOURCE CODE IS PROVIDED UNDER THIS 
 * AGREEMENT "AS IS," WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, 
 * INCLUDING, WITHOUT LIMITATION, WARRANTIES THAT THE COMMUNITY SOURCE CODE ARE 
 * FREE OF DEFECTS, MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE OR 
 * NON-INFRINGING OR IN ANY WAY CONSTITUTE THE COMPLETE PRODUCT MARKETED UNDER 
 * THE NAMES GIVEN SAID CODE. 
 */ 

/* LIBGUL - Geometry Utility Library
 * Copyright (c) 1999 by Norbert Irmer and Blaxxun Interactive 
 * All rights reserved 
 */ 

#ifndef GUAR_EXACT_H
#define GUAR_EXACT_H

#include &lt;math.h&gt;
// #include &lt;new.h&gt;

namespace guar {

// using namespace gust;
// using gust::PoolAlloc;
// using gust::PoolFree;
// using gul::Error;
// using gul::PoolAllocError;
// using gul::IntervalDivZeroError;

#ifdef _MSC_VER
  typedef unsigned _int64 uint64;
  #define isinf(f) (!_finite((f)))
  // 64-Bit Integer constants
  #define LL(i) i##i64
#else
  typedef unsigned long long uint64;
  // 64-Bit Integer constants
  #define LL(i) i##LL
#endif

/* ---------------------------------------------------------
  Converts int-string to double
----------------------------------------------------------- */

template&lt; class T &gt;
void IntTo( const int na, const unsigned long *<a class="code" href="class_a.html">a</a>, T&amp; t )
{
  int i;

  if( na == 0 )
  {
    t = (T)0.0;
    return;
  }
  t = (T)<a class="code" href="class_a.html">a</a>[na-1];
  
  for( i = na-2; i &gt;= 0; i-- )
  {
    t = t*(T)(<a class="code" href="guar_exact.h.html#a0">LL</a>(0x100000000)) + (T)<a class="code" href="class_a.html">a</a>[i];
  }  
}

/* ----------------------------------------------------------------
  Calculates the sum of two operands
------------------------------------------------------------------ */
void IntAdd( const int na, const unsigned long *<a class="code" href="class_a.html">a</a>, 
             const int nb, const unsigned long *b, 
             int *nc, unsigned long *c );

/* ---------------------------------------------------------------
  Calculates c=a-b with length of c = max(length(a),length(b)).
  If a &lt; b the result c is a negative number (two-complement, i.e.
  not(fabs(c))+1), and the fuction returns -1, else it returns 0.
------------------------------------------------------------------ */
int IntSub( const int na, const unsigned long *<a class="code" href="class_a.html">a</a>, 
            const int nb, const unsigned long *b, 
            int *nc, unsigned long *c );
                 
/* ---------------------------------------------------------------
  Short Multiplication
---------------------------------------------------------------- */
unsigned long IntMultShort( 
         const int na, const unsigned long *<a class="code" href="class_a.html">a</a>, const unsigned long b,
         unsigned long *c );
         
/* ----------------------------------------------------------------
  Calculates the product of two operands, slow but simple
  TODO: Multiplication with FFT
------------------------------------------------------------------ */
void IntMult( const int na, const unsigned long *<a class="code" href="class_a.html">a</a>, 
              const int nb, const unsigned long *b,
              int *nc, unsigned long *c );

/* ---------------------------------------------------------
  Divide a int-string by a single int
----------------------------------------------------------- */
unsigned long IntDivShort( 
       const int na, const unsigned long *<a class="code" href="class_a.html">a</a>, const unsigned long b, 
       int *nq, unsigned long *q );

/* ---------------------------------------------------------
  Divide a int-string by a int-string
----------------------------------------------------------- */
int IntDiv( const int na, const unsigned long *<a class="code" href="class_a.html">a</a>, 
            const int nb, const unsigned long *b, 
            int *nq, unsigned long *q, 
            int *nr, unsigned long *r );



/* ---------------------------------------------------------
  Converts double to int-string
----------------------------------------------------------- */
int DoubleToInt( const double d, const int na, unsigned long *<a class="code" href="class_a.html">a</a>,
                 int *retLen );

/* ---------------------------------------------------------
  Converts int-string to double
----------------------------------------------------------- */
double IntToDouble( const int na, const unsigned long *<a class="code" href="class_a.html">a</a> );



struct Interval
{
  friend Interval operator+( const Interval &amp;<a class="code" href="class_a.html">a</a>, const Interval &amp;b );
  friend Interval operator-( const Interval &amp;<a class="code" href="class_a.html">a</a>, const Interval &amp;b );
  friend Interval operator*( const Interval &amp;<a class="code" href="class_a.html">a</a>, const Interval &amp;b );
  friend Interval operator/( const Interval &amp;<a class="code" href="class_a.html">a</a>, const Interval &amp;b );
  friend int Test( const Interval &amp;<a class="code" href="class_a.html">a</a>, const Interval &amp;b );

  double         m_low;
  double         m_high;

  Interval() { m_low = 0.0; m_high = 0.0; }
  Interval(double val) { m_low = val; m_high = val; }
  Interval(double low, double high) { m_low = low; m_high = high; }
};

/* -------------------------------------------------------------
  wrapper class, because i don't want implicit double -&gt; long
  conversion
---------------------------------------------------------------*/
class ULong
{
  unsigned long l;
public:
  explicit ULong( unsigned long ul ) : l(ul) { }
  operator unsigned long() const { return l; }
};

class PrecRational
{
public:
  friend PrecRational operator*( const PrecRational&amp; <a class="code" href="class_a.html">a</a>, const PrecRational&amp; b );
  friend PrecRational operator+( const PrecRational&amp; A, const PrecRational&amp; B );
  friend PrecRational operator/( const PrecRational&amp; A, const PrecRational&amp; B );
  friend PrecRational operator-( const PrecRational&amp; A, const PrecRational&amp; B );
  friend int Compare( const PrecRational&amp; A, const PrecRational &amp;B );

  struct PrecRationalRep
  {
    int            m_na;  /* number of words for a */
    unsigned long *m_a;   /* numerator   */

    int            m_nb;  /* number of words for b */
    unsigned long *m_b;   /* denominator */

    size_t         m_size_a;  /* allocation size in byte of a */ 
    size_t         m_size_b;  /* allocation size of byte of b */ 

    int            m_refcount;    /* Referencecounter */ 

    Interval       m_i;

    int            m_sign   : 2;  /* -1 = negative, 0 = positive or zero */
    unsigned int   m_bounds : 1;  /* lower and upper bound initialized */

    PrecRationalRep()
    {
      m_refcount = 1;
      m_sign = m_bounds = m_na = m_nb = m_size_a = m_size_b = 0;
      m_a = m_b = NULL;
    }

/*
    PrecRationalRep( const double f ) : m_i(f)
    {
      unsigned long *a;
      int sign,len;
      size_t bsize;
         
      m_refcount = 1;
      m_sign = m_bounds = m_na = m_nb = m_size_a = m_size_b = 0; 
      m_a = m_b = NULL;

      if( f == 0.0 ) {m_bounds=1; return; }
      
      a = (unsigned long *)PoolAlloc( 128*sizeof(unsigned long), &amp;bsize );
      if( a == NULL ) throw PoolAllocError();

      sign = DoubleToInt( f, 128, a, &amp;len );
      if( len == 0 ) {PoolFree(a,128*sizeof(unsigned long)); return;}

      m_a = (unsigned long *)PoolAlloc( len*sizeof(unsigned long), &amp;bsize );
      if( m_a == NULL ) throw PoolAllocError();
      memcpy( m_a, a, len*sizeof(unsigned long) );

      PoolFree(a,128*sizeof(unsigned long)); 
  
      m_sign = sign;
      m_i.m_low = f; m_i.m_high = f; m_bounds = 1;
      m_na = len;
      m_size_a = bsize;
    }
*/

    PrecRationalRep( int sign, int na, unsigned long *<a class="code" href="class_a.html">a</a> )
    {
      size_t bsize;

      m_refcount = 1;
      m_sign = m_bounds = m_na = m_nb = m_size_b = m_size_a = 0; 
      m_a = m_b = 0;

      if( na == 0 ) return;
      
      m_a = (unsigned long *)gust::PoolAlloc( na*sizeof(unsigned long), &amp;bsize );
      if( m_a == NULL ) throw gul::PoolAllocError();
      for( int i=0; i&lt;na; i++ ) m_a[i] = <a class="code" href="class_a.html">a</a>[i];

      m_sign = sign;
      m_na = na;
      m_size_a = bsize;
    }
    
    PrecRationalRep( int sign, unsigned long <a class="code" href="class_a.html">a</a> )
    {
      size_t bsize;

      m_a = (unsigned long *)gust::PoolAlloc( sizeof(unsigned long), &amp;bsize );
      if( m_a == NULL ) throw gul::PoolAllocError();
      m_a[0] = <a class="code" href="class_a.html">a</a>;

      m_refcount = 1;
      m_bounds = m_nb = m_size_b = 0; 
      m_b = 0;

      m_sign = sign;
      m_na = 1;
      m_size_a = bsize;
    }
 
            // this only reserves memory, but leaves it uninitialized
    PrecRationalRep( int sign, int na, int nb )
    {
      size_t bsize;

      m_refcount = 1;
      m_sign = m_bounds = m_na = m_nb = m_size_a = m_size_b = 0; 
      m_a = m_b = NULL;

      if( na != 0 )       
      {
        m_sign = sign;
        m_a = (unsigned long *)gust::PoolAlloc( na*sizeof(unsigned long),&amp;bsize);
        if( m_a == NULL ) throw gul::PoolAllocError();
        m_size_a = bsize;
        m_na = na;
      }
      if( nb != 0 )       
      {     
        m_b = (unsigned long *)gust::PoolAlloc( nb*sizeof(unsigned long),&amp;bsize);
        if( m_b == NULL ) throw gul::PoolAllocError();
        m_size_b = bsize;
        m_nb = nb;
      }
    }

    ~PrecRationalRep()
    {
      if( (m_size_a != 0) &amp;&amp; (m_a != NULL) ) gust::PoolFree( m_a, m_size_a );      
      if( (m_size_b != 0) &amp;&amp; (m_b != NULL) ) gust::PoolFree( m_b, m_size_b );
    }

    template&lt; class T &gt;
    void dump( T&amp; num, T&amp; den )
    { 
      if( m_na == 0 )
      {  num = (T)0.0; den = (T)1.0; return; }
      else
        IntTo&lt;T&gt;( m_na, m_a, num );

      if( m_sign ) 
        num = -num;

      if( m_nb == 0 )
        den = (T)1.0;
      else
        IntTo&lt;T&gt;( m_nb, m_b, den );  
    }

    void calc_bounds( void )
    { 
      Interval inum,iden;
      double num,den;

      dump( num, den );
      if( num != 0.0 )
      {
        inum.m_low = num - DBL_EPSILON*fabs(num);
        inum.m_high = num + DBL_EPSILON*fabs(num);
      }
      else
      {
        inum.m_low = inum.m_high = 0.0;
      }
      
      if( den != 1.0 )
      {
        iden.m_low = den - DBL_EPSILON*fabs(den);
        iden.m_high = den + DBL_EPSILON*fabs(den);
      }
      else
      {
        iden.m_low = iden.m_high = 1.0;
      }

      m_i = inum/iden;

      m_bounds = 1;
    }
   
    void negative( void )    /* for internal use only, no checks !!!! */ 
    {      
      if( m_na != 0 )
        m_sign ^= -1;
    }
    
    void reciprocal( void )  /* for internal use only, no checks !!!! */
    {
      size_t bsize;
      unsigned long *p;
      int i;
      
      if( m_na == 0 ) throw gul::Error();
      
      if( (m_na == 1) &amp;&amp; (m_a[0] == 1) )
      {
        gust::PoolFree( m_a, m_size_a );
        m_na = 0;
        m_size_a = 0;
        m_a = NULL;
      }
      
      if( m_size_b == 0 )
      {
        m_b = (unsigned long *)gust::PoolAlloc( sizeof(unsigned long), &amp;bsize );
        if( m_b == NULL ) throw gul::PoolAllocError();
        m_nb = 1;
        m_b[0] = 1;
        m_size_b = bsize;
      }

      i = m_na; m_na = m_nb; m_nb = i;
      bsize = m_size_a; m_size_a = m_size_b; m_size_b = bsize;
      p = m_a; m_a = m_b; m_b = p;
    }
  };



public:
  PrecRationalRep   *m;
  
  PrecRational( void )
  {
    size_t bsize;
    void *<a class="code" href="class_buf.html">buf</a> = gust::PoolAlloc( sizeof(PrecRationalRep), &amp;bsize );
    if( <a class="code" href="class_buf.html">buf</a> == NULL ) throw gul::PoolAllocError();
    m = new(<a class="code" href="class_buf.html">buf</a>) PrecRationalRep;
  }
/*  
  PrecRational( const double f )
  {
    size_t bsize;
    void *buf = PoolAlloc( sizeof(PrecRationalRep), &amp;bsize );
    if( buf == NULL ) throw PoolAllocError();
    m = new(buf) PrecRationalRep(f);
  }
*/
  explicit PrecRational( int na, unsigned long *<a class="code" href="class_a.html">a</a>, int sign = 0 )
  {
    size_t bsize;
    void *<a class="code" href="class_buf.html">buf</a> = gust::PoolAlloc( sizeof(PrecRationalRep), &amp;bsize );
    if( <a class="code" href="class_buf.html">buf</a> == NULL ) throw gul::PoolAllocError();
    m = new(<a class="code" href="class_buf.html">buf</a>) PrecRationalRep(sign,na,<a class="code" href="class_a.html">a</a>);
  }

  explicit PrecRational( ULong <a class="code" href="class_a.html">a</a>, int sign = 0 )
  {
    size_t bsize;
    void *<a class="code" href="class_buf.html">buf</a> = gust::PoolAlloc( sizeof(PrecRationalRep), &amp;bsize );
    if( <a class="code" href="class_buf.html">buf</a> == NULL ) throw gul::PoolAllocError();
    m = new(<a class="code" href="class_buf.html">buf</a>) PrecRationalRep(sign,<a class="code" href="class_a.html">a</a>);
  }

  explicit PrecRational( int sign, int size_a, int size_b )
  {
    size_t bsize;
    void *<a class="code" href="class_buf.html">buf</a> = gust::PoolAlloc( sizeof(PrecRationalRep), &amp;bsize );
    if( <a class="code" href="class_buf.html">buf</a> == NULL ) throw gul::PoolAllocError();
    m = new(<a class="code" href="class_buf.html">buf</a>) PrecRationalRep( sign, size_a, size_b );
  }

  PrecRational( const PrecRational&amp; other )
  {
    other.m-&gt;m_refcount++;
    m = other.m;
  }

  PrecRational&amp; operator=( const PrecRational&amp; other )
  {
    other.m-&gt;m_refcount++;

    if( --m-&gt;m_refcount == 0 ) 
    {
      m-&gt;~PrecRationalRep();
      gust::PoolFree( m, sizeof(PrecRationalRep) );      
    }

    m = other.m;

    return( *this );    
  } 

  ~PrecRational() 
  {
    if( --m-&gt;m_refcount == 0 ) 
    {
      m-&gt;~PrecRationalRep();
      gust::PoolFree( m, sizeof(PrecRationalRep) );      
    }
  }

  PrecRational GetCopy() const
  {
    PrecRational C(m-&gt;m_sign,m-&gt;m_na,m-&gt;m_nb);
    int i;
    
    if( m-&gt;m_na )
      for( i = 0; i &lt; m-&gt;m_na; i++ )
        C.m-&gt;m_a[i] = m-&gt;m_a[i];
    if( m-&gt;m_nb )
      for( i = 0; i &lt; m-&gt;m_nb; i++ )
        C.m-&gt;m_b[i] = m-&gt;m_b[i];
    return C;
  }

  operator int() const
  {
    int i;
    
    if( (m-&gt;m_na != 0) &amp;&amp; (m-&gt;m_nb != 0) )
    {
      PrecRational Q,R;
  
      DivMod( &amp;Q, &amp;R );

      if( Q.m-&gt;m_na )
      {
        i = Q.m-&gt;m_a[0] &amp; 0xefffffff;
        if( Q.m-&gt;m_sign ) i = -i;
      }
      else
        i = 0;
    }
    else
    {
      if( m-&gt;m_na )  
      {
        i = m-&gt;m_a[0] &amp; 0xefffffff;
        if( m-&gt;m_sign ) i = -i;
      }
      else
        i = 0;
    }

    return(i);
  }

  void CalcBounds( void ) const { m-&gt;calc_bounds(); } 
  
  inline const Interval&amp; GetBounds( void ) const
  {
    if( !m-&gt;m_bounds ) m-&gt;calc_bounds();
    return(m-&gt;m_i);
  }
  
  template&lt; class T &gt;
  void Dump( T&amp; num, T&amp; den ) const { m-&gt;dump( num, den ); }

  template&lt; class T &gt;
  void Dump( T&amp; t ) const 
  {
    T n,d;
    
    Dump(n,d);
    
    t = n/d;
  } 

  bool IsZero( void ) const { return(m-&gt;m_na == 0); }

  int  Test( void ) const
  {
    if( m-&gt;m_sign ) return(-1);
    else if( m-&gt;m_na == 0 ) return(0);
    return(1);
  }

  void DivMod( PrecRational *q, PrecRational *r ) const;
};

/* ---------------------------------------------------------------
  functions for intervall arithmetic
--------------------------------------------------------------- */

inline Interval operator+( const Interval &amp;<a class="code" href="class_a.html">a</a>, const Interval &amp;b )
{
  Interval c;
  
  c.m_low = <a class="code" href="class_a.html">a</a>.m_low + b.m_low;
  if( !isinf(c.m_low) ) c.m_low = c.m_low - DBL_EPSILON*fabs(c.m_low);

  c.m_high = <a class="code" href="class_a.html">a</a>.m_high + b.m_high;
  if( !isinf(c.m_high) ) c.m_high = c.m_high + DBL_EPSILON*fabs(c.m_high);
    
  return( c );
}

inline Interval operator-( const Interval &amp;<a class="code" href="class_a.html">a</a>, const Interval &amp;b )
{
  Interval c(-b.m_high,-b.m_low);
  
  return(<a class="code" href="class_a.html">a</a>+c);
}

inline Interval operator/( const Interval &amp;<a class="code" href="class_a.html">a</a>, const Interval &amp;b )
{
  if( (b.m_low &lt; 0.0) &amp;&amp; (b.m_high &gt; 0.0) )
    throw gul::IntervalDivZeroError();

  Interval c(1.0/b.m_high,1.0/b.m_low);
  
  return(<a class="code" href="class_a.html">a</a>*c);
}

inline int Test( const Interval &amp;<a class="code" href="class_a.html">a</a>, const Interval &amp;b )
{
  Interval c = <a class="code" href="class_a.html">a</a>-b;
  
  if( c.m_high &lt; 0.0 ) return(-1);
  if( c.m_low &gt; 0.0 ) return(+1);

  return(0);   /* dunno :) */
}


/* ---------------------------------------------------------------
  functions for fractions arithmetic
--------------------------------------------------------------- */

inline PrecRational operator/( const PrecRational&amp; A, const PrecRational&amp; B )
{
  PrecRational c;
  
  if( A.m == B.m )
    return PrecRational(ULong(1));
  
  B.m-&gt;reciprocal();
  c = A * B;
  B.m-&gt;reciprocal();

  return(c);
}

inline PrecRational operator-( const PrecRational&amp; A, const PrecRational&amp; B )
{
  PrecRational c;  // (= 0)

  if( A.m == B.m )
    return c;

  if( A.m-&gt;m_na == 0 )   /* if A=0, A+B returns B !!! */
  {
    if( B.m-&gt;m_na != 0 )
    {
      c = B.GetCopy();
      c.m-&gt;m_sign = B.m-&gt;m_sign ^ -1;
    }
    return c;
  }
    
  B.m-&gt;negative();
  c = A + B;
  B.m-&gt;negative();

  return(c);
}

inline bool operator&lt;( const PrecRational&amp; A, int b )
{
  PrecRational B,C;
  unsigned long <a class="code" href="class_buf.html">buf</a>;
  
  if( b &lt; 0 )
  {
    B.m-&gt;m_sign = -1;
    <a class="code" href="class_buf.html">buf</a> = -b;
    B.m-&gt;m_a = &amp;<a class="code" href="class_buf.html">buf</a>;
    B.m-&gt;m_na = 1; 
  }
  else if( b &gt; 0 )
  {
    <a class="code" href="class_buf.html">buf</a> = b;
    B.m-&gt;m_a = &amp;<a class="code" href="class_buf.html">buf</a>;
    B.m-&gt;m_na = 1; 
  }
  
  C = A - B;

  return( C.m-&gt;m_sign != 0 );
}

inline bool operator&lt;=( const PrecRational&amp; A, int b )
{
  PrecRational B,C;
  unsigned long <a class="code" href="class_buf.html">buf</a>;
  
  if( b &lt; 0 )
  {
    B.m-&gt;m_sign = -1;
    <a class="code" href="class_buf.html">buf</a> = -b;
    B.m-&gt;m_a = &amp;<a class="code" href="class_buf.html">buf</a>;
    B.m-&gt;m_na = 1; 
  }
  else if( b &gt; 0 )
  {
    <a class="code" href="class_buf.html">buf</a> = b;
    B.m-&gt;m_a = &amp;<a class="code" href="class_buf.html">buf</a>;
    B.m-&gt;m_na = 1; 
  }
  
  C = A - B;

  if( C.m-&gt;m_sign || C.m-&gt;m_na == 0)
    return(true);

  return( false );
}

inline bool operator&gt;=( const PrecRational&amp; A, int b )
{
  return( !(A &lt; b) );
}

inline int Compare( const PrecRational&amp; A, const PrecRational &amp;B )
{
  Interval i;
  
  if( A.m == B.m )
    return 0;

  if( !A.m-&gt;m_bounds ) A.CalcBounds();
  if( !B.m-&gt;m_bounds ) B.CalcBounds();  
  i = A.m-&gt;m_i - B.m-&gt;m_i;
  if( i.m_high &lt; 0.0 ) return(-1); 
  else if( i.m_low &gt; 0.0 ) return(1); 

  PrecRational c = A - B;
  if( c.m-&gt;m_sign ) return(-1);
  if( c.m-&gt;m_na == 0 ) return(0);

  return(1);
}

class PrecPoint2D
{
public:
  PrecRational m_x;
  PrecRational m_y;

  PrecPoint2D() { }
  explicit PrecPoint2D( const PrecPoint2D&amp; o ) : m_x(o.m_x), m_y(o.m_y) { }
  explicit PrecPoint2D( ULong x, ULong y ) : m_x(x), m_y(y) { }
  explicit PrecPoint2D( const PrecRational&amp; x, const PrecRational&amp; y ) : 
                                                        m_x(x), m_y(y) { }
};

}

#endif


</div></pre><hr><address><small>Generated at Thu Jan 27 18:54:51 2000 for blaxxunContact3D by
<a href="http://www.stack.nl/~dimitri/doxygen/index.html">
<img src="doxygen.gif" alt="doxygen" align=center border=0 
width=118 height=53></a> 1.0.0 written by <a href="mailto:dimitri@stack.nl">Dimitri van Heesch</a>,
 &copy; 1997-1999</small></address>
</body>
</html>

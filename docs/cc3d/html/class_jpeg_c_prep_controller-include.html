<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta name="robots" content="noindex">
<title>jpeg_c_prep_controller Include File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body bgcolor="#ffffff">
<!-- Generated by Doxygen 1.0.0 on Thu Jan 27 18:55:30 2000 -->
<center>
<a class="qindex"href="index.html">Main Page</a> &nbsp; <a class="qindex"href="namespaces.html">Namespace List</a> &nbsp; <a class="qindex"href="hierarchy.html">Class Hierarchy</a> &nbsp; <a class="qindex"href="annotated.html">Compound List</a> &nbsp; <a class="qindex"href="files.html">File List</a> &nbsp; <a class="qindex"href="headers.html">Header Files</a> &nbsp; <a class="qindex"href="namespacemembers.html">Namespace Members</a> &nbsp; <a class="qindex"href="functions.html">Compound Members</a> &nbsp; <a class="qindex"href="globals.html">File Members</a> &nbsp; </center>
<hr><h1>jpegint.h</h1>This is the verbatim text of the jpegint.h include file.<div class="fragment"><pre>/*
 * jpegint.h
 *
 * Copyright (C) 1991-1996, Thomas G. Lane.
 * This file is part of the Independent JPEG Group's software.
 * For conditions of distribution and use, see the accompanying README file.
 *
 * This file provides common declarations for the various JPEG modules.
 * These declarations are considered internal to the JPEG library; most
 * applications using the library shouldn't need to include this file.
 */


/* Declarations for both compression &amp; decompression */

typedef enum {                  /* Operating modes for buffer controllers */
        JBUF_PASS_THRU,         /* Plain stripwise operation */
        /* Remaining modes require a full-image buffer to have been created */
        JBUF_SAVE_SOURCE,       /* Run source subobject only, save output */
        JBUF_CRANK_DEST,        /* Run dest subobject only, using saved data */
        JBUF_SAVE_AND_PASS      /* Run both subobjects, save output */
} J_BUF_MODE;

/* Values of global_state field (jdapi.c has some dependencies on ordering!) */
#define CSTATE_START    100     /* after create_compress */
#define CSTATE_SCANNING 101     /* start_compress done, write_scanlines OK */
#define CSTATE_RAW_OK   102     /* start_compress done, write_raw_data OK */
#define CSTATE_WRCOEFS  103     /* jpeg_write_coefficients done */
#define DSTATE_START    200     /* after create_decompress */
#define DSTATE_INHEADER 201     /* reading header markers, no SOS yet */
#define DSTATE_READY    202     /* found SOS, ready for start_decompress */
#define DSTATE_PRELOAD  203     /* reading multiscan file in start_decompress*/
#define DSTATE_PRESCAN  204     /* performing dummy pass for 2-pass quant */
#define DSTATE_SCANNING 205     /* start_decompress done, read_scanlines OK */
#define DSTATE_RAW_OK   206     /* start_decompress done, read_raw_data OK */
#define DSTATE_BUFIMAGE 207     /* expecting jpeg_start_output */
#define DSTATE_BUFPOST  208     /* looking for SOS/EOI in jpeg_finish_output */
#define DSTATE_RDCOEFS  209     /* reading file in jpeg_read_coefficients */
#define DSTATE_STOPPING 210     /* looking for EOI in jpeg_finish_decompress */


/* Declarations for compression modules */

/* Master control module */
struct <a class="code" href="class_jpeg_comp_master.html">jpeg_comp_master</a> {
  <a class="code" href="class_jpeg_comp_master.html#a0">JMETHOD</a>(void, prepare_for_pass, (j_compress_ptr cinfo));
  <a class="code" href="class_jpeg_comp_master.html#a0">JMETHOD</a>(void, pass_startup, (j_compress_ptr cinfo));
  <a class="code" href="class_jpeg_comp_master.html#a0">JMETHOD</a>(void, finish_pass, (j_compress_ptr cinfo));

  /* State variables made visible to other modules */
  boolean call_pass_startup;    /* True if pass_startup must be called */
  boolean is_last_pass;         /* True during last pass */
};

/* Main buffer control (downsampled-data buffer) */
struct <a class="code" href="class_jpeg_c_main_controller.html">jpeg_c_main_controller</a> {
  <a class="code" href="class_jpeg_c_main_controller.html#a0">JMETHOD</a>(void, start_pass, (j_compress_ptr cinfo, J_BUF_MODE pass_mode));
  <a class="code" href="class_jpeg_c_main_controller.html#a0">JMETHOD</a>(void, process_data, (j_compress_ptr cinfo,
                               JSAMPARRAY input_buf, JDIMENSION *in_row_ctr,
                               JDIMENSION in_rows_avail));
};

/* Compression preprocessing (downsampling input buffer control) */
struct <a class="code" href="class_jpeg_c_prep_controller.html">jpeg_c_prep_controller</a> {
  <a class="code" href="class_jpeg_c_prep_controller.html#a0">JMETHOD</a>(void, start_pass, (j_compress_ptr cinfo, J_BUF_MODE pass_mode));
  <a class="code" href="class_jpeg_c_prep_controller.html#a0">JMETHOD</a>(void, pre_process_data, (j_compress_ptr cinfo,
                                   JSAMPARRAY input_buf,
                                   JDIMENSION *in_row_ctr,
                                   JDIMENSION in_rows_avail,
                                   JSAMPIMAGE output_buf,
                                   JDIMENSION *out_row_group_ctr,
                                   JDIMENSION out_row_groups_avail));
};

/* Coefficient buffer control */
struct <a class="code" href="class_jpeg_c_coef_controller.html">jpeg_c_coef_controller</a> {
  <a class="code" href="class_jpeg_c_coef_controller.html#a0">JMETHOD</a>(void, start_pass, (j_compress_ptr cinfo, J_BUF_MODE pass_mode));
  <a class="code" href="class_jpeg_c_coef_controller.html#a0">JMETHOD</a>(boolean, compress_data, (j_compress_ptr cinfo,
                                   JSAMPIMAGE input_buf));
};

/* Colorspace conversion */
struct <a class="code" href="class_jpeg_color_converter.html">jpeg_color_converter</a> {
  <a class="code" href="class_jpeg_color_converter.html#a0">JMETHOD</a>(void, start_pass, (j_compress_ptr cinfo));
  <a class="code" href="class_jpeg_color_converter.html#a0">JMETHOD</a>(void, color_convert, (j_compress_ptr cinfo,
                                JSAMPARRAY input_buf, JSAMPIMAGE output_buf,
                                JDIMENSION output_row, int num_rows));
};

/* Downsampling */
struct <a class="code" href="class_jpeg_downsampler.html">jpeg_downsampler</a> {
  <a class="code" href="class_jpeg_downsampler.html#a0">JMETHOD</a>(void, start_pass, (j_compress_ptr cinfo));
  <a class="code" href="class_jpeg_downsampler.html#a0">JMETHOD</a>(void, downsample, (j_compress_ptr cinfo,
                             JSAMPIMAGE input_buf, JDIMENSION in_row_index,
                             JSAMPIMAGE output_buf,
                             JDIMENSION out_row_group_index));

  boolean need_context_rows;    /* TRUE if need rows above &amp; below */
};

/* Forward DCT (also controls coefficient quantization) */
struct <a class="code" href="class_jpeg_forward_dct.html">jpeg_forward_dct</a> {
  <a class="code" href="class_jpeg_forward_dct.html#a0">JMETHOD</a>(void, start_pass, (j_compress_ptr cinfo));
  /* perhaps this should be an array??? */
  <a class="code" href="class_jpeg_forward_dct.html#a0">JMETHOD</a>(void, forward_DCT, (j_compress_ptr cinfo,
                              <a class="code" href="class_jpeg_component_info.html">jpeg_component_info</a> * compptr,
                              JSAMPARRAY sample_data, JBLOCKROW coef_blocks,
                              JDIMENSION start_row, JDIMENSION start_col,
                              JDIMENSION num_blocks));
};

/* Entropy encoding */
struct <a class="code" href="class_jpeg_entropy_encoder.html">jpeg_entropy_encoder</a> {
  <a class="code" href="class_jpeg_entropy_encoder.html#a0">JMETHOD</a>(void, start_pass, (j_compress_ptr cinfo, boolean gather_statistics));
  <a class="code" href="class_jpeg_entropy_encoder.html#a0">JMETHOD</a>(boolean, encode_mcu, (j_compress_ptr cinfo, JBLOCKROW *MCU_data));
  <a class="code" href="class_jpeg_entropy_encoder.html#a0">JMETHOD</a>(void, finish_pass, (j_compress_ptr cinfo));
};

/* Marker writing */
struct <a class="code" href="class_jpeg_marker_writer.html">jpeg_marker_writer</a> {
  /* write_any_marker is exported for use by applications */
  /* Probably only COM and APPn markers should be written */
  <a class="code" href="class_jpeg_marker_writer.html#a0">JMETHOD</a>(void, write_any_marker, (j_compress_ptr cinfo, int marker,
                                   const JOCTET *dataptr, unsigned int datalen));
  <a class="code" href="class_jpeg_marker_writer.html#a0">JMETHOD</a>(void, write_file_header, (j_compress_ptr cinfo));
  <a class="code" href="class_jpeg_marker_writer.html#a0">JMETHOD</a>(void, write_frame_header, (j_compress_ptr cinfo));
  <a class="code" href="class_jpeg_marker_writer.html#a0">JMETHOD</a>(void, write_scan_header, (j_compress_ptr cinfo));
  <a class="code" href="class_jpeg_marker_writer.html#a0">JMETHOD</a>(void, write_file_trailer, (j_compress_ptr cinfo));
  <a class="code" href="class_jpeg_marker_writer.html#a0">JMETHOD</a>(void, write_tables_only, (j_compress_ptr cinfo));
};


/* Declarations for decompression modules */

/* Master control module */
struct <a class="code" href="class_jpeg_decomp_master.html">jpeg_decomp_master</a> {
  <a class="code" href="class_jpeg_decomp_master.html#a0">JMETHOD</a>(void, prepare_for_output_pass, (j_decompress_ptr cinfo));
  <a class="code" href="class_jpeg_decomp_master.html#a0">JMETHOD</a>(void, finish_output_pass, (j_decompress_ptr cinfo));

  /* State variables made visible to other modules */
  boolean is_dummy_pass;        /* True during 1st pass for 2-pass quant */
};

/* Input control module */
struct <a class="code" href="class_jpeg_input_controller.html">jpeg_input_controller</a> {
  <a class="code" href="class_jpeg_input_controller.html#a0">JMETHOD</a>(int, consume_input, (j_decompress_ptr cinfo));
  <a class="code" href="class_jpeg_input_controller.html#a0">JMETHOD</a>(void, reset_input_controller, (j_decompress_ptr cinfo));
  <a class="code" href="class_jpeg_input_controller.html#a0">JMETHOD</a>(void, start_input_pass, (j_decompress_ptr cinfo));
  <a class="code" href="class_jpeg_input_controller.html#a0">JMETHOD</a>(void, finish_input_pass, (j_decompress_ptr cinfo));

  /* State variables made visible to other modules */
  boolean has_multiple_scans;   /* True if file has multiple scans */
  boolean eoi_reached;          /* True when EOI has been consumed */
};

/* Main buffer control (downsampled-data buffer) */
struct <a class="code" href="class_jpeg_d_main_controller.html">jpeg_d_main_controller</a> {
  <a class="code" href="class_jpeg_d_main_controller.html#a0">JMETHOD</a>(void, start_pass, (j_decompress_ptr cinfo, J_BUF_MODE pass_mode));
  <a class="code" href="class_jpeg_d_main_controller.html#a0">JMETHOD</a>(void, process_data, (j_decompress_ptr cinfo,
                               JSAMPARRAY output_buf, JDIMENSION *out_row_ctr,
                               JDIMENSION out_rows_avail));
};

/* Coefficient buffer control */
struct <a class="code" href="class_jpeg_d_coef_controller.html">jpeg_d_coef_controller</a> {
  <a class="code" href="class_jpeg_d_coef_controller.html#a0">JMETHOD</a>(void, start_input_pass, (j_decompress_ptr cinfo));
  <a class="code" href="class_jpeg_d_coef_controller.html#a0">JMETHOD</a>(int, consume_data, (j_decompress_ptr cinfo));
  <a class="code" href="class_jpeg_d_coef_controller.html#a0">JMETHOD</a>(void, start_output_pass, (j_decompress_ptr cinfo));
  <a class="code" href="class_jpeg_d_coef_controller.html#a0">JMETHOD</a>(int, decompress_data, (j_decompress_ptr cinfo,
                                 JSAMPIMAGE output_buf));
  /* Pointer to array of coefficient virtual arrays, or NULL if none */
  jvirt_barray_ptr *coef_arrays;
};

/* Decompression postprocessing (color quantization buffer control) */
struct <a class="code" href="class_jpeg_d_post_controller.html">jpeg_d_post_controller</a> {
  <a class="code" href="class_jpeg_d_post_controller.html#a0">JMETHOD</a>(void, start_pass, (j_decompress_ptr cinfo, J_BUF_MODE pass_mode));
  <a class="code" href="class_jpeg_d_post_controller.html#a0">JMETHOD</a>(void, post_process_data, (j_decompress_ptr cinfo,
                                    JSAMPIMAGE input_buf,
                                    JDIMENSION *in_row_group_ctr,
                                    JDIMENSION in_row_groups_avail,
                                    JSAMPARRAY output_buf,
                                    JDIMENSION *out_row_ctr,
                                    JDIMENSION out_rows_avail));
};

/* Marker reading &amp; parsing */
struct <a class="code" href="class_jpeg_marker_reader.html">jpeg_marker_reader</a> {
  <a class="code" href="class_jpeg_marker_reader.html#a0">JMETHOD</a>(void, reset_marker_reader, (j_decompress_ptr cinfo));
  /* Read markers until SOS or EOI.
   * Returns same codes as are defined for jpeg_consume_input:
   * JPEG_SUSPENDED, JPEG_REACHED_SOS, or JPEG_REACHED_EOI.
   */
  <a class="code" href="class_jpeg_marker_reader.html#a0">JMETHOD</a>(int, read_markers, (j_decompress_ptr cinfo));
  /* Read a restart marker --- exported for use by entropy decoder only */
  jpeg_marker_parser_method read_restart_marker;
  /* Application-overridable marker processing methods */
  jpeg_marker_parser_method process_COM;
  jpeg_marker_parser_method process_APPn[16];

  /* State of marker reader --- nominally internal, but applications
   * supplying COM or APPn handlers might like to know the state.
   */
  boolean saw_SOI;              /* found SOI? */
  boolean saw_SOF;              /* found SOF? */
  int next_restart_num;         /* next restart number expected (0-7) */
  unsigned int discarded_bytes; /* # of bytes skipped looking for a marker */
};

/* Entropy decoding */
struct <a class="code" href="class_jpeg_entropy_decoder.html">jpeg_entropy_decoder</a> {
  <a class="code" href="class_jpeg_entropy_decoder.html#a0">JMETHOD</a>(void, start_pass, (j_decompress_ptr cinfo));
  <a class="code" href="class_jpeg_entropy_decoder.html#a0">JMETHOD</a>(boolean, decode_mcu, (j_decompress_ptr cinfo,
                                JBLOCKROW *MCU_data));
};

/* Inverse DCT (also performs dequantization) */
typedef <a class="code" href="jmorecfg.h.html#a11">JMETHOD</a>(void, inverse_DCT_method_ptr,
                (j_decompress_ptr cinfo, <a class="code" href="class_jpeg_component_info.html">jpeg_component_info</a> * compptr,
                 JCOEFPTR coef_block,
                 JSAMPARRAY output_buf, JDIMENSION output_col));

struct <a class="code" href="class_jpeg_inverse_dct.html">jpeg_inverse_dct</a> {
  <a class="code" href="class_jpeg_inverse_dct.html#a0">JMETHOD</a>(void, start_pass, (j_decompress_ptr cinfo));
  /* It is useful to allow each component to have a separate IDCT method. */
  inverse_DCT_method_ptr inverse_DCT[MAX_COMPONENTS];
};

/* Upsampling (note that upsampler must also call color converter) */
struct <a class="code" href="class_jpeg_upsampler.html">jpeg_upsampler</a> {
  <a class="code" href="class_jpeg_upsampler.html#a0">JMETHOD</a>(void, start_pass, (j_decompress_ptr cinfo));
  <a class="code" href="class_jpeg_upsampler.html#a0">JMETHOD</a>(void, upsample, (j_decompress_ptr cinfo,
                           JSAMPIMAGE input_buf,
                           JDIMENSION *in_row_group_ctr,
                           JDIMENSION in_row_groups_avail,
                           JSAMPARRAY output_buf,
                           JDIMENSION *out_row_ctr,
                           JDIMENSION out_rows_avail));

  boolean need_context_rows;    /* TRUE if need rows above &amp; below */
};

/* Colorspace conversion */
struct <a class="code" href="class_jpeg_color_deconverter.html">jpeg_color_deconverter</a> {
  <a class="code" href="class_jpeg_color_deconverter.html#a0">JMETHOD</a>(void, start_pass, (j_decompress_ptr cinfo));
  <a class="code" href="class_jpeg_color_deconverter.html#a0">JMETHOD</a>(void, color_convert, (j_decompress_ptr cinfo,
                                JSAMPIMAGE input_buf, JDIMENSION input_row,
                                JSAMPARRAY output_buf, int num_rows));
};

/* Color quantization or color precision reduction */
struct <a class="code" href="class_jpeg_color_quantizer.html">jpeg_color_quantizer</a> {
  <a class="code" href="class_jpeg_color_quantizer.html#a0">JMETHOD</a>(void, start_pass, (j_decompress_ptr cinfo, boolean is_pre_scan));
  <a class="code" href="class_jpeg_color_quantizer.html#a0">JMETHOD</a>(void, color_quantize, (j_decompress_ptr cinfo,
                                 JSAMPARRAY input_buf, JSAMPARRAY output_buf,
                                 int num_rows));
  <a class="code" href="class_jpeg_color_quantizer.html#a0">JMETHOD</a>(void, finish_pass, (j_decompress_ptr cinfo));
  <a class="code" href="class_jpeg_color_quantizer.html#a0">JMETHOD</a>(void, new_color_map, (j_decompress_ptr cinfo));
};


/* Miscellaneous useful macros */

#undef MAX
#define MAX(a,b)        ((a) &gt; (b) ? (a) : (b))
#undef MIN
#define MIN(a,b)        ((a) &lt; (b) ? (a) : (b))


/* We assume that right shift corresponds to signed division by 2 with
 * rounding towards minus infinity.  This is correct for typical "arithmetic
 * shift" instructions that shift in copies of the sign bit.  But some
 * C compilers implement &gt;&gt; with an unsigned shift.  For these machines you
 * must define RIGHT_SHIFT_IS_UNSIGNED.
 * RIGHT_SHIFT provides a proper signed right shift of an INT32 quantity.
 * It is only applied with constant shift counts.  SHIFT_TEMPS must be
 * included in the variables of any routine using RIGHT_SHIFT.
 */

#ifdef RIGHT_SHIFT_IS_UNSIGNED
#define SHIFT_TEMPS     INT32 shift_temp;
#define RIGHT_SHIFT(x,shft)  \
        ((shift_temp = (x)) &lt; 0 ? \
         (shift_temp &gt;&gt; (shft)) | ((~((INT32) 0)) &lt;&lt; (32-(shft))) : \
         (shift_temp &gt;&gt; (shft)))
#else
#define SHIFT_TEMPS
#define RIGHT_SHIFT(x,shft)     ((x) &gt;&gt; (shft))
#endif


/* Short forms of external names for systems with brain-damaged linkers. */

#ifdef NEED_SHORT_EXTERNAL_NAMES
#define jinit_compress_master   jICompress
#define jinit_c_master_control  jICMaster
#define jinit_c_main_controller jICMainC
#define jinit_c_prep_controller jICPrepC
#define jinit_c_coef_controller jICCoefC
#define jinit_color_converter   jICColor
#define jinit_downsampler       jIDownsampler
#define jinit_forward_dct       jIFDCT
#define jinit_huff_encoder      jIHEncoder
#define jinit_phuff_encoder     jIPHEncoder
#define jinit_marker_writer     jIMWriter
#define jinit_master_decompress jIDMaster
#define jinit_d_main_controller jIDMainC
#define jinit_d_coef_controller jIDCoefC
#define jinit_d_post_controller jIDPostC
#define jinit_input_controller  jIInCtlr
#define jinit_marker_reader     jIMReader
#define jinit_huff_decoder      jIHDecoder
#define jinit_phuff_decoder     jIPHDecoder
#define jinit_inverse_dct       jIIDCT
#define jinit_upsampler         jIUpsampler
#define jinit_color_deconverter jIDColor
#define jinit_1pass_quantizer   jI1Quant
#define jinit_2pass_quantizer   jI2Quant
#define jinit_merged_upsampler  jIMUpsampler
#define jinit_memory_mgr        jIMemMgr
#define jdiv_round_up           jDivRound
#define jround_up               jRound
#define jcopy_sample_rows       jCopySamples
#define jcopy_block_row         jCopyBlocks
#define jzero_far               jZeroFar
#define jpeg_zigzag_order       jZIGTable
#define jpeg_natural_order      jZAGTable
#endif /* NEED_SHORT_EXTERNAL_NAMES */


/* Compression module initialization routines */
<a class="code" href="cdjpeg.h.html#a10">EXTERN</a>(void) jinit_compress_master <a class="code" href="jpeglib.h.html#a18">JPP</a>((j_compress_ptr cinfo));
<a class="code" href="cdjpeg.h.html#a10">EXTERN</a>(void) jinit_c_master_control <a class="code" href="jpeglib.h.html#a18">JPP</a>((j_compress_ptr cinfo,
                                         boolean transcode_only));
<a class="code" href="cdjpeg.h.html#a10">EXTERN</a>(void) jinit_c_main_controller <a class="code" href="jpeglib.h.html#a18">JPP</a>((j_compress_ptr cinfo,
                                          boolean need_full_buffer));
<a class="code" href="cdjpeg.h.html#a10">EXTERN</a>(void) jinit_c_prep_controller <a class="code" href="jpeglib.h.html#a18">JPP</a>((j_compress_ptr cinfo,
                                          boolean need_full_buffer));
<a class="code" href="cdjpeg.h.html#a10">EXTERN</a>(void) jinit_c_coef_controller <a class="code" href="jpeglib.h.html#a18">JPP</a>((j_compress_ptr cinfo,
                                          boolean need_full_buffer));
<a class="code" href="cdjpeg.h.html#a10">EXTERN</a>(void) jinit_color_converter <a class="code" href="jpeglib.h.html#a18">JPP</a>((j_compress_ptr cinfo));
<a class="code" href="cdjpeg.h.html#a10">EXTERN</a>(void) jinit_downsampler <a class="code" href="jpeglib.h.html#a18">JPP</a>((j_compress_ptr cinfo));
<a class="code" href="cdjpeg.h.html#a10">EXTERN</a>(void) jinit_forward_dct <a class="code" href="jpeglib.h.html#a18">JPP</a>((j_compress_ptr cinfo));
<a class="code" href="cdjpeg.h.html#a10">EXTERN</a>(void) jinit_huff_encoder <a class="code" href="jpeglib.h.html#a18">JPP</a>((j_compress_ptr cinfo));
<a class="code" href="cdjpeg.h.html#a10">EXTERN</a>(void) jinit_phuff_encoder <a class="code" href="jpeglib.h.html#a18">JPP</a>((j_compress_ptr cinfo));
<a class="code" href="cdjpeg.h.html#a10">EXTERN</a>(void) jinit_marker_writer <a class="code" href="jpeglib.h.html#a18">JPP</a>((j_compress_ptr cinfo));
/* Decompression module initialization routines */
<a class="code" href="cdjpeg.h.html#a10">EXTERN</a>(void) jinit_master_decompress <a class="code" href="jpeglib.h.html#a18">JPP</a>((j_decompress_ptr cinfo));
<a class="code" href="cdjpeg.h.html#a10">EXTERN</a>(void) jinit_d_main_controller <a class="code" href="jpeglib.h.html#a18">JPP</a>((j_decompress_ptr cinfo,
                                          boolean need_full_buffer));
<a class="code" href="cdjpeg.h.html#a10">EXTERN</a>(void) jinit_d_coef_controller <a class="code" href="jpeglib.h.html#a18">JPP</a>((j_decompress_ptr cinfo,
                                          boolean need_full_buffer));
<a class="code" href="cdjpeg.h.html#a10">EXTERN</a>(void) jinit_d_post_controller <a class="code" href="jpeglib.h.html#a18">JPP</a>((j_decompress_ptr cinfo,
                                          boolean need_full_buffer));
<a class="code" href="cdjpeg.h.html#a10">EXTERN</a>(void) jinit_input_controller <a class="code" href="jpeglib.h.html#a18">JPP</a>((j_decompress_ptr cinfo));
<a class="code" href="cdjpeg.h.html#a10">EXTERN</a>(void) jinit_marker_reader <a class="code" href="jpeglib.h.html#a18">JPP</a>((j_decompress_ptr cinfo));
<a class="code" href="cdjpeg.h.html#a10">EXTERN</a>(void) jinit_huff_decoder <a class="code" href="jpeglib.h.html#a18">JPP</a>((j_decompress_ptr cinfo));
<a class="code" href="cdjpeg.h.html#a10">EXTERN</a>(void) jinit_phuff_decoder <a class="code" href="jpeglib.h.html#a18">JPP</a>((j_decompress_ptr cinfo));
<a class="code" href="cdjpeg.h.html#a10">EXTERN</a>(void) jinit_inverse_dct <a class="code" href="jpeglib.h.html#a18">JPP</a>((j_decompress_ptr cinfo));
<a class="code" href="cdjpeg.h.html#a10">EXTERN</a>(void) jinit_upsampler <a class="code" href="jpeglib.h.html#a18">JPP</a>((j_decompress_ptr cinfo));
<a class="code" href="cdjpeg.h.html#a10">EXTERN</a>(void) jinit_color_deconverter <a class="code" href="jpeglib.h.html#a18">JPP</a>((j_decompress_ptr cinfo));
<a class="code" href="cdjpeg.h.html#a10">EXTERN</a>(void) jinit_1pass_quantizer <a class="code" href="jpeglib.h.html#a18">JPP</a>((j_decompress_ptr cinfo));
<a class="code" href="cdjpeg.h.html#a10">EXTERN</a>(void) jinit_2pass_quantizer <a class="code" href="jpeglib.h.html#a18">JPP</a>((j_decompress_ptr cinfo));
<a class="code" href="cdjpeg.h.html#a10">EXTERN</a>(void) jinit_merged_upsampler <a class="code" href="jpeglib.h.html#a18">JPP</a>((j_decompress_ptr cinfo));
/* Memory manager initialization */
<a class="code" href="cdjpeg.h.html#a10">EXTERN</a>(void) jinit_memory_mgr <a class="code" href="jpeglib.h.html#a18">JPP</a>((j_common_ptr cinfo));

/* Utility routines in jutils.c */
<a class="code" href="cdjpeg.h.html#a10">EXTERN</a>(long) jdiv_round_up <a class="code" href="jpeglib.h.html#a18">JPP</a>((long <a class="code" href="class_a.html">a</a>, long b));
<a class="code" href="cdjpeg.h.html#a10">EXTERN</a>(long) jround_up <a class="code" href="jpeglib.h.html#a18">JPP</a>((long <a class="code" href="class_a.html">a</a>, long b));
<a class="code" href="cdjpeg.h.html#a10">EXTERN</a>(void) jcopy_sample_rows <a class="code" href="jpeglib.h.html#a18">JPP</a>((JSAMPARRAY input_array, int source_row,
                                    JSAMPARRAY output_array, int dest_row,
                                    int num_rows, JDIMENSION num_cols));
<a class="code" href="cdjpeg.h.html#a10">EXTERN</a>(void) jcopy_block_row <a class="code" href="jpeglib.h.html#a18">JPP</a>((JBLOCKROW input_row, JBLOCKROW output_row,
                                  JDIMENSION num_blocks));
<a class="code" href="cdjpeg.h.html#a10">EXTERN</a>(void) jzero_far <a class="code" href="jpeglib.h.html#a18">JPP</a>((void <a class="code" href="class_inflate_huft_s.html">FAR</a> * target, size_t bytestozero));
/* Constant tables in jutils.c */
extern const int jpeg_zigzag_order[]; /* natural coef order to zigzag order */
extern const int jpeg_natural_order[]; /* zigzag coef order to natural order */

/* Suppress undefined-structure complaints if necessary. */

#ifdef INCOMPLETE_TYPES_BROKEN
#ifndef AM_MEMORY_MANAGER       /* only jmemmgr.c defines these */
struct jvirt_sarray_control { long dummy; };
struct jvirt_barray_control { long dummy; };
#endif
#endif /* INCOMPLETE_TYPES_BROKEN */
</div></pre><hr><address><small>Generated at Thu Jan 27 18:55:31 2000 for blaxxunContact3D by
<a href="http://www.stack.nl/~dimitri/doxygen/index.html">
<img src="doxygen.gif" alt="doxygen" align=center border=0 
width=118 height=53></a> 1.0.0 written by <a href="mailto:dimitri@stack.nl">Dimitri van Heesch</a>,
 &copy; 1997-1999</small></address>
</body>
</html>

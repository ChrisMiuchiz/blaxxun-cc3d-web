<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta name="robots" content="noindex">
<title>GvMetaverse Include File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body bgcolor="#ffffff">
<!-- Generated by Doxygen 1.0.0 on Thu Jan 27 18:48:47 2000 -->
<center>
<a class="qindex"href="index.html">Main Page</a> &nbsp; <a class="qindex"href="namespaces.html">Namespace List</a> &nbsp; <a class="qindex"href="hierarchy.html">Class Hierarchy</a> &nbsp; <a class="qindex"href="annotated.html">Compound List</a> &nbsp; <a class="qindex"href="files.html">File List</a> &nbsp; <a class="qindex"href="headers.html">Header Files</a> &nbsp; <a class="qindex"href="namespacemembers.html">Namespace Members</a> &nbsp; <a class="qindex"href="functions.html">Compound Members</a> &nbsp; <a class="qindex"href="globals.html">File Members</a> &nbsp; </center>
<hr><h1>gvbsp.h</h1>This is the verbatim text of the gvbsp.h include file.<div class="fragment"><pre>/*=============================================================================

This code is licensed under the Web3D-blaxxun Community Source License,
provided in distribution file LICENSE.TXT and available online at
http://www.web3D.org/TaskGroups/x3d/blaxxun/Web3D-blaxxunCommunitySourceAgreement.html
and may only be used for non-commercial use as specified in that license.

THE WEB3D CONSORTIUM AND BLAXXUN DO NOT MAKE AND HEREBY DISCLAIM ANY EXPRESS
OR IMPLIED WARRANTIES RELATING TO THIS CODE, INCLUDING BUT NOT LIMITED TO,
WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY OR FITNESS FOR A PARTICULAR
PURPOSE, OR ANY WARRANTIES THAT MIGHT ARISE FROM A COURSE OF DEALING, USAGE
OR TRADE PRACTICE.  THE COMMUNITY SOURCE CODE IS PROVIDED UNDER THIS
AGREEMENT "AS IS," WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
INCLUDING, WITHOUT LIMITATION, WARRANTIES THAT THE COMMUNITY SOURCE CODE ARE
FREE OF DEFECTS, MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE OR
NON-INFRINGING OR IN ANY WAY CONSTITUTE THE COMPLETE PRODUCT MARKETED UNDER
THE NAMES GIVEN SAID CODE.

==============================================================================*/
#ifndef  _GvBsp_h_
#define  _GvBsp_h_


#include &lt;gvsubnode.h&gt;

#include &lt;gvsfrotation.h&gt;
#include &lt;gvsfnode.h&gt;

#include &lt;gvmfnode.h&gt;

#include &lt;gvsfbool.h&gt;
#include &lt;gvsftime.h&gt;
#include &lt;gvsfvec3f.h&gt;
#include &lt;gvmfstring.h&gt;

#include &lt;gv2group.h&gt;


/* 
   Build a BSP Tree 
   out of a set of nodes

*/

<a class="code" href="class_gvnode.html">GvNode</a> *BuildBspTree(<a class="code" href="class_gvmfnode.html">GvMFNode</a> &amp;shapes); 



#if 0

class GvBspShape : public <a class="code" href="class_gvnode.html">GvNode</a> {

    <a class="code" href="class_gvgeometrysensor.html#c0">GV_NODE_HEADER</a>(GvBspShape);

public:
    // Fields
   //GvMatrixTransform transform; 

   <a class="code" href="class_gvsfnode.html">GvSFNode</a> appearance; // Default NULL
   <a class="code" href="class_gvsfnode.html">GvSFNode</a> geometry;  // Default NULL 

public:

        <a class="code" href="class_bbox.html">BBox</a> bbox; // bounding box in GLOBAL coordinates 

        // get matrix of node , FALSE if node has no matrix 
        GvBool <a class="code" href="class_gvnode.html#a39">getMatrix</a>(<a class="code" href="class_matrix.html">Matrix</a> &amp;m) {   get(m); return(TRUE); }
        void get(<a class="code" href="class_matrix.html">Matrix</a> &amp;m) { matrix.Get(m); }

        // apply transform to state 
        int setMatrix(<a class="code" href="class_gtraversal.html">GTraversal</a> &amp;state);

        <a class="code" href="class_bbox.html">BBox</a> &amp;getBoundingBox() { return bbox; }



    int <a class="code" href="class_gvgeometrysensor.html#a1">Do</a>(<a class="code" href="class_gtraversal.html">GTraversal</a> &amp;state);          
    int <a class="code" href="class_gvgeometrysensor.html#a1">Do</a>(<a class="code" href="class_gglrendertraversal.html">GglRenderTraversal</a> &amp;state);
    int <a class="code" href="class_gvgeometrysensor.html#a1">Do</a>(<a class="code" href="class_grayselecttraversal.html">GRaySelectTraversal</a> &amp;state);  

    int <a class="code" href="class_gvgeometrysensor.html#a1">Do</a>(<a class="code" href="class_gbboxtraversal.html">GBBoxTraversal</a> &amp;state);


};

#endif


#define TRAVERSE_NORMAL 0
#define TRAVERSE_BACK_TO_FRONT 1
#define TRAVERSE_FRONT_TO_BACK 2
#define TRAVERSE_FRONT_TO_BACK_VISIBILITY 3


enum BSP_HEURISTIC {
        USE_FIRST_PLANAR_OBJECT,
        USE_LARGEST_PLANAR_OBJECT,
        SPLIT_ALONG_BBOX,
        COMPUTE_SEPARATION_PLANE
};

//
// GvBspTree
//


class <a class="code" href="class_gvbsptree.html">GvBspTree</a> : public <a class="code" href="class_gvnode.html">GvNode</a> {

    <a class="code" href="class_gvgeometrysensor.html#c0">GV_NODE_HEADER</a>(<a class="code" href="class_gvbsptree.html">GvBspTree</a>);

public:
    // Fields

   <a class="code" href="class_gvsfrotation.html">GvSFRotation</a> plane;  // the separation plane 
   <a class="code" href="class_gvsfnode.html">GvSFNode</a> front; // Default NULL
   <a class="code" href="class_gvsfnode.html">GvSFNode</a> overlap; // Default NULL
   <a class="code" href="class_gvsfnode.html">GvSFNode</a> back;  // Default NULL 

   // set the plane 
   void <a class="code" href="class_gvbsptree.html#a0">setPlane</a>(const <a class="code" href="class_plane.html">Plane</a> &amp;p) { plane.<a class="code" href="class_gvsfrotation.html#a13">set</a>(p.n.x,p.n.y,p.n.z,p.d); }
   void <a class="code" href="class_gvbsptree.html#a1">getPlane</a>(<a class="code" href="class_plane.html">Plane</a> &amp;p) { p.<a class="code" href="class_plane.html#a5">Set</a>(plane.value[0],plane.value[1],plane.value[2],plane.value[3]); }

#ifdef _DEBUG
   // additional BBox check 
   GvBool bboxOk;       
   <a class="code" href="class_bbox.html">BBox</a> bbox;

#endif

   // global builder flags
   static BSP_HEURISTIC bspHeuristic;   // bsp split heuristic
   static BOOL  bspSplit;       // split of polygons / facesets allowed 
   static int   maxBspSplit; // max allowed bsp-tree depth 

   // statistic
   static int bspLevel;
   static int bspSearchLimit; // limitation of the number of candidates search
   static int bspMaxLevel; // maximum allowed tree level
   static int bspOverlapMax;
   static int bspOverlapMean;
   static int bspOverlapMeanCnt;
   static int bspNumNodes; // num BspTree Nodes
   static int bspNumGeomNodes; // num Geometry Nodes

   static void <a class="code" href="class_gvbsptree.html#d0">ClearStats</a>();

   //#ifdef _DEBUG   
   // render stats
        static int boxCullsSucceeded;
        static int viewerPlaneCullsSucceeded;
        static int checkedNodes;

        static int cullChecks;
        static int cullChecksSucceeded;

        static void <a class="code" href="class_gvbsptree.html#d1">ClearBspStats</a>();
        static void <a class="code" href="class_gvbsptree.html#d2">TraceBspStats</a>();
//#endif


public:

   int <a class="code" href="class_gvgeometrysensor.html#a1">Do</a>(<a class="code" href="class_gtraversal.html">GTraversal</a> &amp;state);           
   int <a class="code" href="class_gvgeometrysensor.html#a1">Do</a>(<a class="code" href="class_gpathtraversal.html">GPathTraversal</a> &amp;state);       
   int <a class="code" href="class_gvgeometrysensor.html#a1">Do</a>(<a class="code" href="class_gglrendertraversal.html">GglRenderTraversal</a> &amp;state);
   
   int <a class="code" href="class_gvgeometrysensor.html#a1">Do</a>(<a class="code" href="class_gloadinlinestraversal.html">GLoadInlinesTraversal</a> &amp;state);

   int <a class="code" href="class_gvgeometrysensor.html#a1">Do</a>(<a class="code" href="class_grayselecttraversal.html">GRaySelectTraversal</a> &amp;state);  
   int <a class="code" href="class_gvgeometrysensor.html#a1">Do</a>(<a class="code" href="class_gbboxtraversal.html">GBBoxTraversal</a> &amp;state);
   int <a class="code" href="class_gvgeometrysensor.html#a1">Do</a>(<a class="code" href="class_goptimizetraversal.html">GOptimizeTraversal</a> &amp;state); 

};

//
// BspGroup - automatically build BspTree
//


class <a class="code" href="class_gvbspgroup.html">GvBspGroup</a> : public <a class="code" href="class_gv2group.html">Gv2Group</a> {

    <a class="code" href="class_gv2group.html#c0">GV_NODE_HEADER</a>(<a class="code" href="class_gvbspgroup.html">GvBspGroup</a>);

public:
    // Fields :

    // bboxCenter
    // bboxSize

        GvBool           buildBspTree;  // need to rebuild bsp Tree
    <a class="code" href="class_gvsfnode.html">GvSFNode</a>     bspTree;      // NULL,



        // helpers 
        GvBool <a class="code" href="class_gvbspgroup.html#a0">isOutside</a>(<a class="code" href="class_gtraversal.html">GTraversal</a> &amp;state, const <a class="code" href="class_point.html">Point</a> &amp;p);
        GvBool <a class="code" href="class_gvbspgroup.html#a0">isOutside</a>(<a class="code" href="class_gtraversal.html">GTraversal</a> &amp;state, <a class="code" href="class_gvnode.html">GvNode</a>* proxy,const <a class="code" href="class_point.html">Point</a> &amp;p) const;
        GvBool <a class="code" href="class_gvbspgroup.html#a0">isOutside</a>(<a class="code" href="class_gtraversal.html">GTraversal</a> &amp;state, <a class="code" href="class_gvmfnode.html">GvMFNode</a> &amp;proxy,const <a class="code" href="class_point.html">Point</a> &amp;p) const;

        // build the bsp tree
        GvBool <a class="code" href="class_gvbspgroup.html#a3">BuildBspTree</a>();

        // children

    // call by subfield on touch
        int <a class="code" href="class_gv2group.html#a8">OnFieldChanged</a>(<a class="code" href="class_gvfield.html">GvField</a> *field);


    int <a class="code" href="class_gv2group.html#a12">Do</a>(<a class="code" href="class_gtraversal.html">GTraversal</a> &amp;state);
    int <a class="code" href="class_gv2group.html#a12">Do</a>(<a class="code" href="class_gpathtraversal.html">GPathTraversal</a> &amp;state);
    int <a class="code" href="class_gv2group.html#a12">Do</a>(<a class="code" href="class_gglrendertraversal.html">GglRenderTraversal</a> &amp;state);

//      int Do(GRaySelectTraversal &amp;state);   // in GRaySelect.cpp
//      int Do(GOptimizeTraversal &amp;state);      // implemented in GOptimizeTraversal.cpp


};


//
// Occlusion is a Group node
// that traverses the children only if the viewpoint is outside of  all of the proxy volumes 
// isActive enterTime and exitTimer are notifying similar to a ProximtySensor
// if the viewer enters and exits the proxy Space 

class <a class="code" href="class_gvocclusion.html">GvOcclusion</a> : public <a class="code" href="class_gv2group.html">Gv2Group</a> {

    <a class="code" href="class_gv2group.html#c0">GV_NODE_HEADER</a>(<a class="code" href="class_gvocclusion.html">GvOcclusion</a>);

public:
    // Fields :

    // bboxCenter
    // bboxSize
        <a class="code" href="class_gvsfbool.html">GvSFBool</a>         enabled;         // TRUE, true : enable processing,  behave as Group 
    <a class="code" href="class_gvsfnode.html">GvSFNode</a>     proxy;      // NULL, if viewpoint outside proxy, chilren are not rendered

    // EventOut
    <a class="code" href="class_gvsfbool.html">GvSFBool</a>     isActive;          // are the children currently visible  ?
    <a class="code" href="class_gvsftime.html">GvSFTime</a>     enterTime;             // when children becomes traversed
    <a class="code" href="class_gvsftime.html">GvSFTime</a>     exitTime;              // when children are no longer traversed 


    void <a class="code" href="class_gvsensor.html#a0">setActive</a>(GvBool state) { if (isActive != state) isActive.<a class="code" href="class_gvsfbool.html#a10">set</a>(state); }

        <a class="code" href="class_point.html">Point</a> lastPosition;        // used to minimize position checks 

        // helpers 
        GvBool <a class="code" href="class_gvocclusion.html#a1">isOutside</a>(<a class="code" href="class_gtraversal.html">GTraversal</a> &amp;state, const <a class="code" href="class_point.html">Point</a> &amp;p);
        GvBool <a class="code" href="class_gvocclusion.html#a1">isOutside</a>(<a class="code" href="class_gtraversal.html">GTraversal</a> &amp;state, <a class="code" href="class_gvnode.html">GvNode</a>* proxy,const <a class="code" href="class_point.html">Point</a> &amp;p) const;
        GvBool <a class="code" href="class_gvocclusion.html#a1">isOutside</a>(<a class="code" href="class_gtraversal.html">GTraversal</a> &amp;state, <a class="code" href="class_gvmfnode.html">GvMFNode</a> &amp;proxy,const <a class="code" href="class_point.html">Point</a> &amp;p) const;


        // children

    int <a class="code" href="class_gv2group.html#a12">Do</a>(<a class="code" href="class_gglrendertraversal.html">GglRenderTraversal</a> &amp;state);

        int <a class="code" href="class_gv2group.html#a12">Do</a>(<a class="code" href="class_grayselecttraversal.html">GRaySelectTraversal</a> &amp;state);   // in GRaySelect.cpp

//      int Do(GOptimizeTraversal &amp;state);      // implemented in GOptimizeTraversal.cpp

        GvBool wasRendered; // set to true each time it was reached by  Do(GglRenderTraversal &amp;state);



};

//
// Inclusion is a Group node
// that traverses the children only if the viewpoint is inside of one or more of the proxy volumes 
// isActive enterTime and exitTimer are notifying similar to a ProximitySensor
// if the viewer enters and exits the proxy Space 
// in addition further traversing of the scene graph is aborted, if an inclusion is active

class <a class="code" href="class_gvinclusion.html">GvInclusion</a> : public <a class="code" href="class_gv2group.html">Gv2Group</a> {

    <a class="code" href="class_gv2group.html#c0">GV_NODE_HEADER</a>(<a class="code" href="class_gvinclusion.html">GvInclusion</a>);

public:
    // Fields :

    // bboxCenter
    // bboxSize
        <a class="code" href="class_gvsfbool.html">GvSFBool</a>         enabled;               // TRUE, true : enable processing,  behave as Group 
    <a class="code" href="class_gvsfnode.html">GvSFNode</a>     proxy;                 // NULL, if viewpoint outside proxy, chilren are not rendered

        <a class="code" href="class_gvmfnode.html">GvMFNode</a>         portals;               // list of portals or doors

    // EventOut
    <a class="code" href="class_gvsfbool.html">GvSFBool</a>     isActive;          // are the children currently visible  ?
    <a class="code" href="class_gvsftime.html">GvSFTime</a>     enterTime;             // when children becomes traversed
    <a class="code" href="class_gvsftime.html">GvSFTime</a>     exitTime;              // when children are no longer traversed 


    <a class="code" href="class_gvsfbool.html">GvSFBool</a>     isInside;          // user is inside ?

    void <a class="code" href="class_gvsensor.html#a0">setActive</a>(GvBool state) 
        { 
                if (isActive != state) isActive.<a class="code" href="class_gvsfbool.html#a10">set</a>(state); 
        }

    void <a class="code" href="class_gvinclusion.html#a1">setInside</a>(GvBool state) 
        { 
                if (isInside != state) isInside.<a class="code" href="class_gvsfbool.html#a10">set</a>(state); 
        }


        <a class="code" href="class_point.html">Point</a> lastPosition;        // used to minimize position checks 

        // helpers 
        GvBool <a class="code" href="class_gvinclusion.html#a2">isPointInside</a>(<a class="code" href="class_gtraversal.html">GTraversal</a> &amp;state, const <a class="code" href="class_point.html">Point</a> &amp;p);
        GvBool <a class="code" href="class_gvinclusion.html#a2">isPointInside</a>(<a class="code" href="class_gtraversal.html">GTraversal</a> &amp;state, <a class="code" href="class_gvnode.html">GvNode</a>* proxy,const <a class="code" href="class_point.html">Point</a> &amp;p) const;
        GvBool <a class="code" href="class_gvinclusion.html#a2">isPointInside</a>(<a class="code" href="class_gtraversal.html">GTraversal</a> &amp;state, <a class="code" href="class_gvmfnode.html">GvMFNode</a> &amp;proxy,const <a class="code" href="class_point.html">Point</a> &amp;p) const;

        GvBool <a class="code" href="class_gvinclusion.html#a5">anyPortalOpen</a>(<a class="code" href="class_ggeometrytraversal.html">GGeometryTraversal</a> &amp;state);
        GvBool <a class="code" href="class_gvinclusion.html#a6">isNodeVisible</a>(<a class="code" href="class_ggeometrytraversal.html">GGeometryTraversal</a> &amp;state, <a class="code" href="class_gvnode.html">GvNode</a>* proxy);
        GvBool <a class="code" href="class_gvinclusion.html#a6">isNodeVisible</a>(<a class="code" href="class_ggeometrytraversal.html">GGeometryTraversal</a> &amp;state, <a class="code" href="class_gvmfnode.html">GvMFNode</a> &amp;proxy);
        GvBool <a class="code" href="class_gvinclusion.html#a8">isBBoxVisible</a>(<a class="code" href="class_ggeometrytraversal.html">GGeometryTraversal</a> &amp;state, <a class="code" href="class_bbox.html">BBox</a> &amp;proxy);


        GvBool wasRendered; // set to true each time it was reached by  Do(GglRenderTraversal &amp;state);

        // children

    int <a class="code" href="class_gv2group.html#a12">Do</a>(<a class="code" href="class_gglrendertraversal.html">GglRenderTraversal</a> &amp;state);

        int <a class="code" href="class_gv2group.html#a12">Do</a>(<a class="code" href="class_grayselecttraversal.html">GRaySelectTraversal</a> &amp;state);   // in GRaySelect.cpp

//      int Do(GOptimizeTraversal &amp;state);      // implemented in GOptimizeTraversal.cpp


};

class <a class="code" href="class_pointi.html">Pointi</a> 
{
public:
        int x,y,z;
        <a class="code" href="class_pointi.html#a0">Pointi</a>(int x_=0,int y_=0,int z_=0) : x(x_),y(y_),z(z_) {}
        <a class="code" href="class_pointi.html#a0">Pointi</a>(const <a class="code" href="class_pointi.html">Pointi</a> &amp;p) : x(p.x),y(p.y),z(p.z) {}

        friend int operator&lt; (const <a class="code" href="class_pointi.html">Pointi</a>&amp; A, const <a class="code" href="class_pointi.html">Pointi</a>&amp; B);

        friend int operator== (const <a class="code" href="class_pointi.html">Pointi</a>&amp; A, const <a class="code" href="class_pointi.html">Pointi</a>&amp; B);
        friend int operator!= (const <a class="code" href="class_pointi.html">Pointi</a>&amp; A, const <a class="code" href="class_pointi.html">Pointi</a>&amp; B);

};

inline int operator&lt; (const <a class="code" href="class_pointi.html">Pointi</a>&amp; A, const <a class="code" href="class_pointi.html">Pointi</a>&amp; B)
{
        return A.x &lt; B.x &amp;&amp; A.y &lt; B.y &amp;&amp; A.z &lt; B.z;
}

inline int operator== (const <a class="code" href="class_pointi.html">Pointi</a>&amp; A, const <a class="code" href="class_pointi.html">Pointi</a>&amp; B)
{
        return (A.x == B.x) &amp;&amp; (A.y == B.y) &amp;&amp; (A.z == B.z);
}

inline int operator!= (const <a class="code" href="class_pointi.html">Pointi</a>&amp; A, const <a class="code" href="class_pointi.html">Pointi</a>&amp; B)
{
        return !(A == B);
}



class <a class="code" href="class_gtileentry.html">GTileEntry</a> {
public : 
        <a class="code" href="class_pointi.html">Pointi</a> coord;   // the logical coordinate
        <a class="code" href="class_gvnodehandle.html">GvNodeHandle</a> node;
        BOOL inScene;  // entry is instanced in SceneGraph
        <a class="code" href="class_gtileentry.html#a0">GTileEntry</a>(const <a class="code" href="class_pointi.html">Pointi</a> c) : coord(c), inScene(FALSE) {}

};

class <a class="code" href="class_gvmetaverse.html">GvMetaverse</a> : public <a class="code" href="class_gv2group.html">Gv2Group</a> {

    <a class="code" href="class_gv2group.html#c0">GV_NODE_HEADER</a>(<a class="code" href="class_gvmetaverse.html">GvMetaverse</a>);

public:
    // Fields :

    // bboxCenter
    // bboxSize
        //GvSFBool       enabled;         // TRUE, true : enable processing,  behave as Group 

        <a class="code" href="class_gvsfvec3f.html">GvSFVec3f</a>        start;
        <a class="code" href="class_gvsfvec3f.html">GvSFVec3f</a>        end;
        <a class="code" href="class_gvsfvec3f.html">GvSFVec3f</a>        spacing;
        <a class="code" href="class_gvmfstring.html">GvMFString</a>       urlPrefix;


        <a class="code" href="class_gvsfnode.html">GvSFNode</a>     proxy;      

        BOOL            initialized;

        <a class="code" href="class_pointi.html">Pointi</a>          currentTile;

        
        <a class="code" href="class_array.html">Array</a>&lt;<a class="code" href="class_gtileentry.html">GTileEntry</a> *&gt; tileCache;

        // store entry in cache
        void <a class="code" href="class_gvmetaverse.html#a0">putCache</a>(<a class="code" href="class_gtileentry.html">GTileEntry</a> *entry);
        
        // find entry in cache
        <a class="code" href="class_gtileentry.html">GTileEntry</a> *<a class="code" href="class_gvmetaverse.html#a1">getCache</a>(<a class="code" href="class_pointi.html">Pointi</a> coord);

        // flush 
        void <a class="code" href="class_gvmetaverse.html#a2">FlushAll</a>();

        // generate the scene graph for coordinate
        <a class="code" href="class_gvnode.html">GvNode</a> *<a class="code" href="class_gvmetaverse.html#a3">generateTileNode</a>(<a class="code" href="class_pointi.html">Pointi</a> coord);

        // map world position to tile coordinate
        // FALSE if outside the range
        BOOL <a class="code" href="class_gvmetaverse.html#a4">computeTileCoord</a>(const <a class="code" href="class_point.html">Point</a> &amp;p,<a class="code" href="class_pointi.html">Pointi</a> &amp;coord);

        // get the Inline url field     
        void <a class="code" href="class_gvmetaverse.html#a5">generateTileUrl</a>(<a class="code" href="class_pointi.html">Pointi</a> coord,<a class="code" href="class_gvmfstring.html">GvMFString</a> &amp;url);

        // add the tile node to the scene graph
        BOOL <a class="code" href="class_gvmetaverse.html#a6">addTileNode</a>(<a class="code" href="class_gtileentry.html">GTileEntry</a> *entry);
        
        // remove the tile node to the scene graph
        void <a class="code" href="class_gvmetaverse.html#a7">removeTileNode</a>(<a class="code" href="class_gtileentry.html">GTileEntry</a> *entry);


    // EventOut
    //GvSFBool   isActive;          // are the children currently visible  ?
    //GvSFTime     enterTime;           // when children becomes traversed
    //GvSFTime     exitTime;            // when children are no longer traversed 

    int <a class="code" href="class_gv2group.html#a12">Do</a>(<a class="code" href="class_gglrendertraversal.html">GglRenderTraversal</a> &amp;state);
    int <a class="code" href="class_gv2group.html#a12">Do</a>(<a class="code" href="class_grayselecttraversal.html">GRaySelectTraversal</a> &amp;state);  

        //int Do(GLoadInlinesTraversal &amp;state);

};



#endif // _GvBsp_h_
</div></pre><hr><address><small>Generated at Thu Jan 27 18:48:48 2000 for blaxxunContact3D by
<a href="http://www.stack.nl/~dimitri/doxygen/index.html">
<img src="doxygen.gif" alt="doxygen" align=center border=0 
width=118 height=53></a> 1.0.0 written by <a href="mailto:dimitri@stack.nl">Dimitri van Heesch</a>,
 &copy; 1997-1999</small></address>
</body>
</html>

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta name="robots" content="noindex">
<title>CGLViewCtrlCtrl Include File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body bgcolor="#ffffff">
<!-- Generated by Doxygen 1.0.0 on Thu Jan 27 18:16:00 2000 -->
<center>
<a class="qindex"href="index.html">Main Page</a> &nbsp; <a class="qindex"href="namespaces.html">Namespace List</a> &nbsp; <a class="qindex"href="hierarchy.html">Class Hierarchy</a> &nbsp; <a class="qindex"href="annotated.html">Compound List</a> &nbsp; <a class="qindex"href="files.html">File List</a> &nbsp; <a class="qindex"href="headers.html">Header Files</a> &nbsp; <a class="qindex"href="namespacemembers.html">Namespace Members</a> &nbsp; <a class="qindex"href="functions.html">Compound Members</a> &nbsp; <a class="qindex"href="globals.html">File Members</a> &nbsp; </center>
<hr><h1>blaxxuncc3dctl.h</h1>This is the verbatim text of the blaxxuncc3dctl.h include file.<div class="fragment"><pre>/*=============================================================================

This code is licensed under the Web3D-blaxxun Community Source License,
provided in distribution file LICENSE.TXT and available online at
http://www.web3D.org/TaskGroups/x3d/blaxxun/Web3D-blaxxunCommunitySourceAgreement.html
and may only be used for non-commercial use as specified in that license.

THE WEB3D CONSORTIUM AND BLAXXUN DO NOT MAKE AND HEREBY DISCLAIM ANY EXPRESS
OR IMPLIED WARRANTIES RELATING TO THIS CODE, INCLUDING BUT NOT LIMITED TO,
WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY OR FITNESS FOR A PARTICULAR
PURPOSE, OR ANY WARRANTIES THAT MIGHT ARISE FROM A COURSE OF DEALING, USAGE
OR TRADE PRACTICE.  THE COMMUNITY SOURCE CODE IS PROVIDED UNDER THIS
AGREEMENT "AS IS," WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
INCLUDING, WITHOUT LIMITATION, WARRANTIES THAT THE COMMUNITY SOURCE CODE ARE
FREE OF DEFECTS, MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE OR
NON-INFRINGING OR IN ANY WAY CONSTITUTE THE COMPLETE PRODUCT MARKETED UNDER
THE NAMES GIVEN SAID CODE.

==============================================================================*/
// GLViewCtrlCtl.h : Declaration of the CGLViewCtrlCtrl OLE control class.
// $Revision: 1.42 $
// $Log: blaxxuncc3dctl.h,v $
// Revision 1.42  1998/10/30 13:40:25  tom
// shift-taste
//
// Revision 1.41  1998/10/29 18:07:42  holger
// empty message
//
// Revision 1.40  1998/10/07 13:38:55  tom
// *** empty log message ***
//
// Revision 1.39  1998/09/28 15:20:37  tom
// support of embed and param tags for navpanel
//
// Revision 1.38  1998/09/22 16:45:50  holger
// empty message
//
// Revision 1.37  1998/09/21 16:44:45  tom
// *** empty log message ***
//
// Revision 1.35  1998/08/12 13:17:54  tom
// *** empty log message ***
//
// Revision 1.34  1998/08/11 09:44:57  tom
// *** empty log message ***
//
// Revision 1.33  1998/07/30 16:32:42  thilo
// *** empty log message ***
//
// Revision 1.32  1998/07/30 12:37:31  tom
// erste versuche mit navpanel.
//
// Revision 1.31  1998/07/14 17:25:26  kristof
// *** empty log message ***
//
// Revision 1.30  1998/07/06 17:42:15  holger
// empty message
//
// Revision 1.8  1997/11/24 14:00:26  rainer
// Holgers changes
//



#ifdef _OGL
#include "COpenGL.h"
#endif

#include "dispids.h"
#include "ArrayNew.h"


// OLE_DATAPATH + GUID for interesting MIME-Types
// #include "datapath.h"
typedef BSTR OLE_DATAPATH;


// Forward classes
class <a class="code" href="class_gview.html">GView</a>;            
class <a class="code" href="class_cglviewctrlapp.html">CGLViewCtrlApp</a>; 
class <a class="code" href="class_crenderthread.html">CRenderThread</a>;
class COpenGL;
class <a class="code" href="class_gfile.html">GFile</a>;
class <a class="code" href="class_greporter.html">GReporter</a>;

class <a class="code" href="class_gdriverhints.html">GDriverHints</a>;

// dialog classes
class   <a class="code" href="class_daskhardware.html">DAskHardware</a>;
class   <a class="code" href="class_dconsole.html">DConsole</a>;


// redefine VIEW class for GLView core compatibility
#define CMyglView CGLViewCtrlCtrl

class <a class="code" href="class_cglviewctrlctrl.html">CGLViewCtrlCtrl</a>;
class CCtrlReporter;

class <a class="code" href="class_gvmfstring.html">GvMFString</a>;
class <a class="code" href="class_gvnode.html">GvNode</a>;


/*

class CGlViewDataPathProperty : public CDataPathProperty
{
        void OnStartBinding( );
        void OnStopBinding( HRESULT hresult, LPCTSTR szError );

        void OnDataAvailable( DWORD dwsize, DWORD bscfFlag );
  

};

*/



// Cursor modes 
enum CursorMode {
        STANDARD_CURSOR,
        STANDARD_LOADING_CURSOR,
        NAVIGATION_CURSOR,
        COLLISION_CURSOR,
        TRANSFORM_CURSOR,
        MOVING_CURSOR, // for fly state 2 
        ZOOM_CURSOR, // for fly state 2 

        SENSOR_CURSOR,
        ANCHOR_CURSOR,
};

// Cursor modes 
enum NavCursorMode {
        NAV_NONE,
        NAV_WALK,
        NAV_SLIDE,
        NAV_ROTATE,
        NAV_EXAMINE,
        NAV_FLY,
        NAV_WALK_ROT,
        NAV_WALK_SLIDE,
        NAV_WALK_ROT_SLIDE,
        NAV_ROT_SLIDE,
        NAV_SLIDE_ROT,
        NAV_EXA_SLIDE,
        NAV_JUMP_TO,
        NAV_FOLLOW,
        NAV_ANCHOR,
        NAV_NONE_SENSOR,
        NAV_WALK_SENSOR,
        NAV_SLIDE_SENSOR,
        NAV_ROTATE_SENSOR,
        NAV_EXAMINE_SENSOR,
        NAV_FLY_SENSOR,
        NAV_ANCHOR_SENSOR,
        NAV_PANEL_CURSOR,
        NAV_PAN,
        NAV_COLLISION,
        NAV_NO_CURSOR,
        NAV_CURSOR_MAX,
};

//
enum UIMode {
                UI_NONE,
                UI_SIMPLE,
//              UI_STANDARD,
                UI_EXPERT
};      


//
// CTranslator
// translates messages 
//
#include &lt;fstream.h&gt;

class <a class="code" href="class_ctranslator.html">CTranslator</a> {
public:
        <a class="code" href="class_ctranslator.html#a4">CTranslator</a>();
        <a class="code" href="class_ctranslator.html#a5">~CTranslator</a>();
        // translate unique string into language denpendent string, entryDefault is the default english string
        BOOL <a class="code" href="class_ctranslator.html#a2">Translate</a>(LPCTSTR key,LPCTSTR valueDefault, CString&amp; value);
        BOOL <a class="code" href="class_ctranslator.html#a3">Lookup</a>(LPCTSTR key,CString&amp; value);
        
protected:
#ifdef _DEBUG
        //ofstream out;
#endif

        <a class="code" href="class_cwinapp.html">CWinApp</a>*                        m_pApp;                 
        CString                         m_section;              
        CMapStringToString  m_hashTable;        
};

#include "gviewcontrol.h"

// CGLViewCtrlCtrl : See GLViewCtrlCtl.cpp for implementation.

class <a class="code" href="class_cglviewctrlctrl.html">CGLViewCtrlCtrl</a> : 
        
        public <a class="code" href="class_colecontrol.html">COleControl</a>
        , public <a class="code" href="class_gviewcontroller.html">GViewController</a>

{
        <a class="code" href="class_cglviewctrlctrl.html#c0">DECLARE_DYNCREATE</a>(<a class="code" href="class_cglviewctrlctrl.html">CGLViewCtrlCtrl</a>)

// Constructor
public:
        //CGLViewCtrlCtrl();
        <a class="code" href="src_dprop.h.html#a1">CGLViewCtrlCtrl</a>();


        // Netscape thread dialog handling
        UINT DoThreadModal(<a class="code" href="class_cdialog.html">CDialog</a>* dialog, UINT timeout=60000, BOOL menu=FALSE);
        UINT DoThreadModal(CMenu* menu, POINT* menuPos, CWnd* parent);
        void DoThreadModalUpdateMenu(CMenu* menu); 
        BOOL m_threadFinished;
        <a class="code" href="class_cwinthread.html">CWinThread</a>* m_pt;
        <a class="code" href="class_cdialog.html">CDialog</a>*        m_pd;
        
        BOOL IsModalThreadActive() { return (m_threadFinished)? FALSE: TRUE; }


        // overrides 
        virtual void <a class="code" href="class_cglviewctrlctrl.html#c1">SetInitialDataFormats</a>();

        // For customizing the default messages on the status bar
        virtual void <a class="code" href="class_cglviewctrlctrl.html#c2">GetMessageString</a>(UINT nID, CString&amp; rMessage) const;


        // @cmember GView objects contains the renderState and model information
        <a class="code" href="class_gview.html">GView</a>   *view;

        <a class="code" href="class_ctranslator.html">CTranslator</a> m_translator;

        // translate a message 
        BOOL <a class="code" href="class_cglviewctrlctrl.html#c3">Translate</a>(LPCTSTR key,LPCTSTR valueDefault, CString&amp; value);
        BOOL <a class="code" href="class_cglviewctrlctrl.html#c3">Translate</a>(LPCTSTR valueDefault, CString&amp; value);
        BOOL <a class="code" href="class_cglviewctrlctrl.html#c5">TranslateMessageString</a>(UINT nID, CString&amp; value);
        CString <a class="code" href="class_cglviewctrlctrl.html#c3">Translate</a>(LPCTSTR valueDefault) { CString value; <a class="code" href="class_cglviewctrlctrl.html#c3">Translate</a>(valueDefault,value); return value; }
        
        // Translate a CMenu
        void <a class="code" href="class_cglviewctrlctrl.html#c3">Translate</a>(CMenu &amp;m); 
        void <a class="code" href="class_cglviewctrlctrl.html#c3">Translate</a>(<a class="code" href="class_cpropertysheet.html">CPropertySheet</a> &amp;ps);



        // the initial context url to be loaded 
        CString m_initialUrl;   // the initial URL

        CString m_initialAvatarUrl;     
        BOOL    m_initialThirdPersonView; 

        CString m_messageUrl;
        CString m_messageTargetFrame;


        UIMode m_uiMode;

        BOOL    m_fullscreenOnStartup;
        CString m_fullscreenModeOnStartup;

        BOOL    m_hideCursor;             
        BOOL    m_displayFrameRate;      
        BOOL    m_displayFrameStats;
        DWORD   m_frames;                       
        DWORD   m_checkFrames;          
        DWORD   m_startTime;            
        DWORD   m_endTime;                      


        BOOL    m_mustRedraw;   
        CRect   m_clientRect;   
        BOOL    m_useRenderThread;  

        <a class="code" href="class_crenderthread.html">CRenderThread</a> * m_renderThread; 

        int             m_requestedState;
        int             m_currentState;

//#define TLS_BROWSER 1
//#define TLS_REDRAW 2

#define RUN_STATE 1
#define STOP_STATE 2

        CRITICAL_SECTION m_sceneSection;  
        
        void <a class="code" href="class_cglviewctrlctrl.html#c9">LockScene</a>();
        void <a class="code" href="class_cglviewctrlctrl.html#c10">UnlockScene</a>();
        UINT <a class="code" href="class_cglviewctrlctrl.html#c11">RenderWorker</a>();
        BOOL <a class="code" href="class_cglviewctrlctrl.html#c12">StartRenderThread</a>();
        void <a class="code" href="class_cglviewctrlctrl.html#c13">StopRenderThread</a>();







        // window is minimized, no activity necessary
        BOOL m_minimized;

        BOOL m_menuActive; 
    // expired flag 
    BOOL expired;

    // check for expiration
    BOOL <a class="code" href="class_cglviewctrlctrl.html#c14">Expired</a>() { return(FALSE); }
        
        void <a class="code" href="class_cglviewctrlctrl.html#c15">SetAnimateOff</a>() {}

    // last status messge    
    CString lastMessage;

    // type of last status message
    int lastMessageType;

    // counter to skip some onIdles
    int m_idleCounter;

    //@cmember displays a message to the status bar with update
    void <a class="code" href="class_gviewcontroller.html#a0">Message</a>(const char *message,int messageType = 0);


        void <a class="code" href="class_gviewcontroller.html#a1">Print</a>(const char *message);

        int <a class="code" href="class_gviewcontroller.html#a2">GetLastMessageType</a>() { return lastMessageType; }

        const CString&amp; <a class="code" href="class_gviewcontroller.html#a3">GetLastMessage</a>() { return lastMessage; }


        // registry helpers
    BOOL <a class="code" href="class_gviewcontroller.html#a11">GetProfile</a>(LPCTSTR lpszKey, CString &amp;value);
        BOOL <a class="code" href="class_gviewcontroller.html#a11">GetProfile</a>(LPCTSTR lpszKey, int &amp;value);

        BOOL <a class="code" href="class_cglviewctrlctrl.html#c22">SetProfile</a>(LPCTSTR lpszKey, LPCTSTR value);
        BOOL <a class="code" href="class_cglviewctrlctrl.html#c22">SetProfile</a>(LPCTSTR lpszKey, int value);


        int lastCursorMode; 

        // set the cursor mode depending on action 
        void <a class="code" href="class_cglviewctrlctrl.html#c24">SetCursorMode</a>(int cursorMode);

        int <a class="code" href="class_cglviewctrlctrl.html#c25">GetCursorMode</a>()const { return lastCursorMode; }

        BOOL m_collisionState; 

        // set state, if user currently is in collision during movement
        void <a class="code" href="class_cglviewctrlctrl.html#c26">SetCollisionState</a>(BOOL newState);

        
        HCURSOR NavCursors[NAV_CURSOR_MAX]; 
        
        HCURSOR hCurrentCursor; 



        void <a class="code" href="class_gviewcontroller.html#a5">Redraw</a>();


        int updateLock;

        void <a class="code" href="class_cglviewctrlctrl.html#c28">BeginUpdate</a>();
        void <a class="code" href="class_cglviewctrlctrl.html#c29">EndUpdate</a>();


        // initiialized ?? 
        
        BOOL m_initialized;
        CDC     *m_pDC;

        BOOL m_enableInteraction; 

        
        // initialize associated view &amp; graphics 

        BOOL <a class="code" href="class_cglviewctrlctrl.html#c30">Initialize</a>(HDC hDC);

        // flags 
        BOOL              m_fullSpeed; 
        BOOL              m_verbose;   


        BOOL              m_askHardware; 
        BOOL              m_saveDriverSettings;         

        BOOL              m_forceHwProblemCheck; // do a check on crash for switch back to software rendering
        <a class="code" href="class_gdriverhints.html">GDriverHints</a>  *m_driverHints; // driver hints for device selection
        
        // dialogs 
        <a class="code" href="class_daskhardware.html">DAskHardware</a> *m_dAskHardware;
        <a class="code" href="class_dconsole.html">DConsole</a>         *m_dConsole;
        <a class="code" href="class_cpropertysheet.html">CPropertySheet</a>   *m_dPad; 

        // close all the opened dialogs
        void <a class="code" href="class_cglviewctrlctrl.html#c31">CloseAllDialogs</a>();


        void <a class="code" href="class_cglviewctrlctrl.html#c32">SaveDriverSettings</a>();

        CCtrlReporter *m_reporter; 

        <a class="code" href="class_greporter.html">GReporter</a> *<a class="code" href="class_gviewcontroller.html#a4">GetReporter</a>(); 

        <a class="code" href="class_cglviewctrlapp.html">CGLViewCtrlApp</a> * <a class="code" href="class_cglviewctrlctrl.html#c34">GetApp</a>() { return ((<a class="code" href="class_cglviewctrlapp.html">CGLViewCtrlApp</a> *) AfxGetApp());  }

        
        int <a class="code" href="class_gviewcontroller.html#a7">SetCameraMode</a>(int newMode);

        // get current viewer mode 
        int <a class="code" href="class_cglviewctrlctrl.html#c36">GetCameraMode</a>();

        int <a class="code" href="class_gviewcontroller.html#a7">SetCameraMode</a>(const char *mode);

        const char *<a class="code" href="class_gviewcontroller.html#a9">GetCameraModeString</a>(int mode);
        
        const char* <a class="code" href="class_gviewcontroller.html#a9">GetCameraModeString</a>();


        void <a class="code" href="class_cglviewctrlctrl.html#c40">ResetMove</a>();



        // do animation 
        BOOL <a class="code" href="class_cglviewctrlctrl.html#c41">OnIdle</a>(LONG lcount);

        // timer is running 
        BOOL m_timerRunning;

        // interval for SetTimer 
        long m_timerInterval;

        int m_timerCnt; 
        int m_timerTimeSensorCycle; 


        void <a class="code" href="class_cglviewctrlctrl.html#c42">StartTimer</a>();
        
        void <a class="code" href="class_cglviewctrlctrl.html#c43">RestartTimer</a>();

        void <a class="code" href="class_cglviewctrlctrl.html#c44">StopTimer</a>();

        // navigation state variables 

        // mode started at LButton Down
        int m_lButtonMode;


        // current mode for mouse moves
    int         m_currentMode;

        // current mode for camera mouse moves
        int             m_currentCameraMode;
        int             m_cameraModeOld;

        float   m_cameraSpeed;   
        float   m_cameraSpeedRot;   
        int             m_cameraSpeedFac;   

        // set the camera relative move flag, if TRUE walk direction using viewdirection, FALSE relative to worlds up vector
        BOOL    <a class="code" href="class_cglviewctrlctrl.html#c45">SetCameraRelativeMode</a>(BOOL newMode) { m_cameraRelative = newMode; return m_cameraRelative; }
        BOOL    <a class="code" href="class_cglviewctrlctrl.html#c46">GetCameraRelativeMode</a>() {return m_cameraRelative; }

        BOOL    m_cameraRelative; 

        // do anchor, sensor checking on Camera Modes lButtonDown
        BOOL    m_sensorTest;
        BOOL    m_anchorSingleClick; 
        <a class="code" href="class_gvnode.html">GvNode</a>* m_currentAnchor; 
        BOOL    m_currentTSensor; 
        BOOL    m_currentTDragSensor; 

        BOOL    m_handleWrlIntern; 

   
        UINT    m_moveTimerId;

        // the windows timer ID for the MoveTimer 
        int MOVE_TIMER_ID;

        int             fly_state;                      

        BOOL    m_moveRepeat;                   
        float   m_moveRepeatStartTime; 
        float   m_moveRepeatCycleTime; 

        // Mouse data at left button down time
        CPoint  m_firstPoint;
        UINT    m_firstFlags;
        float   m_firstTime;

        // Mouse data at last mouse move 

        CPoint  m_lastPoint;
        UINT    m_lastFlags;
        float   m_lastTime;
        BOOL    m_wasDrag; 
        int             m_dragEps; 


        CPoint  m_prevLastPoint;


    // last rbutton point for SeekTo in Popup-menu
    CPoint      m_rlastPoint;
    UINT        m_rlastFlags;


//----------------------------------------------------------------------------------
        
        // start Navigation timer
        void <a class="code" href="class_cglviewctrlctrl.html#c47">NavStartTimer</a>();
        // stop Navigation timer
        void <a class="code" href="class_cglviewctrlctrl.html#c48">NavStopTimer</a>();
        

        // navigation controls
        void <a class="code" href="class_cglviewctrlctrl.html#c49">NavStart</a>();
        void <a class="code" href="class_cglviewctrlctrl.html#c50">NavBeamTo</a>(POINT mousepos);
        void <a class="code" href="class_cglviewctrlctrl.html#c51">NavEnd</a>();
        void <a class="code" href="class_cglviewctrlctrl.html#c52">NavGo</a>();
        void <a class="code" href="class_cglviewctrlctrl.html#c53">NavMain</a>();
        void <a class="code" href="class_cglviewctrlctrl.html#c54">NavWalk</a>(<a class="code" href="class_point.html">Point</a> vec);
        void <a class="code" href="class_cglviewctrlctrl.html#c55">NavPan</a>(<a class="code" href="class_point.html">Point</a> vec3);  
        
        void <a class="code" href="class_cglviewctrlctrl.html#c56">NavMove</a>(<a class="code" href="class_point.html">Point</a> vec);
        void <a class="code" href="class_cglviewctrlctrl.html#c57">NavRotate</a>(<a class="code" href="class_point.html">Point</a> vec);
        void <a class="code" href="class_cglviewctrlctrl.html#c58">NavExamine</a>(<a class="code" href="class_point.html">Point</a> vec);
        void <a class="code" href="class_cglviewctrlctrl.html#c59">NavFly</a>(<a class="code" href="class_point.html">Point</a> vec);
        void <a class="code" href="class_cglviewctrlctrl.html#c60">NavJumpTo</a>(<a class="code" href="class_point.html">Point</a> vec3);


        void <a class="code" href="class_cglviewctrlctrl.html#c61">NavCheckCollision</a>(<a class="code" href="class_point.html">Point</a> oldPosition, BOOL rotate, BOOL slide,BOOL ground);
        void <a class="code" href="class_cglviewctrlctrl.html#c62">NavCheckStayOnGround</a>();
        void <a class="code" href="class_cglviewctrlctrl.html#c63">NavCollisionGround</a>(<a class="code" href="class_point.html">Point</a> oldPosition);
        void <a class="code" href="class_cglviewctrlctrl.html#c64">NavForceStayOnGround</a>();
        void <a class="code" href="class_cglviewctrlctrl.html#c65">NavCameraFixToPoint</a>();
        void <a class="code" href="class_cglviewctrlctrl.html#c66">NavStraightenUp</a>();
        int  <a class="code" href="class_cglviewctrlctrl.html#c67">NavCheckKeyState</a>(BOOL checkAnchor=TRUE);
        void <a class="code" href="class_cglviewctrlctrl.html#c68">NavCheckCursor</a>(BOOL checkAnchor=TRUE);
        void <a class="code" href="class_cglviewctrlctrl.html#c69">NavResetFollowObject</a>();
        void <a class="code" href="class_cglviewctrlctrl.html#c70">NavResetCursorBlinking</a>();

        void <a class="code" href="class_cglviewctrlctrl.html#c71">NavCalculateTile</a>(<a class="code" href="class_point.html">Point</a> *ptile);

        // navigation interpolators
        BOOL <a class="code" href="class_cglviewctrlctrl.html#c72">NavStartMotionIP</a>(<a class="code" href="class_point.html">Point</a> p, int steps);
        BOOL <a class="code" href="class_cglviewctrlctrl.html#c73">NavStartGravityIP</a>(int steps);
        BOOL <a class="code" href="class_cglviewctrlctrl.html#c74">NavStartRotPIP</a>(<a class="code" href="class_point.html">Point</a> p, int steps);
        BOOL <a class="code" href="class_cglviewctrlctrl.html#c75">NavStartRotVIP</a>();
        void <a class="code" href="class_cglviewctrlctrl.html#c76">NavStopIP</a>(int ip);

        void <a class="code" href="class_cglviewctrlctrl.html#c77">NavStepMotionIP</a>();
        void <a class="code" href="class_cglviewctrlctrl.html#c78">NavStepGravityIP</a>();
        void <a class="code" href="class_cglviewctrlctrl.html#c79">NavStepRotPIP</a>();
        void <a class="code" href="class_cglviewctrlctrl.html#c80">NavStepRotVIP</a>();

        void <a class="code" href="class_cglviewctrlctrl.html#c81">NavBalanceCamera</a>();

//----------------------------------------------------------------------------------

        // Navigation control variables
//----------------------------------------------------------------------------
#define NAV_MOTION_IP  1
#define NAV_ROT_P_IP   2
#define NAV_ROT_V_IP   4
#define NAV_GRAVITY_IP 8

SYSTEMTIME              m_NavTime;                      

float                   m_NavSpeed;                     
float                   m_NavSpeedRot;          

float                   m_NavSpeed_step;                
float                   m_NavSpeedRot_step;             

BOOL                    m_NavFocus;

BOOL                    m_NavOldSlideState;     
BOOL                    m_NavCNTLState;         
BOOL                    m_NavSlideState;        
BOOL                    m_NavFollowState;       
BOOL                    m_NavSpeedState;        
BOOL                    m_NavRotState;          
BOOL                    m_NavPointState;        
BOOL                    m_NavUPState;           
BOOL                    m_NavDOWNState;         
BOOL                    m_NavLEFTState;         
BOOL                    m_NavRIGHTState;        

BOOL                    m_NavSlideStatePanel;
BOOL                    m_NavUPStatePanel;              
BOOL                    m_NavDOWNStatePanel;    
BOOL                    m_NavLEFTStatePanel;            
BOOL                    m_NavRIGHTStatePanel;

BOOL                    m_NavLBUTState;         

BOOL                    m_NavGravityChecked;    

int                             m_NavRunning;           


BOOL                    m_NavFollowObject;

BOOL                    m_NavCoordDspl;         
BOOL                    m_NavNotActive;

BOOL                    m_NavMotion;            
BOOL                    m_NavTimerRunning;      
int                             m_NavTimerCnt;          
int                             m_NavTimerCnt_1;                
int                             m_NavCursorBlkCount;    
BOOL                    m_NavCursorShow;                
int                             m_NavCursorMode;
int                             m_NavCursorModeOld;

BOOL                    m_NavIPTimerRunning;    
long                    m_NavIPTimerInterval;   

POINT                   m_NavMousePos;                  
RECT                    m_NavClientRect;                
BOOL                    m_NavIsWithinRect;              

struct Vec3l
        {
        long            x;
        long            y;
        long            z;
        };                                                                                                                                                                                                                              


struct Camera
        {
        <a class="code" href="class_point.html">Point</a>   FixPoint;                       
        <a class="code" href="class_point.html">Point</a>   FixPointLocal;          
        BOOL    FixPointValid;          
        <a class="code" href="class_point.html">Point</a>   DefLookAt;                      
        <a class="code" href="class_point.html">Point</a>   DefLookUp;                      
        <a class="code" href="class_point.html">Point</a>   DefLookRight;
        <a class="code" href="class_point.html">Point</a>   DefPosition;            
        <a class="code" href="class_point.html">Point</a>   LookAt;                         
        <a class="code" href="class_point.html">Point</a>   LookUp;
        <a class="code" href="class_point.html">Point</a>   LookRight;
        float   LASpeed;                        
        float   LUSpeed;                        
        float   LRSpeed;                        
        float   CRotSpeed;                      
        <a class="code" href="class_point.html">Point</a>   HeadRot;                        
        float   HRotSpeed;                      
        float   SpeedDouble;            
        float   DoubleSpeed;            
        float   SpeedAcc;                       
        BOOL    BackTurn;                       
        BOOL    ForceAction;            
        };

Camera                  m_NavCamera;    


// structure for Motion Interpolator
struct  m_NavMotIP
        {
        <a class="code" href="class_point.html">Point</a>   StartPoint;                     
        <a class="code" href="class_point.html">Point</a>   EndPoint;                       
        int             Steps;                          
        int             CurStep;                        
        int             StopWhere;                      



        int             StopPercentage;         
        };


m_NavMotIP              m_NavMotionIP;

// structure for Gravity Interpolator
struct  m_NavGravIP
        {
        <a class="code" href="class_point.html">Point</a>   StartPoint;                     // Start point of motion (Start camera position)
        <a class="code" href="class_point.html">Point</a>   EndPoint;                       
        int             Steps;                          
        int             CurStep;                        
        };


m_NavGravIP             m_NavGravityIP;


// structure for Rotation to a Point Interpolator
struct  m_NavRotPIP
        {
        <a class="code" href="class_point.html">Point</a>   StartPoint;                     
        <a class="code" href="class_point.html">Point</a>   EndPoint;                       
        int             Steps;                          
        int             CurStep;                        
        };

m_NavRotPIP             m_NavRotPointIP;



// structure for Rotation to a Stand up position Interpolator
struct  m_NavRotVIP
        {
        int             Start;                          
        float   Angle;                          
        int             Steps;                          
        int             CurStep;                        
        };

m_NavRotVIP             m_NavRotVecIP;


        int             m_NavIPActive;          



        float   m_NavTargetDist;        


struct  NavCollision
        {
        BOOL    LastCollision;          
        <a class="code" href="class_point.html">Point</a>   LastNormal;                     
        <a class="code" href="class_point.html">Point</a>   LastUp;                         
        };

        NavCollision    m_NavCollision;


        POINT   m_NavMouseDiff;         



//----------------------------------------------------------------------------



        // do the mouse move, based on current mouse position in point 
        BOOL DoMove(UINT nFlags, CPoint point);

        // do an incremental delta change of parameters
        BOOL DoDeltaMove(UINT nFlags, <a class="code" href="class_point.html">Point</a> &amp;delta);

        // execute navigation / sensor move action, on time event 
        // return TRUE if redraw / false if not 
        BOOL DoMoveTimer();


        // Stop navigation action, e.g. because new viewpoint was bound 
        void <a class="code" href="class_gviewcontroller.html#a6">OnStopNavigation</a>();

        // do the timer action 
        void OnDoTimer(UINT nIDEvent);


        //
        // OnReadFileCompleted -   GFile Thread sends a user defined WM_READFILECOMPLETED
        //                         message to this window, when the thread has finished.
        //
        afx_msg LRESULT OnReadFileCompleted(WPARAM wParam, LPARAM lParam);

        #define WM_HARDWARECHECK WM_USER +2 

        //
        // OnHardwareCheck -   Hardware check dialog done
        //
        afx_msg LRESULT OnHardwareCheck(WPARAM wParam, LPARAM lParam);

        #define WM_STATUSMESSAGE WM_USER + 3
        #define WM_CONSOLE_MESSAGE WM_USER + 4

        //
        // OnStatusMessage -   Print a status line message
        //
        afx_msg LRESULT OnStatusMessage(WPARAM wParam, LPARAM lParam);

        // write actual console buffer to console
        afx_msg LRESULT OnConsoleMessage(WPARAM wParam, LPARAM lParam);

        // main loader thread for URL scene + WWWAnchors
        <a class="code" href="class_gfile.html">GFile</a> *mainLoader;


        // kill all download activities for this window 
        void KillDownloads(); 


        // add url to history 
        void AddUrlToHistory(const char *url,const char *description=NULL, BOOL isFile=FALSE);

        <a class="code" href="class_arraynew.html">ArrayNew</a>&lt;CString&gt;       m_history;
        <a class="code" href="class_arraynew.html">ArrayNew</a>&lt;CString&gt;       m_historyDescription;
        int                                     m_historyIndex;

        BOOL GoBack();

        BOOL GoForward();


        // read top level url, download if needed 
        int ReadUrl(const char *url,const char *homeUrl,gbool reload=FALSE,time_t lastModified=0); 

        HRESULT NavigateToUrl(const char *url, const char *location=NULL, const char *targetFrame=NULL, DWORD flags = 0);

        BOOL <a class="code" href="class_gviewcontroller.html#a10">loadURLfromFields</a>(const char *description,<a class="code" href="class_gvmfstring.html">GvMFString</a> *url, <a class="code" href="class_gvmfstring.html">GvMFString</a> *<a class="code" href="class_parameter.html">parameter</a>,const char *homeUrl);

        // Exectute the Anchor node 
        BOOL ExecuteAnchorNode(<a class="code" href="class_gvnode.html">GvNode</a> *node);
        
        // public version
        void setViewpointByValue_(float positionX, float positionY, float positionZ, float orientationX, float orientationY, float orientationZ, float orientationAngle, long mode);




// Overrides
        // ClassWizard generated virtual function overrides
        //{{AFX_VIRTUAL(CGLViewCtrlCtrl)
        public:
        virtual void OnDraw(CDC* pdc, const CRect&amp; rcBounds, const CRect&amp; rcInvalid);
        virtual void DoPropExchange(CPropExchange* pPX);
        virtual void OnResetState();
        virtual BOOL OnSetExtent(LPSIZEL lpSizeL);
        virtual void OnSetClientSite();
        virtual DWORD GetControlFlags();
        virtual BOOL OnSetObjectRects(LPCRECT lpRectPos, LPCRECT lpRectClip);
        virtual BOOL OnSetData(LPFORMATETC lpFormatEtc, LPSTGMEDIUM lpStgMedium,BOOL bRelease);
        virtual BOOL OnRenderFileData(LPFORMATETC lpFormatEtc, CFile* pFile);
        virtual BOOL OnRenderData(LPFORMATETC lpFormatEtc, LPSTGMEDIUM lpStgMedium);
        virtual BOOL OnRenderGlobalData(LPFORMATETC lpFormatEtc, HGLOBAL* phGlobal);
        virtual BOOL PreTranslateMessage(MSG* pMsg);
        virtual void OnMnemonic(LPMSG pMsg);
        virtual void OnKeyDownEvent(USHORT nChar, USHORT nShiftState);
        virtual void OnAmbientPropertyChange(DISPID dispid);
        virtual BOOL OnEdit(LPMSG lpMsg, HWND hWndParent, LPCRECT lpRect);
        virtual void OnGetControlInfo(LPCONTROLINFO pControlInfo);
        virtual HMENU OnGetInPlaceMenu();
        virtual BOOL OnGetNaturalExtent(DWORD dwAspect, LONG lindex, DVTARGETDEVICE* ptd, HDC hicTargetDev, DVEXTENTINFO* pExtentInfo, LPSIZEL psizel);
        virtual void Serialize(CArchive&amp; ar);
        virtual BOOL OnProperties(LPMSG lpMsg, HWND hWndParent, LPCRECT lpRect);
        virtual void OnFinalRelease();
        protected:
        virtual BOOL PreCreateWindow(CREATESTRUCT&amp; cs);
        virtual LRESULT WindowProc(UINT message, WPARAM wParam, LPARAM lParam);
        //}}AFX_VIRTUAL

        // Non-in-place activation
        virtual HRESULT OnOpen(BOOL bTryInPlace, LPMSG pMsg);
        virtual HRESULT OnHide();


// Implementation
protected:
        ~CGLViewCtrlCtrl();

        DECLARE_OLECREATE_EX(<a class="code" href="class_cglviewctrlctrl.html">CGLViewCtrlCtrl</a>)    
        DECLARE_OLETYPELIB(<a class="code" href="class_cglviewctrlctrl.html">CGLViewCtrlCtrl</a>)      
        DECLARE_PROPPAGEIDS(<a class="code" href="class_cglviewctrlctrl.html">CGLViewCtrlCtrl</a>)     
        DECLARE_OLECTLTYPE(<a class="code" href="class_cglviewctrlctrl.html">CGLViewCtrlCtrl</a>)             

public:
        // update registry settings 
        BOOL UpdateRegistry() {
                BOOL ret = factory.UpdateRegistry(TRUE);
                return ret;
        }

        // get the progID 
//      LPCTSTR GetProgID() {
//              return factory.m_lpszProgID;
//      }
protected:      

// Message maps


        //{{AFX_MSG(CGLViewCtrlCtrl)
        afx_msg void OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags);
        afx_msg void OnLButtonDblClk(UINT nFlags, CPoint point);
        afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
        afx_msg void OnLButtonUp(UINT nFlags, CPoint point);
        afx_msg void OnMouseMove(UINT nFlags, CPoint point);
        afx_msg void OnMove(int x, int y);
        afx_msg void OnRButtonDown(UINT nFlags, CPoint point);
        afx_msg void OnSize(UINT nType, int cx, int cy);
        afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
        afx_msg void OnDestroy();
        afx_msg BOOL OnEraseBkgnd(CDC* pDC);
        afx_msg void OnTimer(UINT nIDEvent);
        afx_msg void OnActivate(UINT nState, CWnd* pWndOther, BOOL bMinimized);
        afx_msg void OnCameraNone();
        afx_msg void OnUpdateCameraNone(CCmdUI* pCmdUI);
        afx_msg void OnCameraOrbit();
        afx_msg void OnUpdateCameraOrbit(CCmdUI* pCmdUI);
        afx_msg void OnCameraPan();
        afx_msg void OnUpdateCameraPan(CCmdUI* pCmdUI);
        afx_msg void OnCameraRoll();
        afx_msg void OnUpdateCameraRoll(CCmdUI* pCmdUI);
        afx_msg void OnCameraDollyXy();
        afx_msg void OnUpdateCameraDollyXy(CCmdUI* pCmdUI);
        afx_msg void OnCameraFly();
        afx_msg void OnUpdateCameraFly(CCmdUI* pCmdUI);
        afx_msg void OnCameraAnimateViewpoints();
        afx_msg void OnUpdateCameraAnimateViewpoints(CCmdUI* pCmdUI);
        afx_msg void OnCameraReset();
        afx_msg void OnCameraSeekto();
        afx_msg void OnUpdateCameraSeekto(CCmdUI* pCmdUI);
        afx_msg void OnCameraViewpointNext();
        afx_msg void OnUpdateCameraViewpointNext(CCmdUI* pCmdUI);
        afx_msg void OnCameraViewpointPrev();
        afx_msg void OnUpdateCameraViewpointPrev(CCmdUI* pCmdUI);
        afx_msg void OnCameraWalk();
        afx_msg void OnUpdateCameraWalk(CCmdUI* pCmdUI);
        afx_msg void OnCameraZoom();
        afx_msg void OnUpdateCameraZoom(CCmdUI* pCmdUI);
        afx_msg void OnRenderFlat();
        afx_msg void OnUpdateRenderFlat(CCmdUI* pCmdUI);
        afx_msg void OnRenderGouraud();
        afx_msg void OnUpdateRenderGouraud(CCmdUI* pCmdUI);
        afx_msg void OnRenderTextured();
        afx_msg void OnUpdateRenderTextured(CCmdUI* pCmdUI);
        afx_msg void OnRenderWireframe();
        afx_msg void OnUpdateRenderWireframe(CCmdUI* pCmdUI);
        afx_msg void OnCameraHeadlight();
        afx_msg void OnUpdateCameraHeadlight(CCmdUI* pCmdUI);
        afx_msg void OnRenderNonlighted();
        afx_msg void OnUpdateRenderNonlighted(CCmdUI* pCmdUI);
        afx_msg void OnRenderVertices();
        afx_msg void OnUpdateRenderVertices(CCmdUI* pCmdUI);
        afx_msg void OnCameraRelative();
        afx_msg void OnUpdateCameraRelative(CCmdUI* pCmdUI);
        afx_msg void OnCameraFollowObject();
        afx_msg void OnCameraCollision();
        afx_msg void OnUpdateCameraCollision(CCmdUI* pCmdUI);
        afx_msg void OnActivateApp(BOOL bActive, HTASK hTask);
        afx_msg void OnDropFiles(HDROP hDropInfo);
        afx_msg void OnEnable(BOOL bEnable);
        afx_msg void OnKillFocus(CWnd* pNewWnd);
        afx_msg void OnPaletteChanged(CWnd* pFocusWnd);
        afx_msg void OnPaletteIsChanging(CWnd* pRealizeWnd);
        afx_msg BOOL OnQueryNewPalette();
        afx_msg void OnWindowPosChanged(WINDOWPOS <a class="code" href="class_inflate_huft_s.html">FAR</a>* lpwndpos);
        afx_msg void OnPopupHelpManual();
        afx_msg void OnPopupHelpVisit();
        afx_msg void OnPopupHelpAbout();
        afx_msg BOOL OnSetCursor(CWnd* pWnd, UINT nHitTest, UINT message);
        afx_msg void OnCameraJump();
        afx_msg void OnUpdateCameraJump(CCmdUI* pCmdUI);
        afx_msg void OnSettingsStopLoading();
        afx_msg void OnUpdateSettingsStopLoading(CCmdUI* pCmdUI);
        afx_msg void OnSettingsReload();
        afx_msg void OnUpdateSettingsReload(CCmdUI* pCmdUI);
        afx_msg void OnShowWindow(BOOL bShow, UINT nStatus);
        afx_msg void OnSettingsSound();
        afx_msg void OnUpdateSettingsSound(CCmdUI* pCmdUI);
        afx_msg void OnPopupHelpWorldinfo();
        afx_msg void OnSettingsStayOnGround();
        afx_msg void OnUpdateSettingsStayOnGround(CCmdUI* pCmdUI);
        afx_msg void OnRenderDither();
        afx_msg void OnUpdateRenderDither(CCmdUI* pCmdUI);
        afx_msg void OnRenderTextureSmooth();
        afx_msg void OnUpdateRenderTextureSmooth(CCmdUI* pCmdUI);
        afx_msg void OnSettingsPreferences();
        afx_msg int OnMouseActivate(CWnd* pDesktopWnd, UINT nHitTest, UINT message);
        afx_msg void OnPopupHelpCheckversion();
        afx_msg void OnCameraRotate();
        afx_msg void OnUpdateCameraRotate(CCmdUI* pCmdUI);
        afx_msg void OnPopupSpeedVeryslow();
        afx_msg void OnUpdatePopupSpeedVeryslow(CCmdUI* pCmdUI);
        afx_msg void OnPopupSpeedSlow();
        afx_msg void OnUpdatePopupSpeedSlow(CCmdUI* pCmdUI);
        afx_msg void OnPopupSpeedMedium();
        afx_msg void OnUpdatePopupSpeedMedium(CCmdUI* pCmdUI);
        afx_msg void OnPopupSpeedFast();
        afx_msg void OnUpdatePopupSpeedFast(CCmdUI* pCmdUI);
        afx_msg void OnPopupSpeedVeryfast();
        afx_msg void OnUpdatePopupSpeedVeryfast(CCmdUI* pCmdUI);
        afx_msg void OnCameraZoomout();
        afx_msg void OnCameraStraightenUp();
        afx_msg void OnKeyUp(UINT nChar, UINT nRepCnt, UINT nFlags);
        afx_msg void OnDevModeChange(LPTSTR lpDeviceName);
        afx_msg void OnChar(UINT nChar, UINT nRepCnt, UINT nFlags);
        afx_msg void OnGoBack();
        afx_msg void OnUpdateGoBack(CCmdUI* pCmdUI);
        afx_msg void OnCameraGravity();
        afx_msg void OnUpdateCameraGravity(CCmdUI* pCmdUI);
        afx_msg void OnSettingsConsole();
        afx_msg void OnUpdateSettingsConsole(CCmdUI* pCmdUI);
        afx_msg void OnEnterIdle(UINT nWhy, CWnd* pWho);
        afx_msg void OnSetFocus(CWnd* pOldWnd);
        afx_msg void OnView3rdPerson();
        afx_msg void OnUpdateView3rdPerson(CCmdUI* pCmdUI);
        afx_msg void OnViewPad();
        afx_msg void OnUpdateViewPad(CCmdUI* pCmdUI);
        afx_msg void OnPopupPanel();
        afx_msg void OnUpdatePopupPanel(CCmdUI* pCmdUI);
        afx_msg void OnRButtonUp(UINT nFlags, CPoint point);
        afx_msg void OnRButtonDblClk(UINT nFlags, CPoint point);
        afx_msg void OnSettingChange(UINT uFlags, LPCTSTR lpszSection);
        afx_msg void OnMButtonDown(UINT nFlags, CPoint point);
        afx_msg void OnMButtonUp(UINT nFlags, CPoint point);
        afx_msg void OnMButtonDblClk(UINT nFlags, CPoint point);
        afx_msg void OnInitMenu(CMenu* pMenu);
        afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
        //}}AFX_MSG

        // standard OnClose is without dwSaveOption

        afx_msg void OnClose(DWORD dwSaveOption); 
        
        //  command id range handlers
        afx_msg void OnCameraViewpoint(UINT id); 
        afx_msg void OnUpdateCameraViewpoint(CCmdUI* pCmdUI);
        afx_msg void OnUserMenu(UINT id); 
        afx_msg void OnOptionsDriver(UINT id); 
        afx_msg void OnUpdateOptionsDriver(CCmdUI* pCmdUI);
        afx_msg void OnPaint();

        // WM_MOVING
        afx_msg LRESULT OnMoving(WPARAM wParam, LPARAM lParam);

        //WM_SIZING
        afx_msg LRESULT OnSizing(WPARAM wParam, LPARAM lParam);

        //WM_CAPTURECHANGED
        afx_msg LRESULT OnCaptureChanged(WPARAM wParam, LPARAM lParam);
        
        
        DECLARE_MESSAGE_MAP()

// Dispatch maps
        //{{AFX_DISPATCH(CGLViewCtrlCtrl)
        afx_msg BSTR GetUrl();
        afx_msg void SetUrl(LPCTSTR lpszNewValue);
        afx_msg BSTR GetRenderMode();
        afx_msg void SetRenderMode(LPCTSTR lpszNewValue);
        afx_msg BSTR GetNavigationMode();
        afx_msg void SetNavigationMode(LPCTSTR lpszNewValue);
        afx_msg short GetHeadlight();
        afx_msg void SetHeadlight(short nNewValue);
        afx_msg float GetWalkSpeed();
        afx_msg void SetWalkSpeed(float newValue);
        afx_msg BOOL GetAnimateAllViewpoints();
        afx_msg void SetAnimateAllViewpoints(BOOL bNewValue);
        afx_msg BSTR GetViewpoint();
        afx_msg void SetViewpoint(LPCTSTR lpszNewValue);
        afx_msg BSTR GetDescription();
        afx_msg void SetDescription(LPCTSTR lpszNewValue);
        afx_msg BSTR GetWorld();
        afx_msg void SetWorld(LPCTSTR lpszNewValue);
        afx_msg BOOL GetCollisionDetection();
        afx_msg void SetCollisionDetection(BOOL bNewValue);
        afx_msg float GetAvatarHeight();
        afx_msg void SetAvatarHeight(float newValue);
        afx_msg float GetCollisionDistance();
        afx_msg void SetCollisionDistance(float newValue);
        afx_msg float GetVisibilityLimit();
        afx_msg void SetVisibilityLimit(float newValue);
        afx_msg BOOL GetGravity();
        afx_msg void SetGravity(BOOL bNewValue);
        afx_msg void OnNextViewpoint();
        afx_msg void OnPrevViewpoint();
        afx_msg BSTR getName();
        afx_msg BSTR getVersion();
        afx_msg float getCurrentSpeed();
        afx_msg float getCurrentFrameRate();
        afx_msg BSTR getWorldURL();
        afx_msg void replaceWorld(LPUNKNOWN nodes);
        afx_msg void loadURL(LPCTSTR url, LPCTSTR <a class="code" href="class_parameter.html">parameter</a>);
        afx_msg void setDescription(LPCTSTR description);
        afx_msg LPUNKNOWN createVrmlFromString(LPCTSTR vrmlSyntax);
        afx_msg void createVrmlFromURL(LPCTSTR url, LPDISPATCH node, LPCTSTR event);
        afx_msg LPUNKNOWN getNode(LPCTSTR name);
        afx_msg void addRoute(LPUNKNOWN fromNode, LPCTSTR fromEventOut, LPUNKNOWN toNode, LPCTSTR toEventIn);
        afx_msg void deleteRoute(LPUNKNOWN fromNode, LPCTSTR fromEventOut, LPUNKNOWN toNode, LPCTSTR toEventIn);
        afx_msg LPUNKNOWN createNode(LPCTSTR nodeclass);
        afx_msg void addNode(LPUNKNOWN node);
        afx_msg LPDISPATCH getWorld();
        afx_msg void beginUpdate();
        afx_msg void endUpdate();
        afx_msg long setTimerInterval(long interval);
        afx_msg BOOL isSceneLoaded();
        afx_msg void setNodeName(LPUNKNOWN node, LPCTSTR name);
        afx_msg BSTR getNodeName(LPUNKNOWN node);
        afx_msg LPUNKNOWN getEventOut(LPCTSTR eventOutName);
        afx_msg LPUNKNOWN getEventIn(LPCTSTR eventInName);
        afx_msg BSTR getControlPathname();
        afx_msg BOOL saveWorld(LPCTSTR fileName);
        afx_msg void saveViewpoint(LPCTSTR viewpointName);
        afx_msg BOOL setFullscreen(BOOL mode);
        afx_msg BOOL removeNode(LPUNKNOWN node);
        afx_msg BOOL setObserver(LPUNKNOWN observer, long flags);
        afx_msg BOOL loadURLfromFile(LPCTSTR url, LPCTSTR mimeType, LPCTSTR fileName);
        afx_msg void onUrlNotify(LPCTSTR url, LPCTSTR mimeType, LPCTSTR fileName, long reason);
        afx_msg BOOL setObserverWnd(long hwndHandle);
        afx_msg long getUiMode();
        afx_msg void setUiMode(long newMode);
        afx_msg void openPreferences(long flags);
        afx_msg void playSound(LPCTSTR soundFilename);
        afx_msg BOOL loadURLfromFile2(LPCTSTR url, LPCTSTR mimeType, long lastModified, long size, LPCTSTR fileName);
        afx_msg void onUrlNotify2(LPCTSTR url, LPCTSTR mimeType, long lastModified, long size, LPCTSTR fileName, long reason);
        afx_msg void printMessage(LPCTSTR message);
        afx_msg void setViewpointByValue(float positionX, float positionY, float positionZ, float orientationX, float orientationY, float orientationZ, float orientationAngle, long mode);
        afx_msg void getViewpointByValue(float <a class="code" href="class_inflate_huft_s.html">FAR</a>* positionX, float <a class="code" href="class_inflate_huft_s.html">FAR</a>* positionY, float <a class="code" href="class_inflate_huft_s.html">FAR</a>* positionZ, float <a class="code" href="class_inflate_huft_s.html">FAR</a>* orientationX, float <a class="code" href="class_inflate_huft_s.html">FAR</a>* orientationY, float <a class="code" href="class_inflate_huft_s.html">FAR</a>* orientationZ, float <a class="code" href="class_inflate_huft_s.html">FAR</a>* orientationAngle, long mode);
        afx_msg BOOL getNodeBoundingBox(LPUNKNOWN node, long mode, float <a class="code" href="class_inflate_huft_s.html">FAR</a>* xmin, float <a class="code" href="class_inflate_huft_s.html">FAR</a>* ymin, float <a class="code" href="class_inflate_huft_s.html">FAR</a>* zmin, float <a class="code" href="class_inflate_huft_s.html">FAR</a>* xmax, float <a class="code" href="class_inflate_huft_s.html">FAR</a>* ymax, float <a class="code" href="class_inflate_huft_s.html">FAR</a>* zmax);
        afx_msg void setUrl2(LPCTSTR url, long lastModified, long mode);
        afx_msg long getInterfaceVersion();
        afx_msg void setThirdPersonView(BOOL mode);
        afx_msg BOOL getThirdPersonView();
        afx_msg LPUNKNOWN computeRayHit(LPUNKNOWN startNode, float startx, float starty, float startz, float endx, float endy, float endz, long mode);
        afx_msg void setMyAvatarNode(LPUNKNOWN node);
        afx_msg LPUNKNOWN getMyAvatarNode();
        afx_msg void setMyAvatarURL(LPCTSTR url);
        afx_msg BSTR getMyAvatarURL();
        afx_msg BOOL setViewpointFollow(LPUNKNOWN node, float refX, float refY, float refZ, long mode);
        afx_msg BOOL setNodeEventIn(LPCTSTR nodeName, LPCTSTR eventInName, LPCTSTR value);
        afx_msg BSTR getNodeEventOut(LPCTSTR nodeName, LPCTSTR eventOutName);
        afx_msg LPUNKNOWN getObject(long objectId);
        afx_msg void setNavigationPanel(BOOL mode);
        afx_msg BOOL getNavigationPanel();
        //}}AFX_DISPATCH
        DECLARE_DISPATCH_MAP()

//      afx_msg BSTR GetUrl();
//      afx_msg void SetUrl(LPCTSTR lpszNewValue);

//      afx_msg BSTR GetMedia();
//      afx_msg void SetMedia(LPCTSTR lpszNewValue);
//      afx_msg BSTR GetCfformat();
//      afx_msg void SetCfformat(LPCTSTR lpszNewValue);

        DECLARE_INTERFACE_MAP()

        // IPersistMoniker
        BEGIN_INTERFACE_PART(PersistMoniker, IPersistMoniker)
                INIT_INTERFACE_PART(CGLViewCtrl, PersistMoniker)
                STDMETHOD(GetClassID)(CLSID *clsid);
                STDMETHOD(IsDirty)(void);
                STDMETHOD(Load)(BOOL fFullyAvailable, IMoniker* pmkSrc, IBindCtx* pbc, DWORD grfMode);
                STDMETHOD(Save)(IMoniker* pmkDst, IBindCtx* pbc, BOOL fRemember);
                STDMETHOD(SaveCompleted)(IMoniker* pmkNew, IBindCtx* pbc);
                STDMETHOD(GetCurMoniker)(IMoniker** ppmkCur);
        END_INTERFACE_PART(PersistMoniker)

        // IOleCommandTarget //http://www.microsoft.com/kb/articles/q167/9/56.htm
    BEGIN_INTERFACE_PART(CmdTargetObj, IOleCommandTarget)
         STDMETHOD(QueryStatus)(const GUID*, ULONG, OLECMD[], OLECMDTEXT*);
         STDMETHOD(Exec)(const GUID*, DWORD, DWORD, VARIANTARG*, VARIANTARG*);
     END_INTERFACE_PART(CmdTargetObj)






        afx_msg void AboutBox();

// Event maps
        //{{AFX_EVENT(CGLViewCtrlCtrl)
        void FireOnSceneChanged(LPCTSTR url)
                {FireEvent(eventidOnSceneChanged,EVENT_PARAM(VTS_BSTR), url);}
        void FireOnEvent(LPCTSTR name, LPCTSTR value, double timeStamp)
                {FireEvent(eventidOnEvent,EVENT_PARAM(VTS_BSTR  VTS_BSTR  VTS_R8), name, value, timeStamp);}
        void FireOnProgress(long amount)
                {FireEvent(DISPID_ONPROGRESS,EVENT_PARAM(VTS_I4), amount);}
        //}}AFX_EVENT
        DECLARE_EVENT_MAP()


        //void FireOnProgress(long amount) {FireEvent(DISPID_PROGRESS,EVENT_PARAM(VTS_I4), amount);}



// Dispatch and event IDs
public:

        enum {
        //{{AFX_DISP_ID(CGLViewCtrlCtrl)
        dispidUrl = 1L,
        dispidRenderMode = 2L,
        dispidNavigationMode = 3L,
        dispidHeadlight = 4L,
        dispidWalkSpeed = 5L,
        dispidAnimateAllViewpoints = 6L,
        dispidViewpoint = 7L,
        dispidDescription = 8L,
        dispidWorld = 9L,
        dispidCollisionDetection = 10L,
        dispidAvatarHeight = 11L,
        dispidCollisionDistance = 12L,
        dispidVisibilityLimit = 13L,
        dispidGravity = 14L,
        dispidOnNextViewpoint = 15L,
        dispidOnPrevViewpoint = 16L,
        dispidGetName = 17L,
        dispidGetVersion = 18L,
        dispidGetCurrentSpeed = 19L,
        dispidGetCurrentFrameRate = 20L,
        dispidGetWorldURL = 21L,
        dispidReplaceWorld = 22L,
        dispidLoadURL = 23L,
        dispidSetDescription = 24L,
        dispidCreateVrmlFromString = 25L,
        dispidCreateVrmlFromURL = 26L,
        dispidGetNode = 27L,
        dispidAddRoute = 28L,
        dispidDeleteRoute = 29L,
        dispidCreateNode = 30L,
        dispidAddNode = 31L,
        dispidGetWorld = 32L,
        dispidBeginUpdate = 33L,
        dispidEndUpdate = 34L,
        dispidSetTimerInterval = 35L,
        dispidIsSceneLoaded = 36L,
        dispidSetNodeName = 37L,
        dispidGetNodeName = 38L,
        dispidGetEventOut = 39L,
        dispidGetEventIn = 40L,
        dispidGetControlPathname = 41L,
        dispidSaveWorld = 42L,
        dispidSaveViewpoint = 43L,
        dispidSetFullscreen = 44L,
        dispidRemoveNode = 45L,
        dispidSetObserver = 46L,
        dispidLoadURLfromFile = 47L,
        dispidOnUrlNotify = 48L,
        dispidSetObserverWnd = 49L,
        dispidGetUiMode = 50L,
        dispidSetUiMode = 51L,
        dispidOpenPreferences = 52L,
        dispidPlaySound = 53L,
        dispidLoadURLfromFile2 = 54L,
        dispidOnUrlNotify2 = 55L,
        dispidPrint = 56L,
        dispidSetViewpointByValue = 57L,
        dispidGetViewpointByValue = 58L,
        dispidGetNodeBoundingBox = 59L,
        dispidSetUrl2 = 60L,
        dispidGetInterfaceVersion = 61L,
        dispidSetThirdPersonView = 62L,
        dispidGetThirdPersonView = 63L,
        dispidComputeRayHit = 64L,
        dispidSetMyAvatarNode = 65L,
        dispidGetMyAvatarNode = 66L,
        dispidSetMyAvatarURL = 67L,
        dispidGetMyAvatarURL = 68L,
        dispidSetViewpointFollow = 69L,
        dispidSetNodeEventIn = 70L,
        dispidGetNodeEventOut = 71L,
        dispidGetObject = 72L,
        dispidSetNavigationPanel = 73L,
        dispidGetNavigationPanel = 74L,
        eventidOnSceneChanged = 1L,
        eventidOnEvent = 2L,
        //}}AFX_DISP_ID
        };

        //eventidProgress = 3L,


private:
        BOOL InsideSphere;
        BOOL m_navPanelDrag;

        //BOOL m_PanelEnabled;
        BOOL m_navPanelOn_Embed;

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

</div></pre><hr><address><small>Generated at Thu Jan 27 18:16:01 2000 for blaxxunContact3D by
<a href="http://www.stack.nl/~dimitri/doxygen/index.html">
<img src="doxygen.gif" alt="doxygen" align=center border=0 
width=118 height=53></a> 1.0.0 written by <a href="mailto:dimitri@stack.nl">Dimitri van Heesch</a>,
 &copy; 1997-1999</small></address>
</body>
</html>

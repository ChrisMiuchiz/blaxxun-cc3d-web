<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta name="robots" content="noindex">
<title>tagHPoint Include File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body bgcolor="#ffffff">
<!-- Generated by Doxygen 1.0.0 on Thu Jan 27 18:56:19 2000 -->
<center>
<a class="qindex"href="index.html">Main Page</a> &nbsp; <a class="qindex"href="namespaces.html">Namespace List</a> &nbsp; <a class="qindex"href="hierarchy.html">Class Hierarchy</a> &nbsp; <a class="qindex"href="annotated.html">Compound List</a> &nbsp; <a class="qindex"href="files.html">File List</a> &nbsp; <a class="qindex"href="headers.html">Header Files</a> &nbsp; <a class="qindex"href="namespacemembers.html">Namespace Members</a> &nbsp; <a class="qindex"href="functions.html">Compound Members</a> &nbsp; <a class="qindex"href="globals.html">File Members</a> &nbsp; </center>
<hr><h1>gnurbs.h</h1>This is the verbatim text of the gnurbs.h include file.<div class="fragment"><pre>/*=============================================================================

This code is licensed under the Web3D-blaxxun Community Source License,
provided in distribution file LICENSE.TXT and available online at
http://www.web3D.org/TaskGroups/x3d/blaxxun/Web3D-blaxxunCommunitySourceAgreement.html
and may only be used for non-commercial use as specified in that license.

THE WEB3D CONSORTIUM AND BLAXXUN DO NOT MAKE AND HEREBY DISCLAIM ANY EXPRESS
OR IMPLIED WARRANTIES RELATING TO THIS CODE, INCLUDING BUT NOT LIMITED TO,
WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY OR FITNESS FOR A PARTICULAR
PURPOSE, OR ANY WARRANTIES THAT MIGHT ARISE FROM A COURSE OF DEALING, USAGE
OR TRADE PRACTICE.  THE COMMUNITY SOURCE CODE IS PROVIDED UNDER THIS
AGREEMENT "AS IS," WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
INCLUDING, WITHOUT LIMITATION, WARRANTIES THAT THE COMMUNITY SOURCE CODE ARE
FREE OF DEFECTS, MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE OR
NON-INFRINGING OR IN ANY WAY CONSTITUTE THE COMPLETE PRODUCT MARKETED UNDER
THE NAMES GIVEN SAID CODE.

==============================================================================*/
#ifndef __gnurbsshell__
#define __gnurbsshell__
/******************************************************************************
@doc

@module GNurbsShell.h 

Copyright (c) 1998 - 1999 by blaxxun interactive
All rights reserved

Purpose:

Classes:
  
Notes:

Changes:

$Revision: 1.8 $
$Log: gnurbs.h,v $
Revision 1.8  1999/07/06 16:54:41  tom
*** empty log message ***


Todo :

******************************************************************************/

#include "gshell.h"

#include "astream.h"


/*------------------
                config
-------------------*/



#ifdef _DEBUG   

        //#define GN_LOG // enable logging 

        //#define _LOG_TRIMMED_//enable gul logging

        #ifdef _LOG_TRIMMED_

        // logging
        #include &lt;fstream.h&gt;

        #endif

#endif

/*------------------
                config
-------------------*/


typedef struct <a class="code" href="class_taghpoint.html">tagHPoint</a>
{
        float x;
        float y;
        float z;
        float w;
} HPoint;

#define VECTOR_SIZE 4//(sizeof( __m128 )/sizeof( float ) )
#define LOWER_TESSELLATION_BOUND 0.4f

#ifdef _KATMAI_XXX
        #define ALIGNED_NEW( s, t ) (t *)_mm_malloc( (s) * sizeof( t ), 16 )
        #define ALIGNED_DELETE( x ) do { if( (x) ) { _mm_free( (char *)x ); x = NULL; } } while (0)
#else
        #define ALIGNED_NEW( s, t ) (t *) malloc( (s) * sizeof( t ))
        #define ALIGNED_DELETE( x ) do { if( (x) ) { free( (char *)x ); x = NULL; } } while (0)
#endif

#define SAFE_DELETE( x ) if( x ) { delete x; x = NULL; }


typedef enum GNurbsMode {

        GNURBS_STATIC_TESSELATION=0, 

        GNURBS_DYNAMIC_TESSELATION=1, 
        GNURBS_FRAMERATE_TESSELATION=2,
        GNURBS_DYNAMIC_FRAMERATE_TESSELATION=3, 

} GNurbsMode;


class <a class="code" href="class_gtrimmednurbsshell.html">GTrimmedNurbsShell</a>;




//----------------------------------------------------------------------
//
//                                                      GNurbsShell
//
//----------------------------------------------------------------------


class <a class="code" href="class_gnurbsshell.html">GNurbsShell</a> : public <a class="code" href="class_gshell.html">GShell</a>
{
public:
  friend class <a class="code" href="class_gtrimmednurbsshell.html">GTrimmedNurbsShell</a>;

        <a class="code" href="class_gobject.html#c0">RT</a>(<a class="code" href="class_gnurbsshell.html">GNurbsShell</a>);

        <a class="code" href="class_gnurbsshell.html#a1">GNurbsShell</a>();
        <a class="code" href="class_gnurbsshell.html#a2">~GNurbsShell</a>();

        gbool <a class="code" href="class_grenderdevice.html#a0">Init</a>(int uDimension, int vDimension, int uOrder, int vOrder,
                                           const float *controlPoint, 
                                           int numWeight,const float* weight, 
                                           const float* uKnot, const float* vKnot, 
                                           int nUTessellations, int nVTessellations);
        
        // set the initial tesselation // multiplied later by budget
        void <a class="code" href="class_gnurbsshell.html#a4">InitTessellationValues</a>(int nUTessellations, int nVTessellations);
        
        int <a class="code" href="class_gnurbsshell.html#a5">ComputeShell</a>();

        void <a class="code" href="class_gnurbsshell.html#a6">setControlPoints</a>(int numCtrlPts, const float *ctrlPts, 
                                                int numWeights, const float *weights);

        void <a class="code" href="class_gnurbsshell.html#a6">setControlPoints</a>(int num, const float *ctrlPts);

        void <a class="code" href="class_gnurbsshell.html#a8">setWeight</a>(int num, const float * weights);

        int  <a class="code" href="class_gnurbsshell.html#a9">GetCurrentTriangleBudget</a>() const {
                return (2 * m_iUTessellations * m_iVTessellations);
        }

        int <a class="code" href="class_gnurbsshell.html#a10">SetRenderQuality</a>(float budget);

        // is the current cached tessellation up to date ?
        gbool <a class="code" href="class_gnurbsshell.html#a11">IsShellTessellationOk</a>() const {
                if ( tessellationChanged || !shellVerticesOk || !shellFacelistOk)
                        return gfalse;
                return gtrue;
        }



private:

#ifdef GN_LOG
//      AStream out("Framestats.log", "w");
        ofstream tris;
        ofstream bbsurf;
        ofstream scaleStream;
#endif

        BOOL texCompute;
        gbool triStrip; // use triStips or triangles for draw 

        // are the vertices of the shell Computed ??
        gbool shellVerticesOk;                                  
        // is the facelist of the shell Computed ??
        gbool shellFacelistOk;                                  

        // has the tesselation be changed ?
        gbool tessellationChanged;

        //the intel stuff
        BOOL m_bInitialized;
        int g_CurrentUKnot;
        
        int m_iUCoefficients;
        int m_iVCoefficients;
        int m_iUControlPoints;
        int m_iVControlPoints;
        
        unsigned int m_iUKnots;
        unsigned int m_iVKnots;

        unsigned int m_iUDegree, m_iUOrder;
        unsigned int m_iVDegree, m_iVOrder;

        unsigned int m_iUTessellations, m_iMinUTessellations, m_iMaxUTessellations;
        unsigned int m_iVTessellations, m_iMinVTessellations, m_iMaxVTessellations;
        unsigned int m_iLastUTess, m_iLastVTess;

        unsigned int m_iInitialUTess, m_iInitialVTess; // initial tesselation numbers

        float m_fBudget;
        <a class="code" href="class_point.html">Point</a> bboxMin, bboxMax;
        float m_fBBSurface;
        float m_fInitialRenderQuality;
        float m_fRenderQuality;//=triangles per BBSurface = const
                        


        <a class="code" href="class_floatarrayaligned.html">FloatArrayAligned</a> m_ControlPoints;
        <a class="code" href="class_floatarrayaligned.html">FloatArrayAligned</a> m_TxControlPoints;

        <a class="code" href="class_floatarrayaligned.html">FloatArrayAligned</a> m_UKnots;
        <a class="code" href="class_floatarrayaligned.html">FloatArrayAligned</a> m_VKnots;
        <a class="code" href="class_floatarrayaligned.html">FloatArrayAligned</a> m_UBasisCoefficients;
        <a class="code" href="class_floatarrayaligned.html">FloatArrayAligned</a> m_VBasisCoefficients;
        <a class="code" href="class_floatarrayaligned.html">FloatArrayAligned</a> m_UBasis;
        <a class="code" href="class_floatarrayaligned.html">FloatArrayAligned</a> m_VBasis;
        <a class="code" href="class_floatarrayaligned.html">FloatArrayAligned</a> m_dUBasis;
        <a class="code" href="class_floatarrayaligned.html">FloatArrayAligned</a> m_dVBasis;

        <a class="code" href="class_floatarrayaligned.html">FloatArrayAligned</a> m_dUTemp;
    <a class="code" href="class_floatarrayaligned.html">FloatArrayAligned</a> m_UTemp;

        int *m_TessUKnot;
        int *m_TessVKnot;

        <a class="code" href="class_pointarray.html">PointArray</a> m_pNormals;
        
        WORD *m_iVertexIndices[2]; // tri strip indices for DrawPrimitive

        <a class="code" href="class_floatarrayaligned.html">FloatArrayAligned</a> m_pVertexPos; // tesselated vertices in view coordinates
        float *m_pQView;
        float *m_pQWV;


        int m_iVertices;
        float m_fHalfX, m_fHalfY;

        virtual void <a class="code" href="class_gnurbsshell.html#c0">ComputeBasisCoefficients</a>();
        virtual void <a class="code" href="class_gnurbsshell.html#c1">EvaluateBasisFunctions</a>();

        void <a class="code" href="class_gnurbsshell.html#c2">SetTessellationLimits</a>( int iMinUTessellations, int iMinVTessellations, int iMaxUTessellations, int iMaxVTessellations);

        float <a class="code" href="class_gnurbsshell.html#c3">ComputeCoefficient</a>( float *fKnots, int iInterval, int i, int p, int k );
        float <a class="code" href="class_gnurbsshell.html#c4">ComputeBBSurface</a>(<a class="code" href="class_matrix.html">Matrix</a> &amp;model2view, <a class="code" href="class_matrix.html">Matrix</a> &amp;projection, float w, float h);
        void <a class="code" href="class_gnurbsshell.html#c5">SetTessellation</a>(int nUTessellations, int nVTessellations);

        int <a class="code" href="class_gnurbsshell.html#c6">ComputeTessellationValues</a>(int mode);

        void <a class="code" href="class_gnurbsshell.html#c7">TransformControlPoints</a>(const <a class="code" href="class_matrix.html">Matrix</a> &amp;m);
        

public:

        gbool <a class="code" href="class_gnurbsshell.html#a12">EvaluateOnTessellation</a>(float u, float v, <a class="code" href="class_point.html">Point</a> &amp;p, <a class="code" href="class_point.html">Point</a> *vn=NULL, <a class="code" href="class_point.html">Point</a> *vp=NULL);

        void <a class="code" href="class_gnurbsshell.html#a13">GetTessellation</a>(int &amp;nUTessellations, int &amp;nVTessellations) 
        {
                nUTessellations = m_iUTessellations,nVTessellations=m_iVTessellations;
        }
        void <a class="code" href="class_gnurbsshell.html#a14">GetURange</a>(float &amp;umin,float &amp;umax) {
                         umin = m_UKnots[m_iUDegree];
                         umax = m_UKnots[m_iUControlPoints];
        }

        void <a class="code" href="class_gnurbsshell.html#a15">GetVRange</a>(float &amp;vmin,float &amp;vmax) {
                         vmin = m_VKnots[m_iVDegree];
                         vmax = m_VKnots[m_iVControlPoints];
        }


        // virtual ovverrides for GShell
        void <a class="code" href="class_gshell.html#a59">ComputeBBox</a>(<a class="code" href="class_bbox.html">BBox</a> &amp;<a class="code" href="class_box.html">box</a>);

        int <a class="code" href="class_gnode.html#a4">Do</a>(<a class="code" href="class_gbboxtraversal.html">GBBoxTraversal</a> &amp;state);       

        // check if vertices or shell need to be recomputed
        int <a class="code" href="class_gnode.html#a4">Do</a>(<a class="code" href="class_gglrendertraversal.html">GglRenderTraversal</a> &amp;state);
        int <a class="code" href="class_gnode.html#a4">Do</a>(<a class="code" href="class_grayselecttraversal.html">GRaySelectTraversal</a> &amp;state);



#ifdef _D3D

        inline D3DTLVERTEX *GetScreenVertices() { return (D3DTLVERTEX*) vtl.<a class="code" href="class_floatarrayaligned.html#a5">Data</a>(); }

        // get pointer to TLVERTEX Buffer with size check
        inline D3DTLVERTEX *GetScreenVertices(int nv) 
        { 
                // DTLVERTEX = 8 floats x y z w color spec tu tv 
                vtl.<a class="code" href="class_floatarrayaligned.html#a9">SetLength</a>( (sizeof(D3DTLVERTEX) / sizeof(float)) * ((nv+3) &amp; ~3)); // katmai uses at least multiple of 4 
                return (D3DTLVERTEX*) vtl.<a class="code" href="class_floatarrayaligned.html#a5">Data</a>(); 
        }

        //Render using ownLighting/Transform 
        int D3dRenderTL(<a class="code" href="class_gglrendertraversal.html">GglRenderTraversal</a> &amp;traversalState);
        
        void TransformControlPointsKatmai(const <a class="code" href="class_matrix.html">Matrix</a> &amp;m);

        HRESULT D3DRenderKatmaixx(LPDIRECT3DDEVICE2 pd3dDevice, LPDIRECT3DMATERIAL2 pd3dSurfMaterial,
                const <a class="code" href="class_matrix.html">Matrix</a> &amp;m_MxProjection, // projection 
            float sx,float tx, float sy,float ty, // 2D viewpoint transform
                DWORD clipFlags // for DrawPrimitive
                );

        HRESULT D3DRenderKatmai(<a class="code" href="class_renderstate.html">RenderState</a> &amp;state, 
                const <a class="code" href="class_matrix.html">Matrix</a> &amp;m_MxProjection, // projection 
            float sx,float tx, float sy,float ty, // 2D viewpoint transform
                DWORD clipFlags // for DrawPrimitive
                );

        HRESULT D3DRenderX86(<a class="code" href="class_renderstate.html">RenderState</a> &amp;state, 
                const <a class="code" href="class_matrix.html">Matrix</a> &amp;m_MxProjection, // 
            float sx,float tx, float sy,float ty, // 2D viewpoint transform
                DWORD clipFlags // for DrawPrimitive
                );

        int LightVertices(<a class="code" href="class_renderstate.html">RenderState</a> &amp;state,
                                          int nv, // number of vertices
                                          const HPoint *v, const <a class="code" href="class_point.html">Point</a> *vn,
                                          D3DTLVERTEX * vtl,
                                          int vtlstep // VTL BUFFER OFFSET
                                          );

#endif

};





//----------------------------------------------------------------------
//
//                                                      GTrimmedNurbsShell
//
//----------------------------------------------------------------------

#if defined(G_T_NURBS)

#include "gul/common/gul_types.h"

using <a class="code" href="class_gul__ptr.html">gul::Ptr</a>;
using <a class="code" href="class_gul__hpoint.html">gul::hpoint</a>;
using <a class="code" href="class_gul__point.html">gul::point</a>;
using <a class="code" href="class_gul__hpoint2.html">gul::hpoint2</a>;
using <a class="code" href="class_gul__point2.html">gul::point2</a>;
using <a class="code" href="class_gul__list.html">gul::List</a>;
using <a class="code" href="class_gul__list2.html">gul::List2</a>;
using <a class="code" href="class_gul__listnode.html">gul::ListNode</a>;


// data structures
struct trim_element   // can be a polyline (if poly.nElems() &gt; 0) or a curve
{
  Ptr&lt; point2&lt;float&gt; &gt;               poly;  // polyline
  <a class="code" href="class_gul__curve.html">gul::curve</a>&lt;float,hpoint2&lt;float&gt; &gt;  curv;  // curve
};
typedef List2&lt; ListNode&lt;trim_element&gt; &gt; trim_region; // list with two ends
typedef List&lt; ListNode&lt;trim_region&gt; &gt; trim_partition;

#endif



class <a class="code" href="class_gtrimmednurbsshell.html">GTrimmedNurbsShell</a> : public <a class="code" href="class_gshell.html">GShell</a>
{
public:

        <a class="code" href="class_gobject.html#c0">RT</a>(<a class="code" href="class_gtrimmednurbsshell.html">GTrimmedNurbsShell</a>);

        <a class="code" href="class_gtrimmednurbsshell.html#a1">GTrimmedNurbsShell</a>();
        virtual <a class="code" href="class_gtrimmednurbsshell.html#a2">~GTrimmedNurbsShell</a>();

        // ! the base surface
        <a class="code" href="class_gnurbsshell.html">GNurbsShell</a> *surface;

        // array trimmingCurves;

        // ! set the base surface
        gbool <a class="code" href="class_gtrimmednurbsshell.html#a3">SetSurface</a>(<a class="code" href="class_gnurbsshell.html">GNurbsShell</a> *newSurface);

        gbool <a class="code" href="class_gtrimmednurbsshell.html#a4">BeginTrim</a>(void);
        
        gbool <a class="code" href="class_gtrimmednurbsshell.html#a5">AddNurbsTrimmingCurve2D</a>(
                                           int order, 
                                           int numControlPoint,const float *controlPoint, 
                                           int numWeight,const float* weight, 
                                           int numKnot, const float* knot, 
                                           int tessellations );

        gbool <a class="code" href="class_gtrimmednurbsshell.html#a6">AddPolyline2D</a>(int numOfPoints, const float* points);

        gbool <a class="code" href="class_gtrimmednurbsshell.html#a7">EndTrim</a>(void);

        // ! delete all trimming curves
        gbool <a class="code" href="class_gtrimmednurbsshell.html#a8">DeleteTrimmingCurves</a>();

        int <a class="code" href="class_gtrimmednurbsshell.html#a9">ComputeShell</a>();
        
        gbool changed;

        // notify
        void <a class="code" href="class_gobject.html#a0">SetChanged</a>() { changed = gtrue; }
        void <a class="code" href="class_gtrimmednurbsshell.html#a11">SetSurfaceChanged</a>() { <a class="code" href="class_gobject.html#a0">SetChanged</a>(); }
        void <a class="code" href="class_gtrimmednurbsshell.html#a12">SetTrimmingChanged</a>() { <a class="code" href="class_gobject.html#a0">SetChanged</a>(); }

        gbool <a class="code" href="class_gtrimmednurbsshell.html#a13">IsShellTessellationOk</a>() const {
                if ( tessellationChanged || changed)
                        return gfalse;
                return gtrue;
        }

        int <a class="code" href="class_gtrimmednurbsshell.html#a14">SetRenderQuality</a>(float budget);


private:
        float m_fRenderQuality;

        gbool tessellationChanged;

        float <a class="code" href="class_gtrimmednurbsshell.html#c0">ComputeBBSurface</a>(<a class="code" href="class_matrix.html">Matrix</a> &amp;model2view, <a class="code" href="class_matrix.html">Matrix</a> &amp;projection, float w, float h);

        void <a class="code" href="class_gtrimmednurbsshell.html#c1">SetTessellation</a>(int nUTessellations, int nVTessellations);

        //computes new tessellation values depending on mode , quality bbox
        int <a class="code" href="class_gtrimmednurbsshell.html#c2">ComputeTessellationValues</a>(int mode);


        // virtual ovvrrides for GShell

        void <a class="code" href="class_gshell.html#a59">ComputeBBox</a>(<a class="code" href="class_bbox.html">BBox</a> &amp;<a class="code" href="class_box.html">box</a>);

        int <a class="code" href="class_gnode.html#a4">Do</a>(<a class="code" href="class_gbboxtraversal.html">GBBoxTraversal</a> &amp;state);       

        // check if vertices or shell need to be recomputed
        int <a class="code" href="class_gnode.html#a4">Do</a>(<a class="code" href="class_gglrendertraversal.html">GglRenderTraversal</a> &amp;state);
        int <a class="code" href="class_gnode.html#a4">Do</a>(<a class="code" href="class_grayselecttraversal.html">GRaySelectTraversal</a> &amp;state);
        
        float m_ScaleFactor;   
 
        float m_TessTol;       


        float m_DomainTessTol; 



        int m_MaxSubDivisions; 


#if defined(G_T_NURBS)

        trim_partition mContours2D;   
        
        ListNode&lt;trim_region&gt; *contour;
        
        ListNode&lt;trim_element&gt; *elnode;

#ifdef _LOG_TRIMMED_
    void dump_to_file();
#endif


#endif


};


#endif __gnurbsshell__
</div></pre><hr><address><small>Generated at Thu Jan 27 18:56:20 2000 for blaxxunContact3D by
<a href="http://www.stack.nl/~dimitri/doxygen/index.html">
<img src="doxygen.gif" alt="doxygen" align=center border=0 
width=118 height=53></a> 1.0.0 written by <a href="mailto:dimitri@stack.nl">Dimitri van Heesch</a>,
 &copy; 1997-1999</small></address>
</body>
</html>

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta name="robots" content="noindex">
<title>GvSceneInfo Include File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body bgcolor="#ffffff">
<!-- Generated by Doxygen 1.0.0 on Thu Jan 27 18:49:50 2000 -->
<center>
<a class="qindex"href="index.html">Main Page</a> &nbsp; <a class="qindex"href="namespaces.html">Namespace List</a> &nbsp; <a class="qindex"href="hierarchy.html">Class Hierarchy</a> &nbsp; <a class="qindex"href="annotated.html">Compound List</a> &nbsp; <a class="qindex"href="files.html">File List</a> &nbsp; <a class="qindex"href="headers.html">Header Files</a> &nbsp; <a class="qindex"href="namespacemembers.html">Namespace Members</a> &nbsp; <a class="qindex"href="functions.html">Compound Members</a> &nbsp; <a class="qindex"href="globals.html">File Members</a> &nbsp; </center>
<hr><h1>gvtraverse.h</h1>This is the verbatim text of the gvtraverse.h include file.<div class="fragment"><pre>/*=============================================================================

This code is licensed under the Web3D-blaxxun Community Source License,
provided in distribution file LICENSE.TXT and available online at
http://www.web3D.org/TaskGroups/x3d/blaxxun/Web3D-blaxxunCommunitySourceAgreement.html
and may only be used for non-commercial use as specified in that license.

THE WEB3D CONSORTIUM AND BLAXXUN DO NOT MAKE AND HEREBY DISCLAIM ANY EXPRESS
OR IMPLIED WARRANTIES RELATING TO THIS CODE, INCLUDING BUT NOT LIMITED TO,
WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY OR FITNESS FOR A PARTICULAR
PURPOSE, OR ANY WARRANTIES THAT MIGHT ARISE FROM A COURSE OF DEALING, USAGE
OR TRADE PRACTICE.  THE COMMUNITY SOURCE CODE IS PROVIDED UNDER THIS
AGREEMENT "AS IS," WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
INCLUDING, WITHOUT LIMITATION, WARRANTIES THAT THE COMMUNITY SOURCE CODE ARE
FREE OF DEFECTS, MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE OR
NON-INFRINGING OR IN ANY WAY CONSTITUTE THE COMPLETE PRODUCT MARKETED UNDER
THE NAMES GIVEN SAID CODE.

==============================================================================*/
#ifndef _GvTraverse
#define _GvTraverse

#include "arraynew.h"

#include "gshell.h"
#include "gvisibility.h"
#include "gcamera.h"

#include &lt;gvpath.h&gt;
#include &lt;gvmfnode.h&gt;


// scene enable flags 
class <a class="code" href="class_gvsceneflags.html">GvSceneFlags</a> {
public:
        int light;
        int spotLight;
        int pointLight;
        int camera;
        int texture2;
        int WWWinline;
        <a class="code" href="class_gvsceneflags.html#a0">GvSceneFlags</a>() {
                        light = 1;
                        spotLight = 1;
                        pointLight = 1;
                        camera = 1;
                        texture2 = 1;
                        WWWinline = 1;
        }
};

/* register all qv property elements for  nodes to state */
void <a class="code" href="gvtraverse.h.html#a0">InitializeGvAttributes</a>(<a class="code" href="class_gtraversal.html">GTraversal</a> &amp;state,int all=1);


class <a class="code" href="class_gvbackground.html">GvBackground</a>;
class <a class="code" href="class_gvfog.html">GvFog</a>;
class <a class="code" href="class_gvnavigationinfo.html">GvNavigationInfo</a>;
class <a class="code" href="class_gvworldinfo.html">GvWorldInfo</a>;

class GvMaterial;
class GvTexture2;
class GvWWWInline;
class <a class="code" href="class_gvnode.html">GvNode</a>;
class <a class="code" href="class_gvnodeshell.html">GvNodeShell</a>;
class <a class="code" href="class_gshell.html">GShell</a>;
class GvWWWInline;
class GvWWWAnchor;
class GvWWWRegionAnchor;
class GvMorph;
class GvSwitch;
class GvInfo;

class <a class="code" href="class_gvtimesensor.html">GvTimeSensor</a>;


// flags returned by material apply functions
enum MATERIAL_RETURN_FLAGS {
                        MATERIAL_IS_UNLIT  = 1,         // turn of lights
                        MATERIAL_HAS_ALPHA = 2,         // has transparency
                        MATERIAL_SET_DIFFUSE_WHITE = 4, // set diffuse color to white (for textures)
                        MATERIAL_FULLY_TRANSPARENT = 8  // fully transparent, don't draw

};

// flags from the texture setting functions
enum TEXTURE_RETURN_FLAGS {
                        TEXTURE_DEFINED = 1,
                        TEXTURE_HAS_ALPHA = 2,          // texture has some alpha channel
                        TEXTURE_HAS_COLORKEY = 4,
                        TEXTURE_MODULATE = 8,
                        TEXTURE_CHANGED = 16    //D3D handle of texture may changed
};



//
// an object collecting information about a VRML scene tree
//
class <a class="code" href="class_gvsceneinfo.html">GvSceneInfo</a> {
public : 
        int nodeCnt;

        // extended 
        int geometryCnt;
        int faceCnt;
        int textureCnt;
        
        GvBool full; // check full 
        
    <a class="code" href="class_gvnode.html">GvNode</a> *top;

        // VRML 2 bindable nodes
        <a class="code" href="class_gvbackground.html">GvBackground</a>    * firstBackground;
        <a class="code" href="class_gvfog.html">GvFog</a>           *firstFog;
        <a class="code" href="class_gvnavigationinfo.html">GvNavigationInfo</a> *firstNavigationInfo;
        <a class="code" href="class_gvworldinfo.html">GvWorldInfo</a>     *firstWorldInfo;

    GvMaterial *firstMaterial;
        <a class="code" href="class_gvtexture.html">GvTexture</a> *firstTexture;
        <a class="code" href="class_gvnode.html">GvNode</a> *firstAnimated;
        <a class="code" href="class_gvnode.html">GvNode</a> *firstGeometrySensor;
        <a class="code" href="class_gvnode.html">GvNode</a> *firstCamera;
        <a class="code" href="class_gvnode.html">GvNode</a> *firstLight;
        <a class="code" href="class_gvnode.html">GvNode</a> *firstPointLight;
        <a class="code" href="class_gvnode.html">GvNode</a> *firstSpotLight;
        <a class="code" href="class_gvnodeshell.html">GvNodeShell</a> *firstNodeShell;
        <a class="code" href="class_gshell.html">GShell</a> *firstShell;
        
        GvWWWInline *firstWWWInline;
        GvWWWAnchor *firstWWWAnchor;
        GvWWWRegionAnchor *firstWWWRegionAnchor;

        GvSwitch *firstCameraSwitch;
        GvSwitch *firstCameraKeyframe;
        
        GvMorph *firstMorph;


        // info nodes
        GvInfo *viewerInfo;
        GvInfo *viewerSpeed;
        GvInfo *sceneInfo;
        GvInfo *title;
        GvInfo *backgroundColor;
        GvInfo *backgroundImage;
        GvInfo *renderMode;
    GvInfo *animateViewpoints;  

        // 18.08.97 HG changed from GvNode* to  GvNodeHandle
        <a class="code" href="class_arraynew.html">ArrayNew</a>&lt;<a class="code" href="class_gvnodehandle.html">GvNodeHandle</a>&gt; cameras;

        <a class="code" href="class_array.html">Array</a>&lt;<a class="code" href="class_matrix.html">Matrix</a>&gt;  cameraTransforms;

        <a class="code" href="class_arraynew.html">ArrayNew</a>&lt;<a class="code" href="class_gvnodehandle.html">GvNodeHandle</a>&gt; lights; 
        <a class="code" href="class_arraynew.html">ArrayNew</a>&lt;<a class="code" href="class_gvpath.html">GvPath</a>&gt;  lightPath;    // pathes to lights 

        double nextScheduleTime;

        <a class="code" href="class_gvmfnode.html">GvMFNode</a> timeSensors;   
        <a class="code" href="class_gvmfnode.html">GvMFNode</a> audioClips;    
        <a class="code" href="class_gvmfnode.html">GvMFNode</a> sounds;                

        <a class="code" href="class_gvmfnode.html">GvMFNode</a> specialMedia;  

        <a class="code" href="class_gvmfnode.html">GvMFNode</a> movieTextures; 

        <a class="code" href="class_gvmfnode.html">GvMFNode</a> scripts;       

        <a class="code" href="class_gvmfnode.html">GvMFNode</a> menueSensors; 

        <a class="code" href="class_gvmfnode.html">GvMFNode</a> inlines; 

    int <a class="code" href="class_gvsceneinfo.html#a0">TriggerTimeSensors</a>(double t);

    int <a class="code" href="class_gvsceneinfo.html#a1">TriggerMovieTextures</a>(double t);

    int <a class="code" href="class_gvsceneinfo.html#a2">TriggerMedia</a>(double t);

    int <a class="code" href="class_gvsceneinfo.html#a3">TermMedia</a>();

        int <a class="code" href="class_gvsceneinfo.html#a4">UnloadSomeInlines</a>(double currentT,int activeLimit, int numToUnload);


        
        <a class="code" href="class_gvsceneinfo.html#a5">GvSceneInfo</a>();
        <a class="code" href="class_gvsceneinfo.html#a6">~GvSceneInfo</a>();


        void <a class="code" href="class_gvsceneinfo.html#a7">Zero</a>();

        // flush all node references
        void <a class="code" href="class_gvsceneinfo.html#a8">Flush</a>(); 

        GvBool <a class="code" href="class_gvsceneinfo.html#a9">HasTextures</a>() const { return(firstTexture != 0); }
        
        GvBool <a class="code" href="class_gvsceneinfo.html#a10">HasLights</a>() const { return(firstLight != 0); }
        
    GvBool <a class="code" href="class_gvsceneinfo.html#a11">HasTimeSensors</a>() const { return(timeSensors.<a class="code" href="class_gvmfield.html#a8">Length</a>() &gt; 0); }

    GvBool <a class="code" href="class_gvsceneinfo.html#a12">HasMovieTextures</a>() const { return(movieTextures.<a class="code" href="class_gvmfield.html#a8">Length</a>() &gt; 0); }

    GvBool <a class="code" href="class_gvsceneinfo.html#a13">HasAudioClips</a>() const { return(audioClips.<a class="code" href="class_gvmfield.html#a8">Length</a>() &gt; 0); }

    GvBool <a class="code" href="class_gvsceneinfo.html#a14">HasMedia</a>() const { return (
                                                            (audioClips.<a class="code" href="class_gvmfield.html#a8">Length</a>() &gt; 0) 
                                                         || (sounds.<a class="code" href="class_gvmfield.html#a8">Length</a>() &gt; 0)
                                                         || (specialMedia.<a class="code" href="class_gvmfield.html#a8">Length</a>() &gt; 0)
                                                         );
        }

    GvBool <a class="code" href="class_gvsceneinfo.html#a15">HasMenueSensors</a>() const { return(menueSensors.<a class="code" href="class_gvmfield.html#a8">Length</a>() &gt; 0); }
        
    GvBool <a class="code" href="class_gvsceneinfo.html#a16">HasCamera</a>() const  { return(firstCamera != 0); }
        
    GvBool <a class="code" href="class_gvsceneinfo.html#a17">IsAnimated</a>() const  { return(firstAnimated != 0) || <a class="code" href="class_gvsceneinfo.html#a12">HasMovieTextures</a>(); }
        
        GvBool <a class="code" href="class_gvsceneinfo.html#a18">HasBackgroundImage</a>() const { return(backgroundImage != 0); }


        int <a class="code" href="class_gvsceneinfo.html#a19">Do</a>(<a class="code" href="class_gpathtraversal.html">GPathTraversal</a> &amp;state,<a class="code" href="class_gnode.html">GNode</a> *n); 
};

//
// GGvSceneInfoTraversal
// traverse nodes, and gather some information into sceneInfo
//
class <a class="code" href="class_ggvsceneinfotraversal.html">GGvSceneInfoTraversal</a> : public <a class="code" href="class_gpathtraversal.html">GPathTraversal</a> {

public :
        <a class="code" href="class_gpathtraversal.html#a0">RT</a>(<a class="code" href="class_ggvsceneinfotraversal.html">GGvSceneInfoTraversal</a>);

        <a class="code" href="class_ggvsceneinfotraversal.html#a1">GGvSceneInfoTraversal</a>() : <a class="code" href="class_gpathtraversal.html">GPathTraversal</a>() { }

        <a class="code" href="class_gvsceneinfo.html">GvSceneInfo</a> sceneInfo;


        void <a class="code" href="class_ggeometrytraversal.html#a2">InitializeAttributes</a>() {
                <a class="code" href="gvtraverse.h.html#a0">InitializeGvAttributes</a>(*this);
                <a class="code" href="class_ggeometrytraversal.html#a2">GPathTraversal :: InitializeAttributes</a>();
        }

        int <a class="code" href="class_gpathtraversal.html#a3">Do</a>(<a class="code" href="class_gnode.html">GNode</a> *n);

};


class <a class="code" href="class_ggvbboxtraversal.html">GGvBBoxTraversal</a> : public <a class="code" href="class_gbboxtraversal.html">GBBoxTraversal</a>
{
public :
        <a class="code" href="class_gbboxtraversal.html#a0">RT</a>(<a class="code" href="class_ggvbboxtraversal.html">GGvBBoxTraversal</a>);
        
        <a class="code" href="class_ggvbboxtraversal.html#a1">GGvBBoxTraversal</a>() : <a class="code" href="class_gbboxtraversal.html">GBBoxTraversal</a>() {} 
        void <a class="code" href="class_gbboxtraversal.html#a5">InitializeAttributes</a>() {
                <a class="code" href="gvtraverse.h.html#a0">InitializeGvAttributes</a>(*this);
                <a class="code" href="class_gbboxtraversal.html#a5">GBBoxTraversal :: InitializeAttributes</a>();
        }

};

class <a class="code" href="class_renderstate.html">RenderState</a>;

//
// helper structure to collect transparent items
//

class <a class="code" href="class_gtransparentelement.html">GTransparentElement</a>  {
public :
        float key; // sort key
        
        <a class="code" href="class_point.html">Point</a> center; // in world space 

        <a class="code" href="class_matrix.html">Matrix</a> m; // transformation matrix
        
        <a class="code" href="class_gvnode.html">GvNode</a> *appearance;     // appearances node
        <a class="code" href="class_gvnode.html">GvNode</a> *geometry;       // the geometry node
        <a class="code" href="class_gtransparentelement.html#a0">GTransparentElement</a>(<a class="code" href="class_gvnode.html">GvNode</a> *appearance,<a class="code" href="class_gvnode.html">GvNode</a> *geometry,const <a class="code" href="class_bbox.html">BBox</a>&amp; bbox,const <a class="code" href="class_matrix.html">Matrix</a>&amp; m);

        // draw the element
        int <a class="code" href="class_gbboxtraversal.html#a4">Do</a>(<a class="code" href="class_gglrendertraversal.html">GglRenderTraversal</a> &amp;state); 

};



// do cull check wihth shells bounding box
inline gbool <a class="code" href="gvtraverse.h.html#a1">CullCheck</a>(<a class="code" href="class_gshell.html">GShell</a> *theShell,<a class="code" href="class_gglrendertraversal.html">GglRenderTraversal</a> &amp;state)
{
#if 1
        // to think : could turn off checking if parent matrices says all inside
        if (state.doViewCulling /* &amp;&amp; state.doClipping */ )
        {
                <a class="code" href="class_gmatrixstack.html">GMatrixStack</a> *mstack = state.GetCurrentMatrix();        
                if (mstack-&gt;m.contents &amp; ( Matrix::HAS_NEGATIVE_SCALE) )  {
                    state.doClipping = gtrue;
                        return gtrue; // not working with neg scale 
                }

                if (!mstack-&gt;viewpointLocalOk) { // need to transform it 
                        mstack-&gt;<a class="code" href="class_gmatrixstack.html#a8">SetViewpointLocal</a>(state.physicalCamera-&gt;position);      
                }  

                if (!mstack-&gt;viewVolumeLocalOk) {
                        mstack-&gt;<a class="code" href="class_gmatrixstack.html#a9">SetViewVolumeLocal</a>(state.viewVolume); 
                }
                
                if (<a class="code" href="gvisibility.h.html#a8">BoxViewVolumeOutside</a>(theShell-&gt;<a class="code" href="class_gshell.html#a60">GetBBox</a>(),mstack-&gt;viewpointLocal,mstack-&gt;viewVolumeLocal,state.doClipping)) { 
                        return gfalse;
                }

        }
#endif
        return gtrue;
}


class <a class="code" href="class_ggvglrendertraversal.html">GGvglRenderTraversal</a> : public <a class="code" href="class_gglrendertraversal.html">GglRenderTraversal</a>
{
public:
        <a class="code" href="class_gbboxtraversal.html#a0">RT</a>(<a class="code" href="class_ggvglrendertraversal.html">GGvglRenderTraversal</a>);

        <a class="code" href="class_ggvglrendertraversal.html#a1">GGvglRenderTraversal</a>(<a class="code" href="class_renderstate.html">RenderState</a> * GlState=0) : <a class="code" href="class_gglrendertraversal.html">GglRenderTraversal</a>(GlState) { } 
        <a class="code" href="class_ggvglrendertraversal.html#a2">~GGvglRenderTraversal</a>();

        void <a class="code" href="class_gbboxtraversal.html#a5">InitializeAttributes</a>();

        // don't draw fully transparent geometry
        gbool <a class="code" href="class_ggvglrendertraversal.html#a4">IsFullyTransparent</a>() {
                return (materialStatus &amp; MATERIAL_FULLY_TRANSPARENT)!=0;
                }

        // should this geometry node be drawed later ??
        gbool <a class="code" href="class_ggvglrendertraversal.html#a5">IsDelayed</a>() {
                return ((transparencyMode &gt; GTRANSPARENCY_NONE) 
                        &amp;&amp; ((materialStatus &amp; MATERIAL_HAS_ALPHA)
                        || (textureStatus &amp; TEXTURE_HAS_ALPHA)));
        }
        

        // the list of transparent elements, memory owned by this class
        <a class="code" href="class_array.html">Array</a>&lt;<a class="code" href="class_gtransparentelement.html">GTransparentElement</a>*&gt; transparentElements;

        // any transparent elements ?
        gbool <a class="code" href="class_ggvglrendertraversal.html#a6">HasTransparentElements</a>() { return transparentElements.<a class="code" href="class_array.html#a21">Length</a>()&gt;0; }

        // add element to transparent list
        void <a class="code" href="class_ggvglrendertraversal.html#a7">AddTransparentElement</a>(<a class="code" href="class_gtransparentelement.html">GTransparentElement</a> *element);

        // delete all transparent elements
        void <a class="code" href="class_ggvglrendertraversal.html#a8">DeleteTransparentElements</a>();

        // sort &amp; render the transparent elements
        int <a class="code" href="class_ggvglrendertraversal.html#a9">DoTransparentElements</a>();

        // fully process the transparent elements, and clean list at end
        virtual int <a class="code" href="class_grendertraversal.html#a3">RenderTransparentElements</a>();


};

// traverse nodes, load inlines 
//
class <a class="code" href="class_gloadinlinestraversal.html">GLoadInlinesTraversal</a> : public <a class="code" href="class_ggeometrytraversal.html">GGeometryTraversal</a> 
{

public :
        <a class="code" href="class_gbboxtraversal.html#a0">RT</a>(<a class="code" href="class_gloadinlinestraversal.html">GLoadInlinesTraversal</a>);

        <a class="code" href="class_gloadinlinestraversal.html#a1">GLoadInlinesTraversal</a>() : <a class="code" href="class_ggeometrytraversal.html">GGeometryTraversal</a>() { 
                stopOnFirst = 0; resolveRelativeUrls = FALSE; 
        }


        // if TRUE, mode is relativeUrl resolution
        GvBool resolveRelativeUrls; 

/*
        // retreived via stack attribute 

        GvString currentHomeUrl;

        const GvString &amp; getHomeUrl() { return currentHomeUrl; }
        void setHomeUrl(const GvString &amp;s) { currentHomeUrl = s; }
*/

        int stopOnFirst;

        void <a class="code" href="class_gbboxtraversal.html#a5">InitializeAttributes</a>() {
                <a class="code" href="gvtraverse.h.html#a0">InitializeGvAttributes</a>(*this);
                <a class="code" href="class_ggeometrytraversal.html#a2">GGeometryTraversal :: InitializeAttributes</a>();
        }

        int <a class="code" href="class_gbboxtraversal.html#a4">Do</a>(<a class="code" href="class_gnode.html">GNode</a> *n) {      return (n-&gt;<a class="code" href="class_gnode.html#a4">Do</a>(*this)); }

};


#endif
</div></pre><hr><address><small>Generated at Thu Jan 27 18:49:50 2000 for blaxxunContact3D by
<a href="http://www.stack.nl/~dimitri/doxygen/index.html">
<img src="doxygen.gif" alt="doxygen" align=center border=0 
width=118 height=53></a> 1.0.0 written by <a href="mailto:dimitri@stack.nl">Dimitri van Heesch</a>,
 &copy; 1997-1999</small></address>
</body>
</html>

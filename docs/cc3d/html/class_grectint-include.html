<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta name="robots" content="noindex">
<title>GRectInt Include File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body bgcolor="#ffffff">
<!-- Generated by Doxygen 1.0.0 on Thu Jan 27 18:46:19 2000 -->
<center>
<a class="qindex"href="index.html">Main Page</a> &nbsp; <a class="qindex"href="namespaces.html">Namespace List</a> &nbsp; <a class="qindex"href="hierarchy.html">Class Hierarchy</a> &nbsp; <a class="qindex"href="annotated.html">Compound List</a> &nbsp; <a class="qindex"href="files.html">File List</a> &nbsp; <a class="qindex"href="headers.html">Header Files</a> &nbsp; <a class="qindex"href="namespacemembers.html">Namespace Members</a> &nbsp; <a class="qindex"href="functions.html">Compound Members</a> &nbsp; <a class="qindex"href="globals.html">File Members</a> &nbsp; </center>
<hr><h1>gutils.h</h1>This is the verbatim text of the gutils.h include file.<div class="fragment"><pre>/*=============================================================================

This code is licensed under the Web3D-blaxxun Community Source License,
provided in distribution file LICENSE.TXT and available online at
http://www.web3D.org/TaskGroups/x3d/blaxxun/Web3D-blaxxunCommunitySourceAgreement.html
and may only be used for non-commercial use as specified in that license.

THE WEB3D CONSORTIUM AND BLAXXUN DO NOT MAKE AND HEREBY DISCLAIM ANY EXPRESS
OR IMPLIED WARRANTIES RELATING TO THIS CODE, INCLUDING BUT NOT LIMITED TO,
WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY OR FITNESS FOR A PARTICULAR
PURPOSE, OR ANY WARRANTIES THAT MIGHT ARISE FROM A COURSE OF DEALING, USAGE
OR TRADE PRACTICE.  THE COMMUNITY SOURCE CODE IS PROVIDED UNDER THIS
AGREEMENT "AS IS," WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
INCLUDING, WITHOUT LIMITATION, WARRANTIES THAT THE COMMUNITY SOURCE CODE ARE
FREE OF DEFECTS, MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE OR
NON-INFRINGING OR IN ANY WAY CONSTITUTE THE COMPLETE PRODUCT MARKETED UNDER
THE NAMES GIVEN SAID CODE.

==============================================================================*/
#ifndef _gutils_h
#define _gutils_h
/******************************************************************************
@doc

@module GUtils.h - GLView utility routines      |

Copyright (c) 1995      by Holger Grahn
All rights reserved

Purpose:
genric type defines

Template functions for min swap
PI ...
DEG2RAD

Classes:

Notes:

Changes:

$Revision: 1.9 $
$Log: gutils.h,v $
Revision 1.9  1999/07/06 16:55:13  tom
*** empty log message ***


Todo :

******************************************************************************/


// generic type defines

// unicode capable char type
#ifdef WIN32

typedef TCHAR gchar;

#else

typedef char gchar;

#endif

#define GFLOAT_IS_DOUBLE 0
#define GFLOAT_IS_FLOAT 1

typedef float gfloat;
typedef double gdouble;
typedef bool gbool;

#define gtrue true
#define gfalse false


// floating point control
void <a class="code" href="gutils.h.html#a20">GFPInit</a>();

// terminitate floating point control
void <a class="code" href="gutils.h.html#a21">GFPTerm</a>();

// reset floating point control word, might be changed by other components
void <a class="code" href="gutils.h.html#a22">GFPSetControl</a>();

#ifdef _M_IX86

// C++ RTL library float to int conversion is very slow
// because it changes FPU rounding mode

inline int <a class="code" href="gutils.h.html#a23">float2int</a>(float f)
{
  int i;
  __asm {
    fld f
    fistp i
  }
  return i;
}

inline int <a class="code" href="gutils.h.html#a23">float2int</a>(double f)
{
  int i;
  __asm {
    fld f
    fistp i
  }
  return i;
}

#else

inline int <a class="code" href="gutils.h.html#a23">float2int</a>(float f)
{
  return (int)f;
}

inline int <a class="code" href="gutils.h.html#a23">float2int</a>(double f)
{
  return (int)f;
}

#endif

// float / double to int 
template&lt;class T&gt;
inline int
toInt(T <a class="code" href="class_a.html">a</a>) { return( (int) <a class="code" href="class_a.html">a</a>); }





#ifdef max
#undef max
#endif
#ifdef min
#undef min
#endif

//inline float max(float a,float b) { return( (a&gt;b) ? a : b); }
//inline int max(int a,int b) { return( (a&gt;b) ? a : b); }
//inline int max(int a,int b,int c) { return( (a&gt;b) ? max(a,c) : max(b,c)); }
//inline float sqr(float a) { return(a*a); }

template&lt;class T&gt;
inline void
Swap(T&amp; x, T&amp; y) { T temp = x; x = y; y = temp; }

template&lt;class T&gt;
inline T
max(const T <a class="code" href="class_a.html">a</a>, const T b) { return( (<a class="code" href="class_a.html">a</a>&gt;b) ? <a class="code" href="class_a.html">a</a> : b); }


template&lt;class T&gt;
inline T
min(const T <a class="code" href="class_a.html">a</a>, const T b) { return( (<a class="code" href="class_a.html">a</a>&lt;b) ? <a class="code" href="class_a.html">a</a> : b); }



// limit a to range mi .. ma
template&lt;class T&gt;
inline T
limit(const T <a class="code" href="class_a.html">a</a>, const T mi,const T ma) 
{ 
    if (<a class="code" href="class_a.html">a</a>&lt;mi) return(mi);
    return( (<a class="code" href="class_a.html">a</a>&gt;ma) ? ma : <a class="code" href="class_a.html">a</a>); 
}


//template&lt;class T&gt;
//inline T
//min(const T&amp; a, const T&amp; b) { return( (a&lt;b) ? a : b); }

template&lt;class T&gt;
inline T
sqr(const T <a class="code" href="class_a.html">a</a>) { return (<a class="code" href="class_a.html">a</a>*<a class="code" href="class_a.html">a</a>); }

inline float <a class="code" href="gutils.h.html#a27">max</a>(float <a class="code" href="class_a.html">a</a>,float b,float c) { return( (<a class="code" href="class_a.html">a</a>&gt;b) ? <a class="code" href="gutils.h.html#a27">max</a>(<a class="code" href="class_a.html">a</a>,c) : max(b,c)); }


/* PI, DEG, RAD */
#ifndef _PI
#define _PI 3.141592653589793238462643383279502884197169399
#endif

#define Pi      _PI
#define PI      _PI
#define TWOPI    (2*PI)
#define DEG(ANG) ((ANG)*PI/180.0)
#define DEG2RAD(ANG) ((ANG)*PI/180.0)
#define RAD2DEG(ANG) ((ANG)*180.0/PI)

const double Deg2Rad= PI/180.0;
const double Rad2Deg = 180.0/PI;


#define FLOAT_MAX (float)1e30

#define ELEMENTS(array) (sizeof(array)/sizeof((array)[0]))


#if 1
#define MALLOCT(NELEMENTS,OFTYPE)  (OFTYPE *) MALLOC(((NELEMENTS) * sizeof(OFTYPE)))
#define CALLOCT(NELEMENTS,OFTYPE)  (OFTYPE *) CALLOC(NELEMENTS, sizeof(OFTYPE))
#define REALLOCT(PTR,NELEMENTS,OFTYPE)  (OFTYPE *) REALLOC(PTR,(NELEMENTS) * sizeof(OFTYPE))
#define FREET(PTR) FREE(PTR)
#endif


#define EPS 0.000009
// #define iszero(f)  (((f)&lt;0.000009)&amp;&amp;((f)&gt; -0.000009))

inline gbool iszero(float f)  { return (((f)&lt;0.000009)&amp;&amp;((f)&gt; -0.000009)); }

// a cectangle in position size form
// x+dx is part of rectangle
class <a class="code" href="class_grect.html">GRect</a> {

public:

        float x,y,dx,dy;

        inline gbool <a class="code" href="class_grect.html#a0">IsEmpty</a>() const { return(dx &lt;=0 || dy &lt;= 0); }

    //@cmember is Point p inside ?
    inline gbool <a class="code" href="class_grect.html#a1">Inside</a>(float px,float py) const {
                                return( (px&gt;=x) &amp;&amp; (px &lt;= (x+dx))
                                                &amp;&amp; (py&gt;=y) &amp;&amp; (py &lt;= (y+dy))
                                                );

        }

    //@cmember is Point p outside ?
        inline gbool <a class="code" href="class_grect.html#a2">Outside</a>(float px,float py) const {
                                return( (px &lt; x) || (px  &gt; (x+dx))
                                                || (py &lt; y) || (py  &gt; (y+dy))
                                                );
        }

};

// a rectangle in position lower left +  size form
// note :  points x+dx,y+dy are not part of rectangle
//

class <a class="code" href="class_grectint.html">GRectInt</a> {

public:

        int x,y,dx,dy;

        // the x coordinate of the right point (not part of rectangle)
        int <a class="code" href="class_grectint.html#a0">Right</a>() const { return x+dx; }
        int <a class="code" href="class_grectint.html#a1">Top</a>() const { return y+dy; }


        inline gbool <a class="code" href="class_grectint.html#a2">IsEmpty</a>() const { return(dx &lt;=0 || dy &lt;= 0); }

    //@cmember is Point p inside ?
    inline gbool <a class="code" href="class_grectint.html#a3">Inside</a>(int px,int py) const {
                                return( (px&gt;=x) &amp;&amp; (px &lt; (x+dx))
                                                &amp;&amp; (py&gt;=y) &amp;&amp; (py &lt; (y+dy))
                                                );

        }

    //@cmember is Point p outside ?
        inline gbool <a class="code" href="class_grectint.html#a4">Outside</a>(int px, int py) const {
                                return ((px &lt; x) || (px  &gt;= (x+dx))
                                                || (py &lt; y) || (py  &gt;= (y+dy))
                                                );
        }

    //@cmember is BBox b outside ?
    inline gbool  <a class="code" href="class_grectint.html#a4">Outside</a>(const <a class="code" href="class_grectint.html">GRectInt</a> &amp;b) const {
                                return ((b.Right() &lt;= x) || (b.x &gt;= <a class="code" href="class_grectint.html#a0">Right</a>())
                                                || (b.Top() &lt;= y) || (b.y &gt;= <a class="code" href="class_grectint.html#a1">Top</a>())
                                                );

        };

};


void <a class="code" href="gutils.h.html#a33">copylist</a>(int *dest,const int *src,int cnt);

// append appendlist to list,
int append(int * &amp;list,int &amp; nlist, int &amp; listmax, const int *appendlist,int nappendlist);

// return random number between 0 and 1
inline float <a class="code" href="gutils.h.html#a35">Rnd</a>() {   return ((float) rand() / RAND_MAX); }


//\@class Template PtrHandle class
//\@tcarg class | T | A class to maintain a pointer to a allocted datastructure

template&lt;class T&gt;
class <a class="code" href="class_ptrhandle.html">PtrHandle</a> {
protected :
        T* p;           // Pointer to data

public:
        // constructors
        <a class="code" href="class_ptrhandle.html#a0">PtrHandle</a>() { p = 0;}
        <a class="code" href="class_ptrhandle.html#a0">PtrHandle</a>(T* newP) { p = newP; }
        
        <a class="code" href="class_ptrhandle.html#a2">~PtrHandle</a>() { <a class="code" href="class_ptrhandle.html#a3">Delete</a>(); }
        
        void <a class="code" href="class_ptrhandle.html#a3">Delete</a>() { if(p) { delete p; p = NULL; } }

        
        operator T*() { return(p); }
        
        <a class="code" href="class_ptrhandle.html">PtrHandle</a>&lt;T&gt;&amp; operator= (T* newP) { 
                if (p!=newP) {
                        <a class="code" href="class_ptrhandle.html#a3">Delete</a>();
                        p = newP; 
                }
                return(*this);
        }
        

};



// string utils 

// #define streq(a,b) (strcmp(a,b) == 0)
inline int <a class="code" href="gutils.h.html#a36">streq</a>(const char *<a class="code" href="class_a.html">a</a>, const char *b)  { return strcmp(<a class="code" href="class_a.html">a</a>,b) == 0; }
inline int <a class="code" href="gutils.h.html#a37">strgt</a>(const char *<a class="code" href="class_a.html">a</a>, const char *b)  { return strcmp(<a class="code" href="class_a.html">a</a>,b) &gt;  0; }
inline int <a class="code" href="gutils.h.html#a38">strlt</a>(const char *<a class="code" href="class_a.html">a</a>, const char *b)  { return strcmp(<a class="code" href="class_a.html">a</a>,b) &lt;  0; }
inline int <a class="code" href="gutils.h.html#a39">strneq</a>(const char *<a class="code" href="class_a.html">a</a>, const char *b) { return strcmp(<a class="code" href="class_a.html">a</a>,b) != 0; }

inline int <a class="code" href="gutils.h.html#a40">strieq</a>(const char *<a class="code" href="class_a.html">a</a>, const char *b)  { return _stricmp(<a class="code" href="class_a.html">a</a>,b) == 0; }


// check if string prefix occurs at the beggin of str
// return 1 if prefix, 0 if not 
int <a class="code" href="gutils.h.html#a41">strprefix</a>(const char *str, const char * prefix);
int <a class="code" href="gutils.h.html#a42">striprefix</a>(const char *str, const char * prefix);


// return true if c is the last char of s
int <a class="code" href="gutils.h.html#a43">strsuffix</a>(const char *s,char c);


// return entry in s, where suffix is at end
// null if s has not suffix
const char* <a class="code" href="gutils.h.html#a43">strsuffix</a>(const char *s,const char *suffix);
const char* <a class="code" href="gutils.h.html#a45">strisuffix</a>(const char *s,const char *suffix);


// get the first index of search in string, -1 if not found
int indexOf(const char *string,const char *search,int fromIndex);

// get the last index of search in string, -1 if not found
int lastIndexOf(const char *string,const char *search,int fromIndex);

// set out to the subsing of s[index1:index2]
// out must be large enought, empty string if bad data
char * setSubstring(const char *s, int index1, int index2,char *out);

// replace max cnt occurences of search in string by replace 
// out must be large enough
char * <a class="code" href="gutils.h.html#a49">replace</a>(const char *string,
                           const char *search,const char *replace,
                           int cnt,
                           char *out);

char * toLowerCase(char *string);
char * toUpperCase(char *string); 

gbool <a class="code" href="gutils.h.html#a52">parseBool</a>(const gchar* s);


typedef struct {
        int i;  
        char *s; 
        } <a class="code" href="class_is.html">IS</a>;


const char * Lookup(const <a class="code" href="class_is.html">IS</a> *table,int v);

int Lookup(const <a class="code" href="class_is.html">IS</a> *table,const char *v);


// UTF8 helpers
//actually meaning full if not compiled with fully unicode support 

// bad encoding
#define UTF_INVALID     0x80000000

// EOF
#define UTF_EOF ((unsigned int)EOF)

unsigned int <a class="code" href="gutils.h.html#a55">utf8nextcinc</a>(const unsigned char * &amp;strptr);

int <a class="code" href="gutils.h.html#a56">utf8strlen</a>(const unsigned char * strptr); 

unsigned int <a class="code" href="gutils.h.html#a57">sgetu8</a>(const unsigned char *strptr, int *chars);

/*
function of utf-8 library converts a UTC-4 (31-bit Unicode) integer to a sequence 
of one or more characters representing its UTF-8 value, and writes the result to 
a buffer (character string). It appends a NUL at the end of the buffer, so it can be
processed as a standard C string.
*/

char * <a class="code" href="gutils.h.html#a58">sputu8</a>(unsigned int c, char *strptr);
 


 
 


#endif




</div></pre><hr><address><small>Generated at Thu Jan 27 18:46:19 2000 for blaxxunContact3D by
<a href="http://www.stack.nl/~dimitri/doxygen/index.html">
<img src="doxygen.gif" alt="doxygen" align=center border=0 
width=118 height=53></a> 1.0.0 written by <a href="mailto:dimitri@stack.nl">Dimitri van Heesch</a>,
 &copy; 1997-1999</small></address>
</body>
</html>

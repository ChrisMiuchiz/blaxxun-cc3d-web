<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta name="robots" content="noindex">
<title>GConvexVolume Include File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body bgcolor="#ffffff">
<!-- Generated by Doxygen 1.0.0 on Thu Jan 27 18:44:17 2000 -->
<center>
<a class="qindex"href="index.html">Main Page</a> &nbsp; <a class="qindex"href="namespaces.html">Namespace List</a> &nbsp; <a class="qindex"href="hierarchy.html">Class Hierarchy</a> &nbsp; <a class="qindex"href="annotated.html">Compound List</a> &nbsp; <a class="qindex"href="files.html">File List</a> &nbsp; <a class="qindex"href="headers.html">Header Files</a> &nbsp; <a class="qindex"href="namespacemembers.html">Namespace Members</a> &nbsp; <a class="qindex"href="functions.html">Compound Members</a> &nbsp; <a class="qindex"href="globals.html">File Members</a> &nbsp; </center>
<hr><h1>gvisibility.h</h1>This is the verbatim text of the gvisibility.h include file.<div class="fragment"><pre>/*=============================================================================

This code is licensed under the Web3D-blaxxun Community Source License,
provided in distribution file LICENSE.TXT and available online at
http://www.web3D.org/TaskGroups/x3d/blaxxun/Web3D-blaxxunCommunitySourceAgreement.html
and may only be used for non-commercial use as specified in that license.

THE WEB3D CONSORTIUM AND BLAXXUN DO NOT MAKE AND HEREBY DISCLAIM ANY EXPRESS
OR IMPLIED WARRANTIES RELATING TO THIS CODE, INCLUDING BUT NOT LIMITED TO,
WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY OR FITNESS FOR A PARTICULAR
PURPOSE, OR ANY WARRANTIES THAT MIGHT ARISE FROM A COURSE OF DEALING, USAGE
OR TRADE PRACTICE.  THE COMMUNITY SOURCE CODE IS PROVIDED UNDER THIS
AGREEMENT "AS IS," WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
INCLUDING, WITHOUT LIMITATION, WARRANTIES THAT THE COMMUNITY SOURCE CODE ARE
FREE OF DEFECTS, MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE OR
NON-INFRINGING OR IN ANY WAY CONSTITUTE THE COMPLETE PRODUCT MARKETED UNDER
THE NAMES GIVEN SAID CODE.

==============================================================================*/
#ifndef _gvisibility_h
#define _gvisibility_h

/******************************************************************************

gvisibility.h - tools for visibilty computation

Copyright (c) 1997 - 1998 by Holger Grahn
All rights reserved

Purpose:

Classes:

Notes:

Changes:

$Revision: 1.14 $
$Log: gvisibility.h,v $
Revision 1.14  1999/07/06 16:55:15  tom
*** empty log message ***

Revision 1.13  1999/03/10 10:22:19  tom
*** empty log message ***



Todo :

******************************************************************************/

#include &lt;float.h&gt;

#define BEPS 0.00001


enum GVisibility {
        INSIDE=1,               // object is inside
        ON=0,                   // exactly on  plane
        OUTSIDE=2,              // outside
        OVERLAP=3               // don"t know or on both sides
};



#define TRACE_BBOX(b) TRACE("BBox (%g %g) (%g %g) (%g %g) \n",b.mi.x,b.ma.x, b.mi.y,b.ma.y, b.mi.z,b.ma.z)
#define TRACE_PLANE(b) TRACE("PLANE (%g %g %g) %g) \n",b.n.x,b.n.y,b.n.z,b.d)

// is bbox b transformed by m outside a ?
gbool <a class="code" href="gvisibility.h.html#a4">BoxBoxOutside</a>(const <a class="code" href="class_bbox.html">BBox</a> &amp;<a class="code" href="class_a.html">a</a>, const <a class="code" href="class_matrix.html">Matrix</a> &amp;m,const <a class="code" href="class_bbox.html">BBox</a> &amp;b);

// INSIDE, OUTSIDE ON
int <a class="code" href="gvisibility.h.html#a5">BoxPlaneStatus</a>(const <a class="code" href="class_bbox.html">BBox</a> &amp;<a class="code" href="class_box.html">box</a>, const <a class="code" href="class_plane.html">Plane</a> &amp;plane); 

// return TRUE if box fully outside of box 
gbool <a class="code" href="gvisibility.h.html#a6">BoxPlaneOutside</a>(const <a class="code" href="class_bbox.html">BBox</a> &amp;<a class="code" href="class_box.html">box</a>, const <a class="code" href="class_plane.html">Plane</a> &amp;plane); 

// test a box against a set of plane 
// returns only OUTSIDE &amp; OVERLAP 
int <a class="code" href="gvisibility.h.html#a5">BoxPlaneStatus</a>(const <a class="code" href="class_bbox.html">BBox</a> &amp;<a class="code" href="class_box.html">box</a>,const <a class="code" href="class_array.html">Array</a>&lt;<a class="code" href="class_plane.html">Plane</a>&gt; &amp;planes);


// test a box against 5 planes of view frustrum 
// returns true if box outside off all planes 
// planes are defined by the view point position and 4 points on far plane
gbool <a class="code" href="gvisibility.h.html#a8">BoxViewVolumeOutside</a>(const <a class="code" href="class_bbox.html">BBox</a> &amp;<a class="code" href="class_box.html">box</a>,const <a class="code" href="class_point.html">Point</a> &amp;viewpoint,<a class="code" href="class_pointarray.html">PointArray</a> &amp;viewVolume);

// test a box against 5 planes of view frustrum 
// returns true if box outside off all planes 
// planes are defined by the view point position and 4 points on far plane
// return also if resulting object need clipping to view frustrum
gbool <a class="code" href="gvisibility.h.html#a8">BoxViewVolumeOutside</a>(const <a class="code" href="class_bbox.html">BBox</a> &amp;<a class="code" href="class_box.html">box</a>,const <a class="code" href="class_point.html">Point</a> &amp;viewpoint,<a class="code" href="class_pointarray.html">PointArray</a> &amp;viewVolume,BOOL &amp;needClip);



// test a list of points against plane 
// can return all 4 cases 
int <a class="code" href="gvisibility.h.html#a10">PlaneStatus</a>(const <a class="code" href="class_pointarray.html">PointArray</a> &amp;v, const <a class="code" href="class_plane.html">Plane</a> &amp;plane);

int <a class="code" href="gvisibility.h.html#a10">PlaneStatus</a>(int np, const <a class="code" href="class_point.html">Point</a> *p, const <a class="code" href="class_plane.html">Plane</a> &amp;plane);

// Compute a separation Planes 
gbool <a class="code" href="gvisibility.h.html#a12">ComputeSeparationPlane</a>(const <a class="code" href="class_bbox.html">BBox</a> &amp;<a class="code" href="class_a.html">a</a>,const <a class="code" href="class_bbox.html">BBox</a> &amp;b, <a class="code" href="class_plane.html">Plane</a> &amp;plane, int &amp;frontIndex,int &amp;backIndex);
/*

  compute a separation plane splitting a box
  along the dominant axis

*/

gbool <a class="code" href="gvisibility.h.html#a12">ComputeSeparationPlane</a>(const <a class="code" href="class_bbox.html">BBox</a> &amp;<a class="code" href="class_a.html">a</a>, <a class="code" href="class_plane.html">Plane</a> &amp;plane);

// each bit(i) says outside of plane (i)
typedef unsigned long GPlaneMask;
#define GMAX_PLANES (sizeof(GPlaneMask)*8)

class <a class="code" href="class_gcollisionresponse.html">GCollisionResponse</a> 
{
public :
        <a class="code" href="class_gcollisionresponse.html#a0">GCollisionResponse</a>() : 
            currentMinDistance(FLT_MAX), 
                currentMinPlaneIndex(-1),
                currentMinVertexIndex(-1),
                collision(gfalse)
        {}

        float currentMinDistance;                       // maximum penetrations distance (negative)
        int currentMinPlaneIndex;       // index of collission plane
        int currentMinVertexIndex;      // vertex index which is most inside

        int faceIndex;                          // index of face, penetrating
        <a class="code" href="class_plane.html">Plane</a> currentMinPlane ;
        <a class="code" href="class_point.html">Point</a> currentMinVertex;
        gbool collision;

};

//
// GConvexVolume
// 
/*
 Convex volume is a convex polyhedra
 defined by a set of points
 and a set of planes definining the volume

*/

class <a class="code" href="class_gconvexvolume.html">GConvexVolume</a> {
public :
                
                <a class="code" href="class_bbox.html">BBox</a> bbox;              // bounding box over vertices   
                <a class="code" href="class_pointarray.html">PointArray</a> v;   // vertices (convex hull)

                <a class="code" href="class_array.html">Array</a>&lt;<a class="code" href="class_plane.html">Plane</a>&gt; planes; // the planes of the hull
                
                <a class="code" href="class_gconvexvolume.html#a0">GConvexVolume</a>() {}

                <a class="code" href="class_gconvexvolume.html#a0">GConvexVolume</a>(const <a class="code" href="class_pointarray.html">PointArray</a> &amp;v_, const <a class="code" href="class_array.html">Array</a>&lt;<a class="code" href="class_plane.html">Plane</a>&gt; &amp;planes_) :
                                v(v_), planes(planes_)
                        {
                                <a class="code" href="class_gconvexvolume.html#a7">UpdateBBox</a>();
                        }
                <a class="code" href="class_gconvexvolume.html#a2">~GConvexVolume</a>() { }

                <a class="code" href="class_gconvexvolume.html#a0">GConvexVolume</a>(const <a class="code" href="class_matrix.html">Matrix</a> &amp;m,const <a class="code" href="class_matrix.html">Matrix</a> &amp;inverse,const <a class="code" href="class_pointarray.html">PointArray</a> &amp;v_, const <a class="code" href="class_array.html">Array</a>&lt;<a class="code" href="class_plane.html">Plane</a>&gt; &amp;planes_);

                // set to new 
                void <a class="code" href="class_gtraversal.html#a9">Set</a>(const <a class="code" href="class_matrix.html">Matrix</a> &amp;m,const <a class="code" href="class_matrix.html">Matrix</a> &amp;inverse,const <a class="code" href="class_pointarray.html">PointArray</a> &amp;v_, const <a class="code" href="class_array.html">Array</a>&lt;<a class="code" href="class_plane.html">Plane</a>&gt; &amp;planes_);

                // set to new 
                void <a class="code" href="class_gtraversal.html#a9">Set</a>(const <a class="code" href="class_bbox.html">BBox</a> &amp;<a class="code" href="class_box.html">box</a>) { bbox = <a class="code" href="class_box.html">box</a>; }

                // set to new 
                void <a class="code" href="class_gtraversal.html#a9">Set</a>(const <a class="code" href="class_bbox.html">BBox</a> &amp;<a class="code" href="class_box.html">box</a>, const <a class="code" href="class_matrix.html">Matrix</a> &amp;m) { bbox = <a class="code" href="class_box.html">box</a>;  bbox *= m; }

                // recompute bounding box from vertices
                void <a class="code" href="class_gconvexvolume.html#a7">UpdateBBox</a>()
                {
                        v.<a class="code" href="class_pointarray.html#a7">ComputeBBox</a>(bbox);
                }


                // outside bounding box test
                inline gbool <a class="code" href="class_gconvexvolume.html#a8">Outside</a>(const <a class="code" href="class_bbox.html">BBox</a> &amp;object) {
                        // outside if outside of my bounding box
                        if (bbox.<a class="code" href="class_bbox.html#a18">Outside</a>(object)) return gtrue;
                        // outside if object bbox outtside of all planes
                        return (<a class="code" href="gvisibility.h.html#a5">BoxPlaneStatus</a>(object,planes) == OUTSIDE);
                }

                // test if bbox of object transformed by m is outside
                gbool <a class="code" href="class_gconvexvolume.html#a8">Outside</a>(const <a class="code" href="class_matrix.html">Matrix</a> &amp;m,const <a class="code" href="class_bbox.html">BBox</a> &amp;object);


                // compute the status of all vertices with respect to planes
                // and update masks

                // if the ormask = 0, all points are inside
                // if the andmask !=0  all points are outside  

                int <a class="code" href="class_gconvexvolume.html#a10">ComputePlaneMasks</a>(const <a class="code" href="class_pointarray.html">PointArray</a> &amp;v,<a class="code" href="class_array.html">Array</a>&lt;GPlaneMask&gt; &amp;masks); 
                
                // a triangle is outside if the corresponding vertices
                // are outside of a common plane 

                inline gbool <a class="code" href="class_gconvexvolume.html#a8">Outside</a>(int v1,int v2, int v3,const <a class="code" href="class_array.html">Array</a>&lt;GPlaneMask&gt; &amp;masks) const {
                        GPlaneMask m =masks[v1] &amp; masks[v2] &amp; masks[v3];
                        return m !=0;
                }

                // same but for convex polygon 
                inline gbool <a class="code" href="class_gconvexvolume.html#a8">Outside</a>(int n, const int *fp, const <a class="code" href="class_array.html">Array</a>&lt;GPlaneMask&gt; &amp;masks) const {
                        ASSERT(n&gt;0);

                        GPlaneMask m = masks[*fp++];
                        n--;
                        while (n&gt;0) {
                                m &amp;= masks[*fp++];
                                n--;
                        }
                        return m !=0;
                }

                // a triangle is inside if the corresponding vertices
                // are not outside of any plane 

                inline gbool <a class="code" href="class_gconvexvolume.html#a13">Inside</a>(int v1, int v2, int v3,const <a class="code" href="class_array.html">Array</a>&lt;GPlaneMask&gt; &amp;masks) const {
                        return masks[v1] == 0 &amp;&amp; masks[v2] ==0 &amp;&amp; masks[v3]==0;
                }

                // a point is inside if the corresponding vertices
                // are not outside of any plane 

                inline gbool <a class="code" href="class_gconvexvolume.html#a13">Inside</a>(int v1,const <a class="code" href="class_array.html">Array</a>&lt;GPlaneMask&gt; &amp;masks) const 
                {
                        return masks[v1] == 0;
                }

                
                // once a polygon is intersecting
                // compute collision respone &amp; update response info

                gbool <a class="code" href="class_gconvexvolume.html#a15">ComputePenetration</a>(
                        int n, const int *fp,   // the polygon vertex indices
                        const <a class="code" href="class_pointarray.html">PointArray</a> &amp;v,    // the vertices
                        const <a class="code" href="class_array.html">Array</a>&lt;GPlaneMask&gt; &amp;masks, // precomputed masks
                        <a class="code" href="class_gcollisionresponse.html">GCollisionResponse</a> &amp;response    // the response info
                        ) const;


                // for Bsp Tree, test transformed plane against volume
                int <a class="code" href="class_gconvexvolume.html#a16">PlaneStatus</a>(const <a class="code" href="class_matrix.html">Matrix</a> &amp;m,const <a class="code" href="class_matrix.html">Matrix</a> &amp;minverse, const <a class="code" href="class_plane.html">Plane</a> &amp;plane);

};

#endif







</div></pre><hr><address><small>Generated at Thu Jan 27 18:44:18 2000 for blaxxunContact3D by
<a href="http://www.stack.nl/~dimitri/doxygen/index.html">
<img src="doxygen.gif" alt="doxygen" align=center border=0 
width=118 height=53></a> 1.0.0 written by <a href="mailto:dimitri@stack.nl">Dimitri van Heesch</a>,
 &copy; 1997-1999</small></address>
</body>
</html>

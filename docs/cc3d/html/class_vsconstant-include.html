<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta name="robots" content="noindex">
<title>VsConstant Include File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body bgcolor="#ffffff">
<!-- Generated by Doxygen 1.0.0 on Thu Jan 27 18:52:55 2000 -->
<center>
<a class="qindex"href="index.html">Main Page</a> &nbsp; <a class="qindex"href="namespaces.html">Namespace List</a> &nbsp; <a class="qindex"href="hierarchy.html">Class Hierarchy</a> &nbsp; <a class="qindex"href="annotated.html">Compound List</a> &nbsp; <a class="qindex"href="files.html">File List</a> &nbsp; <a class="qindex"href="headers.html">Header Files</a> &nbsp; <a class="qindex"href="namespacemembers.html">Namespace Members</a> &nbsp; <a class="qindex"href="functions.html">Compound Members</a> &nbsp; <a class="qindex"href="globals.html">File Members</a> &nbsp; </center>
<hr><h1>vsexpr.h</h1>This is the verbatim text of the vsexpr.h include file.<div class="fragment"><pre>/*
 * VsExpr.h
 *
 *      Declaration of classes:
 *        VsExpr
 *        VsConstant
 *        VsVar
 *        VsAssign
 *        VsArith
 *        VsUArithOp
 *        VsLogicOp
 *        VsULogicOp
 *        VsIncDec
 *        VsComma
 *        VsExprList
 *
 * Expression support
 * 
 * Copyright (C) 1996, Silicon Graphics,  Inc.
 */



/* hg

  14.12.99 changed

    virtual VsValue             evaluate(VsFunctionCall *) = 0;

to 

  virtual void          evaluate(VsValue &amp;ret, VsFunctionCall *) = 0;

  because temporary VsValue copy / destructor calls cause a serious amount of time


*/

#ifndef _VS_EXPR_
#define _VS_EXPR_

class <a class="code" href="class_vsexprlist.html">VsExprList</a>;

#include "vsstatement.h"


#include "vbplist.h"

#include &lt;gvstring.h&gt;

#define VsMember GvName

class <a class="code" href="class_vsfunctioncall.html">VsFunctionCall</a>;
class <a class="code" href="class_vsmethodcall.html">VsMethodCall</a>;
class <a class="code" href="class_vsmemberaccess.html">VsMemberAccess</a>;

//
// Expression base class:
//
class <a class="code" href="class_vsexpr.html">VsExpr</a> : public <a class="code" href="class_vsstatement.html">VsStatement</a> {
  public:
    // Constructor, just initializes reference count to zero
    <a class="code" href="class_vsexpr.html#a0">VsExpr</a>();

    // Expressions are also statements, and so must have an execute()
    // method.  The execute() method just calls evaluate() and returns
    // a NORMAL status
    virtual VsStatement::Status <a class="code" href="class_vsstatement.html#a2">execute</a>(<a class="code" href="class_vsfunctioncall.html">VsFunctionCall</a> *);

    virtual void <a class="code" href="class_vsexpr.html#a2">evaluate</a>(<a class="code" href="class_vsvalue.html">VsValue</a> &amp;ret, <a class="code" href="class_vsfunctioncall.html">VsFunctionCall</a> *) = 0;

        virtual <a class="code" href="class_vsvar.html">VsVar</a> *<a class="code" href="class_vsexpr.html#a3">evaluateVar</a>(<a class="code" href="class_vsfunctioncall.html">VsFunctionCall</a> *, <a class="code" href="class_vsvalue.html">VsValue</a> &amp;value);


    // Expressions must be reference counted because variables may be
    // multiply instanced in the parse tree
    void        <a class="code" href="class_vsexpr.html#a4">ref</a>();
    void        <a class="code" href="class_vsexpr.html#a5">unref</a>();

  protected:
    virtual <a class="code" href="class_vsexpr.html#b0">~VsExpr</a>();
  private:
    short refCount;
};

//
// Constant numbers and/or strings:
//
class <a class="code" href="class_vsconstant.html">VsConstant</a> : public <a class="code" href="class_vsexpr.html">VsExpr</a> {
  public:
    <a class="code" href="class_vsconstant.html#a0">VsConstant</a>(const char *string); // String is copied in
    <a class="code" href="class_vsconstant.html#a0">VsConstant</a>(double number);
    
        <a class="code" href="class_vsconstant.html#a0">VsConstant</a>(const <a class="code" href="class_vsvalue.html">VsValue</a> &amp;value);

    virtual void <a class="code" href="class_vsexpr.html#a2">evaluate</a>(<a class="code" href="class_vsvalue.html">VsValue</a> &amp;ret, <a class="code" href="class_vsfunctioncall.html">VsFunctionCall</a> *);

  protected:
    virtual <a class="code" href="class_vsconstant.html#b0">~VsConstant</a>();
  private:
    <a class="code" href="class_vsvalue.html">VsValue</a> myValue;
};

//
// Abstract base class:
//
class <a class="code" href="class_vsvar.html">VsVar</a> : public <a class="code" href="class_vsexpr.html">VsExpr</a> {
  public:
    // Assignment operator.
    virtual <a class="code" href="class_vsvalue.html">VsValue</a>             <a class="code" href="class_vsvar.html#a0">assign</a>(const <a class="code" href="class_vsvalue.html">VsValue</a> &amp;, <a class="code" href="class_vsfunctioncall.html">VsFunctionCall</a> *) = 0;
    
    // Assign to a component of an array.
    virtual <a class="code" href="class_vsvalue.html">VsValue</a>             <a class="code" href="class_vsvar.html#a0">assign</a>(const <a class="code" href="class_vsvalue.html">VsValue</a> &amp;, int32_t index, <a class="code" href="class_vsfunctioncall.html">VsFunctionCall</a> *);

        // array support
        virtual void <a class="code" href="class_vsexpr.html#a2">evaluate</a>(<a class="code" href="class_vsvalue.html">VsValue</a> &amp;ret,int32_t index, <a class="code" href="class_vsfunctioncall.html">VsFunctionCall</a> *);

        // may return temporary object !! ref() unref()
        virtual <a class="code" href="class_vsvar.html">VsVar</a>*          <a class="code" href="class_vsexpr.html#a3">evaluateVar</a>(int32_t index, <a class="code" href="class_vsfunctioncall.html">VsFunctionCall</a> * /*, VsValue &amp;value*/);



    // Note: derived classes will also need to define an execute()
    // function to return the var's value.

        // Object support 
        // assign to an member 
        virtual <a class="code" href="class_vsvalue.html">VsValue</a> <a class="code" href="class_vsvar.html#a4">assignMember</a>(const VsMember &amp;member, const <a class="code" href="class_vsvalue.html">VsValue</a> &amp;v, <a class="code" href="class_vsfunctioncall.html">VsFunctionCall</a> *);

        // evaluate an member 
        virtual <a class="code" href="class_vsvalue.html">VsValue</a> <a class="code" href="class_vsvar.html#a5">evaluateMember</a>(const VsMember &amp;member, <a class="code" href="class_vsfunctioncall.html">VsFunctionCall</a> *);

        // invoke member function 
        virtual <a class="code" href="class_vsvalue.html">VsValue</a> <a class="code" href="class_vsvar.html#a6">callMember</a>(const VsMember &amp;member,<a class="code" href="class_vsexprlist.html">VsExprList</a> *args, <a class="code" href="class_vsfunctioncall.html">VsFunctionCall</a> *);

    // returns the corresponding variable object, usually this 
        virtual <a class="code" href="class_vsvar.html">VsVar</a> *<a class="code" href="class_vsexpr.html#a3">evaluateVar</a>(<a class="code" href="class_vsfunctioncall.html">VsFunctionCall</a> *, <a class="code" href="class_vsvalue.html">VsValue</a> &amp;value);

        // get Var representing the objects member 
        // may return temporary object 
        virtual <a class="code" href="class_vsvar.html">VsVar</a>* <a class="code" href="class_vsvar.html#a8">evaluateMemberVar</a>(const VsMember &amp;member, <a class="code" href="class_vsfunctioncall.html">VsFunctionCall</a> *fcall);



};

//
// Assignment expression:
//
class <a class="code" href="class_vsassign.html">VsAssign</a>: public <a class="code" href="class_vsexpr.html">VsExpr</a> {
  public:

    // Pass variable = expression.  Destructor will delete expression,
    // the enclosing scope must delete the variable (since it may
    // appear more than once).
    <a class="code" href="class_vsassign.html#a0">VsAssign</a>(<a class="code" href="class_vsvar.html">VsVar</a> *, <a class="code" href="class_vsexpr.html">VsExpr</a> *);
    
    // Evaluate.  Assigns to variable, result is value of variable.
    virtual void <a class="code" href="class_vsexpr.html#a2">evaluate</a>(<a class="code" href="class_vsvalue.html">VsValue</a> &amp;ret, <a class="code" href="class_vsfunctioncall.html">VsFunctionCall</a> *);

  protected:
    virtual <a class="code" href="class_vsassign.html#b0">~VsAssign</a>();
  private:
    <a class="code" href="class_vsvar.html">VsVar</a> *var;
    <a class="code" href="class_vsexpr.html">VsExpr</a> *expr;
};

//
// Handles arrays on the right hand side of an expression:
//
class <a class="code" href="class_vsarrayvar.html">VsArrayVar</a> : public <a class="code" href="class_vsvar.html">VsVar</a> {
  public:

    <a class="code" href="class_vsarrayvar.html#a0">VsArrayVar</a>(<a class="code" href="class_vsexpr.html">VsExpr</a> *array, <a class="code" href="class_vsexpr.html">VsExpr</a> *subscript);

    virtual void        <a class="code" href="class_vsexpr.html#a2">evaluate</a>(<a class="code" href="class_vsvalue.html">VsValue</a> &amp;ret, <a class="code" href="class_vsfunctioncall.html">VsFunctionCall</a> *);
    
    virtual <a class="code" href="class_vsvalue.html">VsValue</a>             <a class="code" href="class_vsvar.html#a0">assign</a>(const <a class="code" href="class_vsvalue.html">VsValue</a> &amp;, <a class="code" href="class_vsfunctioncall.html">VsFunctionCall</a> *);

        <a class="code" href="class_vsvar.html">VsVar</a> *<a class="code" href="class_vsexpr.html#a3">evaluateVar</a>(<a class="code" href="class_vsfunctioncall.html">VsFunctionCall</a> *fcall, <a class="code" href="class_vsvalue.html">VsValue</a> &amp;value);



  protected:
    virtual <a class="code" href="class_vsarrayvar.html#b0">~VsArrayVar</a>();
    
  private:
    <a class="code" href="class_vsexpr.html">VsExpr</a>  *array;         
    <a class="code" href="class_vsexpr.html">VsExpr</a>  *subscript;
};

//
// Binary arithmetic operators.  One class is used for all of them to
// cut down on code bloat.
//
class <a class="code" href="class_vsarith.html">VsArith</a>: public <a class="code" href="class_vsexpr.html">VsExpr</a> {
  public:
    <a class="code" href="class_vsarith.html#a0">VsArith</a>(<a class="code" href="class_vsexpr.html">VsExpr</a> *e1, <a class="code" href="class_vsexpr.html">VsExpr</a> *e2, int op);

    virtual void <a class="code" href="class_vsexpr.html#a2">evaluate</a>(<a class="code" href="class_vsvalue.html">VsValue</a> &amp;ret, <a class="code" href="class_vsfunctioncall.html">VsFunctionCall</a> *);

  protected:
    virtual <a class="code" href="class_vsarith.html#b0">~VsArith</a>();
  private:
    <a class="code" href="class_vsexpr.html">VsExpr</a> *expr1, *expr2;
    int operation;
};

//
// Increment/decrement operators.  Separate class to allow
// for correct prefix/postfix behavior
//
class <a class="code" href="class_vsincdec.html">VsIncDec</a>: public <a class="code" href="class_vsexpr.html">VsExpr</a> {
  public:
    <a class="code" href="class_vsincdec.html#a0">VsIncDec</a>(<a class="code" href="class_vsexpr.html">VsExpr</a> *var, int inc, int pref);

    virtual void <a class="code" href="class_vsexpr.html#a2">evaluate</a>(<a class="code" href="class_vsvalue.html">VsValue</a> &amp;ret, <a class="code" href="class_vsfunctioncall.html">VsFunctionCall</a> *);

  protected:
    virtual <a class="code" href="class_vsincdec.html#b0">~VsIncDec</a>();
  private:
    <a class="code" href="class_vsexpr.html">VsExpr</a> *var;
    int   increment;
    int   prefix;
};

//
// Comma operator.  Separate class to allow for expression of
// mixed type
//
class <a class="code" href="class_vscomma.html">VsComma</a>: public <a class="code" href="class_vsexpr.html">VsExpr</a> {
  public:
    <a class="code" href="class_vscomma.html#a0">VsComma</a>(<a class="code" href="class_vsexpr.html">VsExpr</a> *e1, <a class="code" href="class_vsexpr.html">VsExpr</a> *e2);

    virtual void <a class="code" href="class_vsexpr.html#a2">evaluate</a>(<a class="code" href="class_vsvalue.html">VsValue</a> &amp;ret, <a class="code" href="class_vsfunctioncall.html">VsFunctionCall</a> *);

  protected:
    virtual <a class="code" href="class_vscomma.html#b0">~VsComma</a>();
  private:
    <a class="code" href="class_vsexpr.html">VsExpr</a> *expr1, *expr2;
};

//
// Conditional expression operator.
//
class <a class="code" href="class_vscondexpr.html">VsCondExpr</a>: public <a class="code" href="class_vsexpr.html">VsExpr</a> {
  public:
    <a class="code" href="class_vscondexpr.html#a0">VsCondExpr</a>(<a class="code" href="class_vsexpr.html">VsExpr</a> *test, <a class="code" href="class_vsexpr.html">VsExpr</a> *e1, <a class="code" href="class_vsexpr.html">VsExpr</a> *e2);

    virtual void <a class="code" href="class_vsexpr.html#a2">evaluate</a>(<a class="code" href="class_vsvalue.html">VsValue</a> &amp;ret, <a class="code" href="class_vsfunctioncall.html">VsFunctionCall</a> *);

  protected:
    virtual <a class="code" href="class_vscondexpr.html#b0">~VsCondExpr</a>();
  private:
    <a class="code" href="class_vsexpr.html">VsExpr</a> *test,  *expr1, *expr2;
};

//
// Unary minus operator
//
class <a class="code" href="class_vsuarithop.html">VsUArithOp</a>: public <a class="code" href="class_vsexpr.html">VsExpr</a> {
  public:
    <a class="code" href="class_vsuarithop.html#a0">VsUArithOp</a>(<a class="code" href="class_vsexpr.html">VsExpr</a> *e, int op);

    virtual void <a class="code" href="class_vsexpr.html#a2">evaluate</a>(<a class="code" href="class_vsvalue.html">VsValue</a> &amp;ret, <a class="code" href="class_vsfunctioncall.html">VsFunctionCall</a> *);

  protected:
    virtual <a class="code" href="class_vsuarithop.html#b0">~VsUArithOp</a>();
  private:
    <a class="code" href="class_vsexpr.html">VsExpr</a> *expr;
    
    int operation;
};

//
// Binary logic operators.  One class is used for all of them to
// cut down on code bloat.
//
class <a class="code" href="class_vslogicop.html">VsLogicOp</a>: public <a class="code" href="class_vsexpr.html">VsExpr</a> {
  public:
    <a class="code" href="class_vslogicop.html#a0">VsLogicOp</a>(<a class="code" href="class_vsexpr.html">VsExpr</a> *e1, <a class="code" href="class_vsexpr.html">VsExpr</a> *e2, int op);

    virtual void <a class="code" href="class_vsexpr.html#a2">evaluate</a>(<a class="code" href="class_vsvalue.html">VsValue</a> &amp;ret, <a class="code" href="class_vsfunctioncall.html">VsFunctionCall</a> *);

  protected:
    virtual <a class="code" href="class_vslogicop.html#b0">~VsLogicOp</a>();
  private:
    <a class="code" href="class_vsexpr.html">VsExpr</a> *expr1, *expr2;
    int operation;
};

//
// Unary logic operators.  One class is used for all of them to
// cut down on code bloat.
//
class <a class="code" href="class_vsulogicop.html">VsULogicOp</a>: public <a class="code" href="class_vsexpr.html">VsExpr</a> {
  public:
    <a class="code" href="class_vsulogicop.html#a0">VsULogicOp</a>(<a class="code" href="class_vsexpr.html">VsExpr</a> *e, int op);

    virtual void <a class="code" href="class_vsexpr.html#a2">evaluate</a>(<a class="code" href="class_vsvalue.html">VsValue</a> &amp;ret, <a class="code" href="class_vsfunctioncall.html">VsFunctionCall</a> *);

  protected:
    virtual <a class="code" href="class_vsulogicop.html#b0">~VsULogicOp</a>();
  private:
    <a class="code" href="class_vsexpr.html">VsExpr</a> *expr;
    int operation;
};

//
// Little wrapper class for VbPList that bundles up some annoying casting:
//
class <a class="code" href="class_vsexprlist.html">VsExprList</a> : public <a class="code" href="class_vbplist.html">VbPList</a> {
  public:
    <a class="code" href="class_vsexprlist.html#a0">VsExprList</a>()                                 {}
    <a class="code" href="class_vsexprlist.html#a0">VsExprList</a>(int initSize) : <a class="code" href="class_vbplist.html">VbPList</a>(initSize) {}

    void    <a class="code" href="class_vbplist.html#a4">append</a>(<a class="code" href="class_vsexpr.html">VsExpr</a> *expr)
                { this-&gt;VbPList::append((void *)expr); }
    int     <a class="code" href="class_vbplist.html#a5">find</a>(<a class="code" href="class_vsexpr.html">VsExpr</a> *expr)
                { return this-&gt;VbPList::find((void *)expr); }
    void    <a class="code" href="class_vbplist.html#a6">insert</a>(<a class="code" href="class_vsexpr.html">VsExpr</a> *expr, int addBefore)
                { this-&gt;VbPList::insert((void *)expr, addBefore); }
    <a class="code" href="class_vsexpr.html">VsExpr</a>* &amp;operator [](int i) const
                { return (<a class="code" href="class_vsexpr.html">VsExpr</a> * &amp;)(this-&gt;VbPList::operator[](i)); }
};

#endif /* _VS_EXPR_ */
</div></pre><hr><address><small>Generated at Thu Jan 27 18:52:55 2000 for blaxxunContact3D by
<a href="http://www.stack.nl/~dimitri/doxygen/index.html">
<img src="doxygen.gif" alt="doxygen" align=center border=0 
width=118 height=53></a> 1.0.0 written by <a href="mailto:dimitri@stack.nl">Dimitri van Heesch</a>,
 &copy; 1997-1999</small></address>
</body>
</html>

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta name="robots" content="noindex">
<title>GView Include File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body bgcolor="#ffffff">
<!-- Generated by Doxygen 1.0.0 on Thu Jan 27 18:47:14 2000 -->
<center>
<a class="qindex"href="index.html">Main Page</a> &nbsp; <a class="qindex"href="namespaces.html">Namespace List</a> &nbsp; <a class="qindex"href="hierarchy.html">Class Hierarchy</a> &nbsp; <a class="qindex"href="annotated.html">Compound List</a> &nbsp; <a class="qindex"href="files.html">File List</a> &nbsp; <a class="qindex"href="headers.html">Header Files</a> &nbsp; <a class="qindex"href="namespacemembers.html">Namespace Members</a> &nbsp; <a class="qindex"href="functions.html">Compound Members</a> &nbsp; <a class="qindex"href="globals.html">File Members</a> &nbsp; </center>
<hr><h1>gmodel.h</h1>This is the verbatim text of the gmodel.h include file.<div class="fragment"><pre>/*=============================================================================

This code is licensed under the Web3D-blaxxun Community Source License,
provided in distribution file LICENSE.TXT and available online at
http://www.web3D.org/TaskGroups/x3d/blaxxun/Web3D-blaxxunCommunitySourceAgreement.html
and may only be used for non-commercial use as specified in that license.

THE WEB3D CONSORTIUM AND BLAXXUN DO NOT MAKE AND HEREBY DISCLAIM ANY EXPRESS
OR IMPLIED WARRANTIES RELATING TO THIS CODE, INCLUDING BUT NOT LIMITED TO,
WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY OR FITNESS FOR A PARTICULAR
PURPOSE, OR ANY WARRANTIES THAT MIGHT ARISE FROM A COURSE OF DEALING, USAGE
OR TRADE PRACTICE.  THE COMMUNITY SOURCE CODE IS PROVIDED UNDER THIS
AGREEMENT "AS IS," WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
INCLUDING, WITHOUT LIMITATION, WARRANTIES THAT THE COMMUNITY SOURCE CODE ARE
FREE OF DEFECTS, MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE OR
NON-INFRINGING OR IN ANY WAY CONSTITUTE THE COMPLETE PRODUCT MARKETED UNDER
THE NAMES GIVEN SAID CODE.

==============================================================================*/
#ifndef _GMODEL_H
#define _GMODEL_H
/******************************************************************************
@doc

@module gmodel.h - GLView data model (document) class|

Copyright (c) 1995 - 1998 by Holger Grahn
All rights reserved

Purpose:

Classes:
&lt;c GModel&gt;
&lt;c GView&gt;

Notes:

Changes:

$Revision: 1.33 $
$Log: gmodel.h,v $
Revision 1.33  1998/09/28 15:44:33  tom
*** empty log message ***

Revision 1.32  1998/09/22 16:37:33  holger
empty message


Todo :

******************************************************************************/

class <a class="code" href="class_renderstate.html">RenderState</a>;
class <a class="code" href="class_rgbacolor.html">RGBAColor</a>;

#ifdef _OGL
#ifdef _GLMESA
        class <a class="code" href="class_gxmesadevice.html">GXMesaDevice</a>;
#endif

#ifdef _WIN32
        class GOpenglDeviceWGL;
#endif
#endif



class <a class="code" href="class_gshell.html">GShell</a>;
class <a class="code" href="class_gworld.html">GWorld</a>;
class <a class="code" href="class_gtraversal.html">GTraversal</a>;
class <a class="code" href="class_gcamera.html">GCamera</a>;


class <a class="code" href="class_gdeform.html">GDeform</a>;
class <a class="code" href="class_gparameter.html">GParameter</a>;

class <a class="code" href="class_gvnode.html">GvNode</a>;
class <a class="code" href="class_gvscene.html">GvScene</a>;

class <a class="code" href="class_gvscript.html">GvScript</a>;

class <a class="code" href="class_gvviewpoint.html">GvViewpoint</a>;
class <a class="code" href="class_gvtimesensor.html">GvTimeSensor</a>;
class <a class="code" href="class_gvmovietexture.html">GvMovieTexture</a>;
class <a class="code" href="class_gvaudioclip.html">GvAudioClip</a>;
class <a class="code" href="class_gvsound.html">GvSound</a>;

class <a class="code" href="class_gvmenusensor.html">GvMenuSensor</a>;
class <a class="code" href="class_gvlight.html">GvLight</a>;
class <a class="code" href="class_gvfog.html">GvFog</a>;
class <a class="code" href="class_gvbackground.html">GvBackground</a>;
class <a class="code" href="class_gvrotation.html">GvRotation</a>;
class <a class="code" href="class_gvnavigationinfo.html">GvNavigationInfo</a>;
class <a class="code" href="class_gv2inline.html">Gv2Inline</a>;

class <a class="code" href="class_ghitinfo.html">GHitInfo</a>;
class <a class="code" href="class_gvevent.html">GvEvent</a>;

class <a class="code" href="class_gconvexvolume.html">GConvexVolume</a>;
class <a class="code" href="class_rapidcollide.html">rapidCollide</a>;

class <a class="code" href="class_geventhandler.html">GEventHandler</a>;


class <a class="code" href="class_gcamerainterpolator.html">GCameraInterpolator</a>;

class <a class="code" href="class_gsounddevice.html">GSoundDevice</a>;

#include "www.h"


#ifdef _GV

#include &lt;gvsubnode.h&gt;

#include &lt;gvnode.h&gt;

#include &lt;gvsfnode.h&gt;
#include &lt;gvmfnode.h&gt;
#include &lt;gvsfbool.h&gt;

#include &lt;gvsffloat.h&gt;
#include &lt;gvsfint32.h&gt;
#include &lt;gvsftime.h&gt;
#include &lt;gvsfstring.h&gt;
#include &lt;gvsfrotation.h&gt;
#include &lt;gvsfvec2f.h&gt;
#include &lt;gvsfvec3f.h&gt;
#include &lt;gvmfstring.h&gt;
#include &lt;gvmfrotation.h&gt;
#include &lt;gvmfvec3f.h&gt;
#include &lt;gvmffloat.h&gt;

#include &lt;gvpath.h&gt;


#endif

#include "quaternation.h"

#include "gcamera.h"
#include "gcamerautil.h"
#include "gfuzzy.h"

class <a class="code" href="class_gmultitsensorhandler.html">GMultitSensorHandler</a>;

#ifdef WIN32
// for _OGL Amovie support
#ifndef __DDRAW_INCLUDED__
struct IDirectDraw;
typedef struct IDirectDraw                      <a class="code" href="class_inflate_huft_s.html">FAR</a> *LPDIRECTDRAW;
#endif
#endif


// create a colored wheel

<a class="code" href="class_gshell.html">GShell</a> *<a class="code" href="gmodel.h.html#a3">NewWheel</a>(float r=1.0,int parts = 6,float h=0.2,float r2factor=0.7);


//@class a 3d model
class <a class="code" href="class_gmodel.html">GModel</a>  {
public :
};


class <a class="code" href="class_gfile.html">GFile</a>;
class <a class="code" href="class_gpanel.html">GPanel</a>;


class <a class="code" href="class_gvsceneinfo.html">GvSceneInfo</a>;
class <a class="code" href="class_gvnode.html">GvNode</a>;
class GvInfo;
class <a class="code" href="class_gvexternproto.html">GvExternProto</a>;


// set of flags, for choosing the "right" output device 
class <a class="code" href="class_gdriverhints.html">GDriverHints</a> 
{
public  :


        CString m_driver;                       // preferenced Driver, default "Ramp Driver"
        CString m_fullScreenMode;       // preferenced full screen mode 

        BOOL  m_useHW;                          // use a HARDWARE driver if present
        BOOL  m_useFullscreen;          // switch to fullscreen !

        // D3D specific crap 
        BOOL  m_useRgb;                         // use a RGB capable driver if present

        BOOL  m_onlySystemMemory;       // use only system memory for all surfaces
        BOOL  m_onlyEmulation;          // use no hardware 

        <a class="code" href="class_gdriverhints.html#a0">GDriverHints</a>() 
        {

                        m_useHW = FALSE; // TRUE;
                        m_useFullscreen = FALSE;

                    m_useRgb = FALSE;   

                        m_onlySystemMemory = FALSE;
                        m_onlyEmulation = FALSE;
        }

};




class <a class="code" href="class_gloadtask.html">GLoadTask</a> { // not used 
public:
        int status;

        <a class="code" href="class_gfile.html">GFile</a> file;

        <a class="code" href="class_gvnode.html">GvNode</a> *node;

        <a class="code" href="class_gloadtask.html">GLoadTask</a> * next;

        <a class="code" href="class_gloadtask.html#a0">GLoadTask</a>() { next = NULL;}
};


class <a class="code" href="class_cmyglview.html">CMyglView</a>;
struct <a class="code" href="class__tk_rgbimagerec.html">_TK_RGBImageRec</a>;

class <a class="code" href="class_gviewcontroller.html">GViewController</a>;

// callback flags if running in "observered" enviroments 

typedef enum {
                // callback via observer interface // must match flags in blaxxunCC3D.odl
                GOBSERVE_MESSAGE = 0x01,                // observer want's all status messages
                GOBSERVE_ANCHOR  = 0x02,                // execution of anchors
                GOBSERVE_VIEWPOINT = 0x04,              // viewpoint message
                GOBSERVE_URLLOADING = 0x08,             // observers loads URL's to file for us
                GOBSERVE_URLERRORS = 0x10,              // observer wants URL errors

                // send message via sendMessage to observer window
                GOBSERVE_WM_MESSAGE = 64,               // same but using window messages
                GOBSERVE_WM_ANCHOR  = 128,
                GOBSERVE_WM_URLLOADING = 256,

} GBrowserObserverFlags;

#define GOBSERVER_WM_MASK                0x0000FFC0
#define GOBSERVER_OBSERVE_MASK   0x0000003F


typedef enum {

                SELECT_SENSOR_BIT = 2,

                SELECT_ANCHOR_BIT = 4,

                SELECT_COLLISION_BIT = 8,

                SELECT_DRAG_SENSOR_BIT = 16

} GBrowserSelectionFlags;



typedef enum {

        GEV_mousedown   = 1,
        GEV_mousemove   = 1&lt;&lt;1, 
        GEV_mouseout    = 1&lt;&lt;2,  
        GEV_mouseover   = 1&lt;&lt;3, 
        GEV_mouseup             = 1&lt;&lt;4, 
        
        GEV_keydown             = 1&lt;&lt;5, 
        GEV_keyup               = 1&lt;&lt;6, 
        GEV_keypress    = 1&lt;&lt;7, 
        GEV_click               = 1&lt;&lt;8, 
        GEV_dblclick    = 1&lt;&lt;9, 

        GEV_joystick    = 1&lt;&lt;10, 

        GEV_ALL                 = 0x0FFFF,
        GEV_MOUSE               = GEV_mousedown | GEV_mousemove | GEV_mouseout | GEV_mouseover | GEV_mouseup,
        GEV_KEY                 = GEV_keydown | GEV_keyup | GEV_keypress,
        GEV_CLICK               = GEV_click | GEV_dblclick ,
        GEV_NONE                = 0

} GBrowserInputEventFlags;





class <a class="code" href="class_gview.html">GView</a> : public <a class="code" href="class_gvnode.html">GvNode</a> 

#ifdef _COM
        // implements the Browser methods 
        ,public CComDualImpl&lt;Browser, &amp;IID_Browser, &amp;LIBID_GLViewVrmlLib&gt;
#endif

{

#ifdef _GV

    GV_NODE_HEADER(<a class="code" href="class_gview.html">GView</a>);

#endif


public:

#ifdef _COM
        BEGIN_COM_MAP(<a class="code" href="class_gview.html">GView</a>)
                COM_INTERFACE_ENTRY(<a class="code" href="class_browser.html">Browser</a>)
                COM_INTERFACE_ENTRY_CHAIN(<a class="code" href="class_gvnode.html">GvNode</a>)
        END_COM_MAP()

        DECLARE_NOT_AGGREGATABLE(<a class="code" href="class_gview.html">GView</a>)

                // Browser Interface methods

                // IUnknown 
                STDMETHOD_(ULONG, AddRef)() {return InternalAddRef();}
                STDMETHOD_(ULONG, Release)()
                { 
                        ULONG l = InternalRelease(); 
                        if (l == 0) delete this; 
                        return l;
                }

                STDMETHOD(QueryInterface)(REFIID iid, void ** ppvObject)
                {return _InternalQueryInterface(iid, ppvObject);}

                //
        STDMETHOD(getName) (BSTR *value);
        STDMETHOD(getVersion) (BSTR *value);
        STDMETHOD(getCurrentSpeed) (float *value);
        STDMETHOD(getCurrentFrameRate) (float *value);
        
        STDMETHOD(getWorldURL)(BSTR *value);
        
        STDMETHOD(replaceWorld)(<a class="code" href="class_node.html">Node</a> *value);
        
        STDMETHOD(loadURL)(int cntUrl,
            /* [size_is][in] */ BSTR *url,
            int cntParameter,
            /* [size_is][in] */ BSTR *<a class="code" href="class_parameter.html">parameter</a>);
        
        STDMETHOD(setDescription)(BSTR description);
        
        STDMETHOD(createVrmlFromString)(BSTR vrmlSyntax,<a class="code" href="class_node.html">Node</a> **value);
        
        STDMETHOD(createVrmlFromURL)(BSTR url, <a class="code" href="class_node.html">Node</a> *node, BSTR event);
        
        STDMETHOD(getNode)(BSTR name,<a class="code" href="class_node.html">Node</a> **value);
        
        STDMETHOD(addRoute)(<a class="code" href="class_node.html">Node</a> *fromNode, BSTR fromEventOut, <a class="code" href="class_node.html">Node</a> *toNode, BSTR toEventIn);
        
        STDMETHOD(deleteRoute)(<a class="code" href="class_node.html">Node</a> *fromNode,BSTR fromEventOut,<a class="code" href="class_node.html">Node</a> *toNode,BSTR toEventIn);
        
        STDMETHOD(createNode)(BSTR nodeclass,<a class="code" href="class_node.html">Node</a> **value);
        
        STDMETHOD(getWorld)(<a class="code" href="class_node.html">Node</a> **value);
        
        STDMETHOD(beginUpdate)(void);
        
        STDMETHOD(endUpdate)(void);
        
        STDMETHOD(addNode)(<a class="code" href="class_node.html">Node</a> *node);
        
        STDMETHOD(removeNode)(<a class="code" href="class_node.html">Node</a> *node,VARIANT_BOOL *value);

        
        STDMETHOD(setNodeName)(<a class="code" href="class_node.html">Node</a> *node, BSTR name);
        
        STDMETHOD(getNodeName)(<a class="code" href="class_node.html">Node</a> *node, BSTR *name);
        
        STDMETHOD(getEventOut)(BSTR eventOutName, <a class="code" href="class_eventout.html">EventOut</a> **value);
        
        STDMETHOD(getEventIn)(BSTR eventInName, <a class="code" href="class_eventin.html">EventIn</a> **value);
        
        STDMETHOD(getControlPathname)(BSTR *directoryName);
        
        STDMETHOD(saveWorld)(BSTR fileName, VARIANT_BOOL *value);
        
        STDMETHOD(saveViewpoint)( BSTR viewpointName);
        
        STDMETHOD(setObserver)(<a class="code" href="class_iunknown.html">IUnknown</a> *observer,int flags,VARIANT_BOOL *value);
        
        STDMETHOD(setViewpointByValue)(float *position, float *orientation,float fov, VARIANT_BOOL animate);
        
        STDMETHOD(setFullscreen)(VARIANT_BOOL mode,VARIANT_BOOL *value);
        
        STDMETHOD(setCollisionDetection)(VARIANT_BOOL mode);
        
        STDMETHOD(setRenderMode)(BSTR mode);
        
        STDMETHOD(setNavigationMode)(BSTR mode);
        
        STDMETHOD(setViewpoint)(BSTR viewpointName);
        
        STDMETHOD(setHeadlight)(VARIANT_BOOL mode);
        
        STDMETHOD(setAvatarHeight)(float value);
        
        STDMETHOD(setCollisionDistance)(float value);
        
        STDMETHOD(setVisibilityLimit)(float value);
        
        STDMETHOD(setWalkSpeed)(float value);

        STDMETHOD(setNavigationPanel)(VARIANT_BOOL mode);
        
        STDMETHOD(getNavigationPanel)(VARIANT_BOOL *value);



                CComPtr&lt;<a class="code" href="class_browserobserver.html">BrowserObserver</a>&gt; observer;
                HWND    observerWnd;
                int             observerFlags;

#endif


  public:


        CCriticalSection locker;        

        int locked;
#ifdef _DEBUG
        BOOL <a class="code" href="class_gview.html#a0">Lock</a>();
        BOOL <a class="code" href="class_gview.html#a1">Unlock</a>();
#else 
        BOOL <a class="code" href="class_gview.html#a0">Lock</a>() {locked++;  return locker.Lock(); }
        BOOL <a class="code" href="class_gview.html#a1">Unlock</a>() {locked-- ; return locker.Unlock(); }
#endif

        gbool <a class="code" href="class_gview.html#a2">Locked</a>() { return locked &gt;0; }


        <a class="code" href="class_gmodel.html">GModel</a> *model;          
        
        <a class="code" href="class_gfile.html">GFile</a> *file;            


        HWND hWnd;                      

#ifdef _MFC
        <a class="code" href="class_cmyglview.html">CMyglView</a> *pView;       
        void SetView(<a class="code" href="class_cmyglview.html">CMyglView</a> *view) { pView = view; }

#endif

        <a class="code" href="class_gviewcontroller.html">GViewController</a> *viewController;

        void <a class="code" href="class_gview.html#a3">SetViewController</a>(<a class="code" href="class_gviewcontroller.html">GViewController</a> *ViewController)
        {       viewController = ViewController; }

        <a class="code" href="class_greporter.html">GReporter</a>* <a class="code" href="class_gview.html#a4">GetReporter</a>();

#ifdef _MFC     
        CFrameWnd* fullScreenWnd;
#endif



        // Panel 
        <a class="code" href="class_gpanel.html">GPanel</a>  *panel;         

        <a class="code" href="class_gpanel.html">GPanel</a>* <a class="code" href="class_gview.html#a5">getPanel</a>() const { return panel;}

        gbool <a class="code" href="class_gview.html#a6">PanelOk</a>() const;
        
        // set by the embed in IE
        //if false panel is always off
        BOOL m_navPanelOn_Prop;
        
        //set by registry
        //panel on startup?
        //if false panel is always off
        BOOL m_navPanelOn_Reg;
        
        //the current status
        //m_navPanelOn = m_navPanelOn_Reg &amp; m_navPanelOn_Prop;
        BOOL m_navPanelOn;

        //is valid for one scene, is used for the NONE mode in navigationInfo
        BOOL m_navPanelOn_NavInf;

        //void GetWindowPos(CPoint point);

        void <a class="code" href="class_gview.html#a7">NavigationPanelDestroy</a>();
        void <a class="code" href="class_gview.html#a8">NavigationPanelCreate</a>(int flush);

        void <a class="code" href="class_gview.html#a9">setNavigationPanel</a>(gbool mode);
    gbool <a class="code" href="class_gview.html#a10">getNavigationPanel</a>();
        void <a class="code" href="class_gview.html#a11">setNavigationPanelProp</a>(gbool mode);
        void <a class="code" href="class_gview.html#a12">setNavigationPanelNavInf</a>(gbool mode);


        <a class="code" href="class_gfuzzylogic.html">GFuzzyLogic</a> FuzzyLogic;

#ifdef _DEBUG
//hg #define _FC_LOG
#ifdef _FC_LOG
        ofstream frameRate, budget;
#endif _FC_LOG
#endif _DEBUG

#if 0
        // idea 

        // caching mode , DONT_CACHE, CACHE_ALL, CACHE_MEDIA
        int defaultUrlCachingMode;
        int urlCachingMode;

        void SetUrlCachingMode(int newMode);
        int  GetUrlCachingMode();

        // load url to cache 
        gbool LoadUrlToCache(const char *url);

        // is the url in cache ?
        gbool IsUrlInCache(const char *url);
        
        // set the last modified date of an url
        void SetUrlModifiedDate(const char *url,time_t date);
        
        void MakeUrlAbsolute(<a class="code" href="class_gvstring.html">GvString</a> &amp;url);
#endif



    
    void <a class="code" href="class_gview.html#a13">Message</a>(const char *message,int messageType = 0);

        int <a class="code" href="class_gview.html#a14">GetLastMessageType</a>();

        void <a class="code" href="class_gview.html#a15">Print</a>(const char *message);


        // Redraw control 
        
        int             <a class="code" href="class_gview.html#a16">Redraw</a>();               


        GvBool mustRedraw;

        inline void <a class="code" href="class_gvnode.html#a28">setRedraw</a>() { mustRedraw = TRUE; } 
        
        void <a class="code" href="class_gview.html#a18">clearRedraw</a>() { mustRedraw = FALSE; } 
        
        inline GvBool <a class="code" href="class_gvnode.html#a29">getRedraw</a>() const { return mustRedraw; } 



        gbool firstUpdate;      


        // currently dummy, idea check for events during rendering 
        int             <a class="code" href="class_gview.html#a20">CheckEvents</a>();


        gbool   useGlCache;             
        gbool   LightMode;              
        gbool   NormalMode;             
        gbool   TextureMode;    
        int             TextureFilteringMode; 
        float   NormalScale;    
        gbool   TransparencyMode;       

        gbool   bspMode;                
        int             traversalOrder; 
        int             traversalInlineLoadingOrder;    
        gbool   viewCulling;  

        
        gbool headLightOn;              

        gbool useSceneLights;   
        float lightScale;               
        
        gbool useSceneSpotLights; 
        gbool useInitialSceneCamera; 

        gbool enableCollisionDetection; 
        gbool enableStayOnGround; 

        int <a class="code" href="class_gview.html#a21">SetLightScale</a>(float factor);
        float <a class="code" href="class_gview.html#a22">GetLightScale</a>();

        void <a class="code" href="class_gview.html#a23">SetHeadLight</a>(gbool flag) { if (flag != headLightOn) { headLightOn = flag; <a class="code" href="class_gview.html#a16">Redraw</a>(); }}
        gbool <a class="code" href="class_gview.html#a24">GetHeadLight</a>() { return (headLightOn); }

#ifndef _COM    
        void <a class="code" href="class_gview.html#a25">setHeadlight</a>(gbool flag);
        
    void <a class="code" href="class_gview.html#a26">setAvatarHeight</a>(float value);
        
    void <a class="code" href="class_gview.html#a27">setCollisionDistance</a>(float value);
        
    void <a class="code" href="class_gview.html#a28">setVisibilityLimit</a>(float value);
        
    void <a class="code" href="class_gview.html#a29">setWalkSpeed</a>(float value);

#endif
        


        gbool   <a class="code" href="class_gview.html#a30">GetBspMode</a>() { return (bspMode); }
        
        void    <a class="code" href="class_gview.html#a31">SetBspMode</a>(gbool mode);

        void    <a class="code" href="class_gview.html#a32">SetNavigationMode</a>(const char* mode);

        void    <a class="code" href="class_gview.html#a33">GetNavigationMode</a>(CString &amp;mode);


        gbool vrml2;    

        // GvNode enables
        gbool   useTextures;            
        gbool   useShapeHints;          
        gbool   useMaterials;
        gbool   useMovies;                      
        
        gbool   useBackground;          
        gbool   hasSoundDevice;         

        gbool   useSound;                       
        gbool   useRSXSound;            
        gbool   hasRSXSound;            
        int             soundQuality;           
        int             maxNumSounds;           
        gbool   soundDoppler;           


        int maxUserTextureSize;         


        void <a class="code" href="class_gview.html#a34">SetUseTextures</a>(gbool flag);
        void <a class="code" href="class_gview.html#a35">SetUseMovies</a>(gbool flag);

        void <a class="code" href="class_gview.html#a36">SetMaxUserTextureSize</a>(int mode);



        gbool   reportErrors;           
        int             errorLevel;
        int             maxInlineDepth;         
        gbool   incrementalUpdates;     // Experimental : update screen after inline reading

        gbool   updateIsComplex;        
        gbool   triggerUrlLoading;      

        // load modes for different node types
        int             inlineLoadMode;
        int             textureLoadMode;
        int             movieLoadMode;
        int             soundLoadMode;

        //int inlineLoadFlags;                  // loader flags 
        int             inlineWwwFlags;                         
        
        int             lastFrameLoadCnt;                       
        int             lastFrameLoadErrorCnt;          
        int             lastFrameInlineLoadCnt;         
        int             lastFrameScriptLoadCnt;         
        int             lastFrameTextureLoadCnt;        
        int             lastFrameSoundLoadCnt;          
        int             lastFrameProtoInstanceCnt;      

        int             maxFrameInlineLoadCnt;          
        int             maxFrameScriptLoadCnt;          
        int             maxFrameTextureLoadCnt;     
        int             maxFrameSoundLoadCnt;           


        void <a class="code" href="class_gview.html#a37">ClearCounts</a>() {
                lastFrameLoadCnt = 0;
                lastFrameLoadErrorCnt=0;
                lastFrameInlineLoadCnt=0;
                lastFrameScriptLoadCnt=0;       
                lastFrameTextureLoadCnt=0;
                lastFrameSoundLoadCnt=0;
                lastFrameProtoInstanceCnt=0;
                updateIsComplex = FALSE;
        }


        int anchorPreloadMode;  // preload anchors

                
        int initialTextureMode;         
        int initialTextureFilteringMode;
        int initalRenderingMode;  // initial rendering mode for VRML scenes

        float resetZoomFactor;
        float ignoreAllInlines; // flag , abort any inline loading

        // set useGLCache optimization flag 
        gbool <a class="code" href="class_gview.html#a38">SetUseGlCache</a>(gbool flag) {
                                        if (useGlCache == flag) return(flag);
                                        useGlCache = flag;
                                        if (!flag) <a class="code" href="class_gview.html#a189">InvalidateModelCache</a>();
                                        return(useGlCache); 
        }



        <a class="code" href="class_gtime.html">GTime</a> time;
        gbool playRealtime; // use real time stepping

        double loadTime;        // the global time, the scene was loaded

        // get current VRML2 time (secs from 1970)
        double <a class="code" href="class_gview.html#a39">Now</a>() const {
                if (playRealtime) 
                        return(<a class="code" href="class_gtime.html#d0">GTime::GetGlobalTime</a>()); // use system time
                else return(loadTime + time.t);
        }
        
        gbool autoPlay;         // start  animations on scene loading

        gbool <a class="code" href="class_gview.html#a40">AutoPlay</a>() { return(autoPlay); }
        
        void <a class="code" href="class_gview.html#a41">SetTargetFrameRate</a>(float targetFR);


        double theTime; // the current VRML simulation time 
        <a class="code" href="class_gvsftime.html">GvSFTime</a> time_changed; // the global time field

        // set the global animation time
        double <a class="code" href="class_gview.html#a42">SetTheTime</a>();

        // get current event timestamp
        inline double <a class="code" href="class_gvnode.html#a30">getTime</a>() const
        { 
                return theTime; 
        }; 

        // get pointer to variable where current event simulation time is stor
        inline double* <a class="code" href="class_gvnode.html#a31">getTimePtr</a>()
        { 
                return &amp;theTime; 
        }; 



        // timeSensors are triggered at beginning of frame
        // if this flag is true, sensors have been already triggered for this frame
        gbool thisFrameTimeSensorsTriggered;

        // trigger time sensors   
        // Result : TRUE there are TimeSensors, FALSE, no timeSensors in scene
        gbool <a class="code" href="class_gview.html#a45">TriggerTimeSensors</a>();

        // pending scripts, scripts where the eventsProcessed function need to be called 
        <a class="code" href="class_gvmfnode.html">GvMFNode</a> pendingScripts;

        void  <a class="code" href="class_gview.html#a46">initPendingScripts</a>();     
        void  <a class="code" href="class_gview.html#a47">termPendingScripts</a>();
        
        // call the eventsProcessed function and clear pendingScripts
        GvBool <a class="code" href="class_gview.html#a48">callPendingScripts</a>();


        //
        // 3D Device / Renderstate 
        //

        //the gl &lt;c RenderState&gt; object, maintains/reflects current rendering settings
        <a class="code" href="class_renderstate.html">RenderState</a> renderState;


#ifdef _OGL
#ifdef _GLMESA
    <a class="code" href="class_gxmesadevice.html">GXMesaDevice</a> *device;
#endif

#ifdef _WIN32
        GOpenglDeviceWGL *device;
#endif
#endif


#ifdef _D3D

        <a class="code" href="class_gd3device.html">GD3Device</a> *device;

        // globals
        //HINSTANCE hInstApp;     /* application instance for dialog boxes */

    BOOL bSingleStepMode;        /* render one frame at a time */
    BOOL bDrawAFrame;            /* render on this pass of the main loop */
    BOOL bClearsOn;              /* clear the back and z-buffer each frame */
    BOOL bShowFrameRate;         /* show the frame rate at the top */
    BOOL bShowInfo;              /* show window information at the bottom */
    BOOL bResizingDisabled;      /* do not allow resizing */

    BOOL bResized; /* the window has resized or some other drastic change, the
                      entire client area should be cleared */
    BOOL bQuit;    /* program is about to terminate */

    LPDIRECTDRAWSURFACE lpFrameRateBuffer; /* frame rate surface */
    LPDIRECTDRAWSURFACE lpInfoBuffer;      /* window info surface */


        // callbacks from device 
        static BOOL AfterDeviceCreated(int w, int h, LPDIRECT3DVIEWPORT* lplpViewport, LPVOID lpContext);
        
        BOOL AfterDeviceCreated(int w, int h, LPDIRECT3DVIEWPORT* lplpViewport);
        static BOOL BeforeDeviceDestroyed(LPVOID lpContext);
        BOOL BeforeDeviceDestroyed();


        /* create the D3D device */
        BOOL CreateD3DDevice(
                         HWND hwnd,HWND hwndFrame,
                         const char *driver= NULL,      // preferenced Driver, default "Ramp Driver"
                         <a class="code" href="class_gdriverhints.html">GDriverHints</a> *driverHints = NULL);

        /*
     * InitView
     * Builds execute buffer and all components needed to be added to viewport.
     */

        BOOL InitView();



        void ReleaseView();


        void ReleaseScene();



        /*
        * RestoreSurfaces
        * Restores any lost surfaces.  Returns TRUE if all surfaces are not lost and
        * FALSE if one or more surfaces is lost and can not be restored at the
        * moment.
        */
        BOOL RestoreSurfaces();


        /*
        * CleanUpAndPostQuit
        * Release all D3D objects, post a quit message and set the bQuit flag
        */
        void CleanUpAndPostQuit();

        void ReportD3DError();
        void G__cdecl Error( LPSTR fmt, ... );

#endif

        void <a class="code" href="class_gview.html#a49">ReleaseTextures</a>();


#ifdef WIN32

#ifdef _OGL
    LPDIRECTDRAW           lpDD;         /* DirectDraw object, needed for Actvie Move */
#endif

        // get pointer to DDRAW object 
        LPDIRECTDRAW GetDirectDraw();

#endif

        //
        // sound stuff
        //
        <a class="code" href="class_gsounddevice.html">GSoundDevice</a> *soundDevice; // the sound device 
        gbool m_playSoundStarted;       // we have started some PlaySound stuff in PlaySoundFile

        // get sound device, initialize if needed 
        <a class="code" href="class_gsounddevice.html">GSoundDevice</a> *<a class="code" href="class_gview.html#a50">GetSoundDevice</a>();
        
        // initialize the sound device
        // return TRUE if initialized, GetSoundDevice() woud return non NULL soundevice
        gbool <a class="code" href="class_gview.html#a51">InitializeSound</a>();

        // release the sound device
        void <a class="code" href="class_gview.html#a52">ReleaseSound</a>();

        // set sound mode flag 
        // setting to false will kill sounddevice and sounds
        gbool <a class="code" href="class_gview.html#a53">SetUseSound</a>(gbool flag);

        // get sound mode flag 
        gbool <a class="code" href="class_gview.html#a54">GetUseSound</a>();

        // do we have a sound device,
        // detected on first try to initialize
        gbool <a class="code" href="class_gview.html#a55">HasSoundDevice</a>();

        // play a sound file
        gbool <a class="code" href="class_gview.html#a56">PlaySoundFile</a>(const char *fileName);

        // delayed execution of replaceWorld / browser.loadURL

        GvBool     hasNewScene; 
        <a class="code" href="class_gvsfnode.html">GvSFNode</a>   newScene; // the new scene to be loaded

        GvBool     hasNewUrl;   // we should load a new url

        <a class="code" href="class_gvmfstring.html">GvMFString</a> newUrl;
        <a class="code" href="class_gvmfstring.html">GvMFString</a> newUrlParams;
        <a class="code" href="class_gvstring.html">GvString</a>   newUrlBase;  


        //check for replaceWorld loadURL requests 
        gbool <a class="code" href="class_gview.html#a57">CheckForSceneChange</a>();


        //
        // Model functions
        //

        // The Model
        <a class="code" href="class_gshell.html">GShell</a> *theShell;

        <a class="code" href="class_gshell.html">GShell</a> * backupShell;

        <a class="code" href="class_gworld.html">GWorld</a> *theWorld;

        /* GvScene  */ 
        <a class="code" href="class_gvnodehandle.html">GvNodeHandle</a> theScene;

        <a class="code" href="class_gvscene.html">GvScene</a>* <a class="code" href="class_gview.html#a58">GetScene</a>() const { return (<a class="code" href="class_gvscene.html">GvScene</a>*) (<a class="code" href="class_gvnode.html">GvNode</a>*) theScene; };

        gbool <a class="code" href="class_gview.html#a59">IsVrml2</a>(); 


        // flag that a scene info update is necessary , 1: needed for UI, 2 : after rendering because of lights / scripts
        int doUpdateSceneInfo;
        int doUpdateBBox;

        <a class="code" href="class_gvsceneinfo.html">GvSceneInfo</a> *sceneInfo;

        <a class="code" href="class_gvsceneinfo.html">GvSceneInfo</a> * <a class="code" href="class_gview.html#a60">GetSceneInfo</a>(); 

        int activeInlinesLimit;         
        float activeInlinesPurge;       

        void <a class="code" href="class_gview.html#a61">Register</a>(<a class="code" href="class_gvtimesensor.html">GvTimeSensor</a> *s);

        void <a class="code" href="class_gview.html#a61">Register</a>(<a class="code" href="class_gvmovietexture.html">GvMovieTexture</a> *s);

        void <a class="code" href="class_gview.html#a61">Register</a>(<a class="code" href="class_gvaudioclip.html">GvAudioClip</a> *s);

        void <a class="code" href="class_gview.html#a61">Register</a>(<a class="code" href="class_gvsound.html">GvSound</a> *s);

        void <a class="code" href="class_gview.html#a65">RegisterSpecialMedia</a>(<a class="code" href="class_gvnode.html">GvNode</a> *s);

        void <a class="code" href="class_gview.html#a61">Register</a>(<a class="code" href="class_gvmenusensor.html">GvMenuSensor</a> *s);

        void <a class="code" href="class_gview.html#a61">Register</a>(<a class="code" href="class_gvscript.html">GvScript</a> *s);

        void <a class="code" href="class_gview.html#a61">Register</a>(<a class="code" href="class_gvviewpoint.html">GvViewpoint</a> *s);

        void <a class="code" href="class_gview.html#a61">Register</a>(<a class="code" href="class_gvlight.html">GvLight</a> *s);

        void <a class="code" href="class_gview.html#a61">Register</a>(<a class="code" href="class_gv2inline.html">Gv2Inline</a> *s);

        // Register special nodes 
        void <a class="code" href="class_gview.html#a71">RegisterNode</a>(<a class="code" href="class_gvnode.html">GvNode</a> *n);
        void <a class="code" href="class_gview.html#a71">RegisterNode</a>(<a class="code" href="class_gvmfnode.html">GvMFNode</a> &amp;nodes);


        gbool <a class="code" href="class_gview.html#a73">SceneHasTextures</a>();
 

        <a class="code" href="class_gworld.html">GWorld</a>* <a class="code" href="class_gview.html#a74">GetWorld</a>() const { return(theWorld); }

        // terminate current scene
        int  <a class="code" href="class_gview.html#a75">TermScene</a>();
                
        int <a class="code" href="class_gview.html#a76">SetShell</a>(<a class="code" href="class_gshell.html">GShell</a> *shell,int resetCamera=1);

        int <a class="code" href="class_gview.html#a77">SetNode</a>(<a class="code" href="class_gvnode.html">GvNode</a> *root,int resetCamera=1);

    // set the current model to &lt;c GvScene&gt; object 
    int <a class="code" href="class_gview.html#a78">SetScene</a>(<a class="code" href="class_gvscene.html">GvScene</a> *scene,gbool bindNodes=FALSE,int resetCamera=1);

        // bind initial scene nodes 
        void <a class="code" href="class_gview.html#a79">BindScene</a>();


    // reset all settings to the VRML 2 defaults 
    void <a class="code" href="class_gview.html#a80">ResetSceneDefaults</a>();
        
        // set scene to the initial default state
        // bind initial nodes etc.
        int <a class="code" href="class_gview.html#a81">SetSceneDefaults</a>();


        // get path to installation directory 
        CString <a class="code" href="class_gview.html#a82">GetInstallDirectory</a>();


        <a class="code" href="class_gcamera.html">GCamera</a> *camera;

        <a class="code" href="class_gcamera.html">GCamera</a> &amp;<a class="code" href="class_gview.html#a83">GetCamera</a>() { return (*camera); }

        // additional matrix transforming camera to the global camera
        <a class="code" href="class_matrixandinverse.html">MatrixAndInverse</a> cameraMatrix;
        
        // camera transformed by camera matrix 
        <a class="code" href="class_gcamera.html">GCamera</a> *globalCamera; 

        <a class="code" href="class_gcamera.html">GCamera</a> &amp;<a class="code" href="class_gview.html#a84">GetGlobalCamera</a>() { return (*globalCamera); }

        <a class="code" href="class_gviewinfo.html">GViewInfo</a> viewInfo; // current view transformation

        // third person mode active ?
        gbool   thirdPersonView;

        // type of floating camera
        <a class="code" href="class_gvsfint32.html">GvSFInt32</a>       thirdPersonMode;

        // otherAvatars view
        gbool <a class="code" href="class_gview.html#a85">ThirdPersonView</a>() const { return thirdPersonView; }
        
        // get type of third person mode
        int <a class="code" href="class_gview.html#a86">getThirdPersonMode</a>() { return thirdPersonMode.<a class="code" href="class_gvsflong.html#a4">get</a>(); }

        <a class="code" href="class_gcamera.html">GCamera</a> thirdPersonFollowCamera;

        // the camera for 3d person mode
        <a class="code" href="class_gcamera.html">GCamera</a> *physicalCamera;

        // camera interpolator 
        <a class="code" href="class_gcamerainterpolator.html">GCameraInterpolator</a> physicalCameraInterpolator;

        // must phyiscal camera animated ?
        gbool <a class="code" href="class_gview.html#a87">AnimatingPhysicalCamera</a>() { return physicalCameraInterpolator.alpha &lt; 1.0f; }     

        // get the real amera used for 3d display  ( 3dperson view / stereo etc)
        <a class="code" href="class_gcamera.html">GCamera</a> *<a class="code" href="class_gview.html#a88">GetPhysicalCamera</a>() 
        {
                if (thirdPersonView) return physicalCamera;
                else return globalCamera;
        }

        // 3rd person mode camera offset variables 
        //Point followDolly;
        //Point followOrbit;
        //Point followPan;

        <a class="code" href="class_gvsfvec3f.html">GvSFVec3f</a> followDolly;
        <a class="code" href="class_gvsfvec3f.html">GvSFVec3f</a> followOrbit;
        <a class="code" href="class_gvsfvec3f.html">GvSFVec3f</a> followPan;

        // update the physical camera for a changed globalCamera
        gbool <a class="code" href="class_gview.html#a89">UpdatePhysicalCamera</a>(gbool cameraChanged);

        // set third person mode on (will offset the camera)
        gbool <a class="code" href="class_gview.html#a90">SetThirdPersonView</a>(gbool flag);


        // set camera transform transforming camera to globalCamera 
        void <a class="code" href="class_gview.html#a91">SetCameraMatrix</a>(const <a class="code" href="class_matrix.html">Matrix</a> &amp;m);
        void <a class="code" href="class_gview.html#a92">SetCameraMatrixIdentity</a>();

        // update global camera from camera + cameraMatrix
        void <a class="code" href="class_gview.html#a93">UpdateGlobalCamera</a>();

        // update default z-range of global camera 
        void <a class="code" href="class_gview.html#a94">UpdateDefaultZRange</a>();

        // update navigations values from  cameraMatrix
        void <a class="code" href="class_gview.html#a95">UpdateGlobalNavigationValues</a>();

        <a class="code" href="class_geventhandler.html">GEventHandler</a> *eventHandler;
        // stack 

        void <a class="code" href="class_gview.html#a96">FlushEventHandlers</a>();

        void <a class="code" href="class_gview.html#a97">PushEventHandler</a>(<a class="code" href="class_geventhandler.html">GEventHandler</a> *eventHandler);

        <a class="code" href="class_geventhandler.html">GEventHandler</a> *<a class="code" href="class_gview.html#a98">PopEventHandler</a>();

        void <a class="code" href="class_gview.html#a99">SetEventHandler</a>(<a class="code" href="class_geventhandler.html">GEventHandler</a> *eventHandler);

        <a class="code" href="class_geventhandler.html">GEventHandler</a> *<a class="code" href="class_gview.html#a100">GetEventHandler</a>() { return eventHandler; }


        // convert a pixel coordinate to normalized screen coordinate (-1..1) (-1 ..1)
        void <a class="code" href="class_gview.html#a101">Pixel2Screen</a>(const CPoint &amp;pixel,<a class="code" href="class_point.html">Point</a> &amp;screen,float screenZ = 0.0);

        // convert a normalized screen coordinate to pixel 
        void <a class="code" href="class_gview.html#a102">Screen2Pixel</a>(const <a class="code" href="class_point.html">Point</a> &amp;screen,<a class="code" href="class_point.html">Point</a> &amp;pixel);

        // convert a normalized screen coordinate to world coordinates
    int <a class="code" href="class_gview.html#a103">Screen2World</a>(const <a class="code" href="class_point.html">Point</a> &amp;screen, <a class="code" href="class_point.html">Point</a> &amp;world) {  return viewInfo.<a class="code" href="class_gviewinfo.html#a0">View2World</a>(screen,world); }
    int <a class="code" href="class_gview.html#a104">World2Screen</a>(const <a class="code" href="class_point.html">Point</a> &amp;world, <a class="code" href="class_point.html">Point</a> &amp;screen) {  return viewInfo.<a class="code" href="class_gviewinfo.html#a1">World2View</a>(world,screen); }

        
    int <a class="code" href="class_gview.html#a105">Cam2World</a>(const <a class="code" href="class_point.html">Point</a> &amp;screen, <a class="code" href="class_point.html">Point</a> &amp;world) {  return viewInfo.<a class="code" href="class_gviewinfo.html#a3">Cam2World</a>(screen,world); }
    int <a class="code" href="class_gview.html#a106">World2Cam</a>(const <a class="code" href="class_point.html">Point</a> &amp;world, <a class="code" href="class_point.html">Point</a> &amp;screen) {  return viewInfo.<a class="code" href="class_gviewinfo.html#a2">World2Cam</a>(world,screen); }

        // compute world ray for screen coordinate 
        void <a class="code" href="class_gview.html#a107">ComputeWorldRay</a>(const <a class="code" href="class_point.html">Point</a> &amp;screen,<a class="code" href="class_rayrange.html">RayRange</a> &amp;ray);

        

        float viewStepSpeed;    // step factor for camera moves
        float viewStepSpeedLocal;       // step factor for camera moves
        float viewAngleSpeed;   // factor for camera rotations 

        // ??Matrix viewpointTransform; // transfrom of viewpoint 
        // from navigation Info
        // local values are transformed by viewpoint transform to global values 

        gbool allowAnyNavigation;       // allow navigation mode switching &amp; viewpoint control 
        gbool collisionDetection; // currently collision detection active
        gbool stayOnGround; // currently stay over ground activated 

        void <a class="code" href="class_gview.html#a108">setCollisionDetection</a>(gbool flag) { collisionDetection = flag; }
        gbool <a class="code" href="class_gview.html#a109">getCollisionDetection</a>() { return collisionDetection; }
        
        void <a class="code" href="class_gview.html#a110">setGravity</a>(gbool flag) { stayOnGround = flag; }
        gbool <a class="code" href="class_gview.html#a111">getGravity</a>() { return stayOnGround; }

        void <a class="code" href="class_gview.html#a112">setViewpointAnimation</a>(gbool flag) { cameraAnimate = flag; }
        gbool <a class="code" href="class_gview.html#a113">getViewpointAnimation</a>() { return cameraAnimate; }


        <a class="code" href="class_point.html">Point</a> downDirection; // the direction vector point to ground 
        <a class="code" href="class_point.html">Point</a> downDirectionLocal;

        float visibilityLimitNear;
        float visibilityLimitNearLocal;

        float visibilityLimit;
        float visibilityLimitLocal;
        float collisionDistance;
        float collisionDistanceLocal;
        float heightOverGround;
        float heightOverGroundLocal;
        float stepOverSize;
        float stepOverSizeLocal;

        
        //the rapid-stuff
        gbool useRapid;//use Rapid collision-detection lib

        <a class="code" href="class_gshell.html">GShell</a> *speedBox;//the shape that represents the avatar and its movement (local coordinates)
        <a class="code" href="class_gshell.html">GShell</a> *speedBox2;
        <a class="code" href="class_gshell.html">GShell</a> *speedBoxGlobal;//the shape that represents the avatar and its movement (global coordinates)
        <a class="code" href="class_rapidcollide.html">rapidCollide</a> *myRapid;  // rapid helper structure

        <a class="code" href="class_gconvexvolume.html">GConvexVolume</a> *speedBoxVolume;  // convex volume for BBox test

        float <a class="code" href="class_gview.html#a114">getVisibilityLimit</a>() { return visibilityLimit; }
        float <a class="code" href="class_gview.html#a115">getCollisionDistance</a>() { return collisionDistance; }
        float <a class="code" href="class_gview.html#a116">getAvatarHeight</a>() { return heightOverGround; }
        float <a class="code" href="class_gview.html#a117">getStepOverSize</a>() { return stepOverSize; }
        float <a class="code" href="class_gview.html#a118">getZNear</a>() { return globalCamera-&gt;znear; }
        float <a class="code" href="class_gview.html#a119">getZFar</a>() { return globalCamera-&gt;zfar; }


        gbool autoZRange;               // automatically recompute z-range 

        gbool collisionPlane;   // enable collision test with ground plane 

        
        <a class="code" href="class_bbox.html">BBox</a>    bbox;   // last computed scene bbox, recomputed eg. by UpdateBbox

        // update scene bounding Box
        int <a class="code" href="class_gview.html#a120">UpdateBoundingBox</a>();

        // update scene bounding Box incrementally 
        int <a class="code" href="class_gview.html#a120">UpdateBoundingBox</a>(<a class="code" href="class_bbox.html">BBox</a> &amp;<a class="code" href="class_box.html">box</a>);

        // traverse scene graph and trigger loads 
        int <a class="code" href="class_gview.html#a122">LoadAllInlines</a>(int oneOnly,gbool inlines,gbool textures=gfalse);

        // traverse nodes and trigger loads 
        int <a class="code" href="class_gview.html#a123">PrefetchNodes</a>(<a class="code" href="class_gvmfnode.html">GvMFNode</a> &amp;nodes, int oneOnly=gfalse,gbool inlines=gtrue,gbool textures=gtrue);

        // evaluate &amp; set the permission level for the script
        void <a class="code" href="class_gview.html#a124">GetScriptPermissions</a>(<a class="code" href="class_gvscript.html">GvScript</a> *script, const char *url);

        int <a class="code" href="class_gview.html#a125">CheckInlineUnload</a>();
        
        int <a class="code" href="class_gview.html#a126">ReadModel</a>(const char *FileName,int fmt,<a class="code" href="class_gfile.html">GFile</a> *theFile=NULL);
        
        // read a model from any known file type
        // including unzip
        int <a class="code" href="class_gview.html#a126">ReadModel</a>(const char *FileName); 

    // Create a VRML scene out of single object model (shell) 
    <a class="code" href="class_gvnode.html">GvNode</a>* <a class="code" href="class_gview.html#a128">CreateVrmlScene</a>(gbool vrml2=FALSE);
        
        // read a model from any known file type
        // including unzip
        // view will own file structure if sucessufll
        int <a class="code" href="class_gview.html#a126">ReadModel</a>(<a class="code" href="class_gfile.html">GFile</a> *file); 

        // get absolute home url
        const char * <a class="code" href="class_gview.html#a130">GetHomeUrl</a>() const;

        // get the absolute url
        const char * <a class="code" href="class_gview.html#a131">GetUrl</a>() const;


        int <a class="code" href="class_gview.html#a132">ReadShell</a>(const char *FileName,int fmt);

        int <a class="code" href="class_gview.html#a133">ReadTexturedPolygon</a>(const char *FileName,int format);

        int <a class="code" href="class_gview.html#a134">SetTexture</a>(const char *FileName,int format=0);

        int <a class="code" href="class_gview.html#a135">EditTexture</a>(const char *FileName,int format=0);

        int <a class="code" href="class_gview.html#a136">ClearTexture</a>();

    CString textureFile;    // name of current texture image file 
    
        const char *<a class="code" href="class_gview.html#a137">GetTexture</a>() const { return(textureFile); }

        void <a class="code" href="class_gview.html#a138">CameraReset</a>();

        int  <a class="code" href="class_gview.html#a139">SetCamera</a>(<a class="code" href="class_gvnode.html">GvNode</a> *cameraNode,const <a class="code" href="class_matrix.html">Matrix</a> *cameraTransform=NULL,int animate=0);
    
    // set viewpoint viewpoint index
    int <a class="code" href="class_gview.html#a140">SetViewpoint</a>(int index,int animate=0);


        int  <a class="code" href="class_gview.html#a141">AnimateToCamera</a>(<a class="code" href="class_gvnode.html">GvNode</a> *cameraNode,const <a class="code" href="class_matrix.html">Matrix</a> *cameraTransform=NULL);
        int  <a class="code" href="class_gview.html#a141">AnimateToCamera</a>(<a class="code" href="class_gvnode.html">GvNode</a> *cameraNode,<a class="code" href="class_gvpath.html">GvPath</a> &amp;cameraPath);

        // state variables for camera animation
    <a class="code" href="class_gcamerainterpolator.html">GCameraInterpolator</a> *cameraInterpolator;

    <a class="code" href="class_gvsfnode.html">GvSFNode</a> cameraAnimateTargetViewpoint;              // target animation viewpint 
        <a class="code" href="class_gvpath.html">GvPath</a> cameraAnimateTargetViewpointPath;        // target viewpoint path

    
    gbool cameraInterpolateAll; // flag 
    gbool cameraInterpolateAllCycle; // flag 
    int cameraInterpolateCurrent; // current viewpoint index
    int cameraInterpolateEnd; // end viewpoint index

   
    gbool cameraAnimate;  // animate cameras on viewpoint change 
    
    gbool <a class="code" href="class_gview.html#a143">AnimatingCamera</a>() { return cameraInterpolator != NULL; }

    int <a class="code" href="class_gview.html#a144">AnimateCameraStep</a>();
   
    // stop camera animation 
    void <a class="code" href="class_gview.html#a145">AnimateCameraStop</a>();

    // animate through all camera 
    void <a class="code" href="class_gview.html#a146">AnimateAllCameras</a>();

    //  current viewpointIndex
    int viewpointIndex;

    // goto prev/next viewpoint
    int <a class="code" href="class_gview.html#a147">SetNextViewpoint</a>(int animate=0);
    int <a class="code" href="class_gview.html#a148">SetPrevViewpoint</a>(int animate=0);
    
    // set viewpoint viewpoint index without change in camera
    int <a class="code" href="class_gview.html#a149">SetViewpointIndex</a>(int index);
    
    // return current viewpoint index
    int <a class="code" href="class_gview.html#a151">GetViewpointIndex</a>(int &amp;index) { index = viewpointIndex; return(1); }

    // return current viewpoint index
    int <a class="code" href="class_gview.html#a151">GetViewpointIndex</a>() { return viewpointIndex; }

    // return name of current viewpoint 
    const char * <a class="code" href="class_gview.html#a152">GetViewpointName</a>();

        // camera follows picked object 
        gbool followObject;

        // the path to the object
        // checked for changed transformations
        <a class="code" href="class_gvpath.html">GvPath</a> followObjectPath;
        <a class="code" href="class_point.html">Point</a> followObjectPosition;     // local position of object to be followed 
        <a class="code" href="class_point.html">Point</a> followObjectPositionGlobal;       // local position of object to be followed 
        <a class="code" href="class_point.html">Point</a> followObjectCameraPosition; // camera position in local space 
        <a class="code" href="class_point.html">Point</a> followObjectNormal;

        void <a class="code" href="class_gview.html#a153">SetFollowObjectOff</a>(); // switch off follow object mode 

                                                           /*
        set follow object mode given a node and a reference point 
        result FALSE if node null or not found in tranform hierarchy
        */

        gbool <a class="code" href="class_gview.html#a154">SetFollowObject</a>(<a class="code" href="class_gvnode.html">GvNode</a> *node,const <a class="code" href="class_point.html">Point</a> &amp;p);



        <a class="code" href="class_gvsfnode.html">GvSFNode</a> sharedZone;            // SharedZone 

        gbool showAvatar;                       // show my avatar, i.e. it is part of scene

        <a class="code" href="class_gvsfstring.html">GvSFString</a> myAvatarURL;                 // the filename for myAvatar 
        <a class="code" href="class_gvsfstring.html">GvSFString</a> myAvatarName;                // the name of my avatar

        // 3d person mode bound avatar 
        <a class="code" href="class_gvsfnode.html">GvSFNode</a> boundAvatar;           // the avatar bound and added to scene at top-level
        <a class="code" href="class_gvsfnode.html">GvSFNode</a> myAvatar;                      // node source for my Avatar

        void <a class="code" href="class_gview.html#a155">set_myAvatarURL</a>(<a class="code" href="class_gvsfstring.html">GvSFString</a> *event);

        // eventIn , callback for createVrmlFromURL
        void <a class="code" href="class_gview.html#a156">set_myAvatarNodes</a>(<a class="code" href="class_gvmfnode.html">GvMFNode</a> *event);
        void <a class="code" href="class_gview.html#a157">set_myAvatarName</a>(<a class="code" href="class_gvsfstring.html">GvSFString</a> *event);
        void <a class="code" href="class_gview.html#a158">set_showMyAvatar</a>(<a class="code" href="class_gvsfbool.html">GvSFBool</a> *event);
        
        // issue predefined guesture number 1.. nn
        void <a class="code" href="class_gview.html#a159">set_myAvatarGesture</a>(<a class="code" href="class_gvsfint32.html">GvSFInt32</a> *event);
        <a class="code" href="class_gvsfint32.html">GvSFInt32</a> myAvatarGesture; // event out for sending guesture
        
        <a class="code" href="class_gvmffloat.html">GvMFFloat</a> myAvatarAvatarSize; // avatar Size info for my avatar  (used instead of NavigationInfo


        // helper class storing avatar eventIn's for 3rd person mode
        
        class GAvatarInfo { 
        public :                
                
                GAvatarInfo() : avatarSetTranslation(-1),avatarSetRotation(-1),avatarSetScale(-1),avatarSetChoice(-1),
                        avatarAvatarSize(-1)
                {
                }
                ~GAvatarInfo() 
                {
                }


                // default guestures 
                <a class="code" href="class_gvnodehandle.html">GvNodeHandle</a> nodeGesture;
                int avatarSetGesture; // SFInt32

                <a class="code" href="class_intarray.html">IntArray</a> gestures;
                <a class="code" href="class_gvmfstring.html">GvMFString</a> *gestureNames;

                int avatarGestureChanged; // SFInt32
                <a class="code" href="class_gvnodehandle.html">GvNodeHandle</a> avatarGestureChangedRoute; // the route from avtar to browser

                int avatarAvatarSize; // MFFloat
                <a class="code" href="class_gvnodehandle.html">GvNodeHandle</a> avatarAvatarSizeRoute; // the route from avatar to browser

                // transform

                <a class="code" href="class_gvnodehandle.html">GvNodeHandle</a> nodeTransform;

                // event codes Ins of avatar
                int avatarSetTranslation; // SFVec3f
                int avatarSetRotation;    // SFRotation
                int avatarSetScale;               // SFVec3f

                // switch 
                <a class="code" href="class_gvnodehandle.html">GvNodeHandle</a> nodeChoice;
                int avatarSetChoice;      // SFInt32

                // extended guestures 
                <a class="code" href="class_gvnodehandle.html">GvNodeHandle</a> nodeEvents;

                int avatarEnterWorld;           // SFTime
                int avatarLeaveWorld;           // SFTime

                int avatarBeginMove;            // SFTime
                int avatarEndMove;                      // SFTime

                int avatarBeginCollision;               // SFTime
                int avatarEndCollision;                 // SFTime

                int avatarBeginFly;                     // SFTime
                int avatarEndFly;                       // SFTime

                int avatarBeginJump;            // SFTime
                int avatarEndJump;                      // SFTime

                int avatarBeginClick;           // SFTime

                // one time handled
                //      eventIn SFString set_url
                //      eventIn SFString set_nickname
                //  eventIn SFBool isPilot
                // e
        
        };
        
        GAvatarInfo avatarInfo;


        <a class="code" href="class_gvmfrotation.html">GvMFRotation</a> avatarRotation;
        <a class="code" href="class_gvmfvec3f.html">GvMFVec3f</a> avatarTranslation;
        
        // bind new avatar 
        void BindAvatar(<a class="code" href="class_gvnode.html">GvNode</a>* avatar);

        // load avatar from file 
        int LoadAvatar(const char *avatar);

        // show avatar, load if needed
        gbool ShowAvatar(gbool mode);

        // is avatar shown
        gbool IsAvatarShown();

        // set avatar gesture
        void SetAvatarGesture(<a class="code" href="class_gvnode.html">GvNode</a>* node,int eventId);


    // a set of created viewpoints
    <a class="code" href="class_gvmfnode.html">GvMFNode</a> viewpoints;
    
    // delete list of viewpoints
    void FlushViewpoints();

        // VRML2 bindable nodes 
    <a class="code" href="class_gvsfnode.html">GvSFNode</a> boundViewpoint; // the bounded viewpoint node (top of stack)

        // the path to the bound viewpoint
        // checked for changed transformations
        <a class="code" href="class_gvpath.html">GvPath</a> boundViewpointPath;

    <a class="code" href="class_gvmfnode.html">GvMFNode</a> boundViewpointStack;               // list of stacked Viewpoints

        gbool boundViewpointChanged; // flag : 1, viewpoint has been changed 
        
        // the path to the bound viewpoint
        // checked for changed transformations

        void BindViewpoint(<a class="code" href="class_gvviewpoint.html">GvViewpoint</a> *newViewpoint);
        void BindViewpoint(<a class="code" href="class_gvviewpoint.html">GvViewpoint</a> *newViewpoint,GvBool bind);
    
        <a class="code" href="class_gvsfnode.html">GvSFNode</a> boundNavigationInfo; // the bounded NavigationInfo node (top of stack)
        <a class="code" href="class_gvpath.html">GvPath</a> boundNavigationInfoPath; 

        <a class="code" href="class_gvmfnode.html">GvMFNode</a> boundNavigationInfoStack;      // list of stacked NavigationInfos
        gbool boundNavigationInfoChanged; // flag : 1, fog  has been changed 

        void BindNavigationInfo(<a class="code" href="class_gvnavigationinfo.html">GvNavigationInfo</a> *newNavigationInfo);
        void BindNavigationInfo(<a class="code" href="class_gvnavigationinfo.html">GvNavigationInfo</a> *newNavigationInfo,GvBool bind);

    <a class="code" href="class_gvsfnode.html">GvSFNode</a> boundFog;    // the bounded fog node (top of stack)
    <a class="code" href="class_gvpath.html">GvPath</a> boundFogPath;
    <a class="code" href="class_gvmfnode.html">GvMFNode</a> boundFogStack; // list of stacked Fog Nodes
        gbool boundFogChanged; // flag : 1, fog  has been changed 

        void BindFog(<a class="code" href="class_gvfog.html">GvFog</a> *newFog);
        void BindFog(<a class="code" href="class_gvfog.html">GvFog</a> *newFog,GvBool bind);
    
        <a class="code" href="class_gvsfnode.html">GvSFNode</a> boundBackground;
        <a class="code" href="class_gvpath.html">GvPath</a> boundBackgroundPath;
        <a class="code" href="class_gvmfnode.html">GvMFNode</a> boundBackgroundStack;
        gbool boundBackgroundChanged; // flag : 1, background  has been changed 

        void BindBackground(<a class="code" href="class_gvbackground.html">GvBackground</a> *newBackground);
        void BindBackground(<a class="code" href="class_gvbackground.html">GvBackground</a> *newBackground,GvBool bind);
        
        // update the camera used for VRML 2.0 Background Node rendering 
        void UpdateBackgroundCamera(<a class="code" href="class_vector.html">Vector</a> axis,float angle);

        // empty all VRML 2 bounded nodes
        void FlushBoundedNodes();

        // the currently edited node 
        <a class="code" href="class_gvsfnode.html">GvSFNode</a> editNode;
        <a class="code" href="class_gvpath.html">GvPath</a> editNodePath;

        // list of scene nodes with Proto definitions (for EXTERNPROTO)
        <a class="code" href="class_gvmfnode.html">GvMFNode</a> protoScenes;


        // find proto for extern proto with url "url", and optional name "name"
        <a class="code" href="class_gvproto.html">GvProto</a>* getProto(const char *url,const char *name);

        // empty proto scenes 
        void FlushProtoScenes();
        
        // add scene to proto scenes
        void addProtoScene(<a class="code" href="class_gvscene.html">GvScene</a> *protoScene);


        <a class="code" href="class_gvmfnode.html">GvMFNode</a> pendingExternProtos; // list of pending externprotos

        // add externproto to list of unloaded externprotos
        void RegisterPending(<a class="code" href="class_gvexternproto.html">GvExternProto</a> *proto);

        // remove externproto to list of unloaded externprotos
        void UnRegisterPending(<a class="code" href="class_gvexternproto.html">GvExternProto</a> *proto);

        // empty pending externproto's
        void FlushPendingExternProtos();




        // get node, specified by urn "urn:inet:glview.com: ...."
        <a class="code" href="class_gvnode.html">GvNode</a>* newUrnInstance(const char *url);


        int  SetCamera(const char *cameraName) { return SetCamera(cameraName,cameraAnimate); }
        int  SetCamera(const char *cameraName,int animate);

        int  SaveCamera(const char *cameraName);
        
        // save current camera into camera node 
        int  SaveCamera(<a class="code" href="class_gvnode.html">GvNode</a> *cameraNode);
        
        int  SaveCamera(const char *cameraName,float t);
        
    int  SetCamera(float t);

#ifdef _OGL
        glCache modelCache;


        // necessary if model data have been changed

        void InvalidateModelCache() { modelCache.Invalidate(); }
#else 
    void InvalidateModelCache() { };
#endif


        // texture parameters are present for theShell
        void SetDefaultTextureParameters();

        void FlushBackupShell();


        // query functions for button checking
        gbool GetDithering();
        gbool GetLightMode();
        gbool GetNormalMode();
        gbool GetBackfaceCulling();
        gbool GetFrontFaceCW();
        gbool GetLocalViewer();
        gbool GetLocalColors();
        gbool GetTexturing();
        gbool GetTransparency();
        gbool GetLineAntialiasing();
        gbool GetAntiAliasing();
        int GetRenderMode();
        gbool GetTwoSidedLighting();
        gbool GetComputePrimitiveList();


        int SetRenderMode(GRenderMode newMode);
        
        // set global render mode to mode
        int SetRenderMode(const char * newMode);


        gbool SetNormalMode(gbool);
        gbool SetDithering(gbool);
        gbool SetLightMode(gbool mode);
        gbool SetBackfaceCulling(gbool mode);
        gbool SetFrontFaceCW(gbool mode);
        gbool SetLocalViewer(gbool mode);
        gbool SetTwoSidedLighting(gbool mode);
        gbool SetLocalColors(gbool mode);
        gbool SetTexturing(gbool mode);

        // set texture filtering 0 : nearest : 1 : bilinear
        int SetTextureFiltering(int mode);
        int GetTextureFiltering() { return TextureFilteringMode; }

        int SetTextureMipMap(int mode);
        int GetTextureMipMap();


        gbool SetTransparency(gbool mode);
        gbool SetLineAntialiasing(gbool mode);
        
        gbool SetAntiAliasing(gbool mode);

        gbool SetComputePrimitiveList(gbool mode);

        // Toggles for User-Interfaces callbacks

        int ToggleNormalMode();
        int ToggleLightMode();
        int ToggleBackfaceCulling();
        int ToggleFrontFaceCW();
        int ToggleLocalViewer();
        int ToggleTwoSidedLighting();
        int ToggleLocalColors();
        int ToggleTexturing();

        int ToggleTransparency();

        int ToggleLineAntialiasing();
        int ToggleComputePrimitveList();


        // fullscreen support 
        int GetFullScreen();
        int SetFullScreen(int mode);
        BOOL m_bTestFullScreen;

        int ToggleFullScreen();

        // query for capabilities, see GCaps.h for definition
        int GetCap(int cap);

        // set/get a global browser option
        gbool SetOption(const char *option,const char *value);
        gbool GetOption(const char *option,<a class="code" href="class_gvstring.html">GvString</a> &amp;value);



#ifdef _OGL
        gbool fullScreen;

#ifdef WIN32
        HMENU savedFrameMenu;
        long savedFrameWinStyle;
        long savedWinStyle;
#endif

#endif



        // interface for material edit

        int SetMaterial(<a class="code" href="class_point.html">Point</a> &amp;Ambient, <a class="code" href="class_point.html">Point</a> &amp;Diffuse, <a class="code" href="class_point.html">Point</a> &amp;Specular,<a class="code" href="class_point.html">Point</a> &amp;Emission,float &amp;Shininess,float &amp;Alpha);
        int GetMaterial(<a class="code" href="class_point.html">Point</a> &amp;Ambient, <a class="code" href="class_point.html">Point</a> &amp;Diffuse, <a class="code" href="class_point.html">Point</a> &amp;Specular,<a class="code" href="class_point.html">Point</a> &amp;Emission,float &amp;Shininess,float &amp;Alpha);
        int SetBackMaterial(<a class="code" href="class_point.html">Point</a> &amp;Ambient, <a class="code" href="class_point.html">Point</a> &amp;Diffuse, <a class="code" href="class_point.html">Point</a> &amp;Specular,<a class="code" href="class_point.html">Point</a> &amp;Emission,float &amp;Shininess,float &amp;Alpha);
        int GetBackMaterial(<a class="code" href="class_point.html">Point</a> &amp;Ambient, <a class="code" href="class_point.html">Point</a> &amp;Diffuse, <a class="code" href="class_point.html">Point</a> &amp;Specular,<a class="code" href="class_point.html">Point</a> &amp;Emission,float &amp;Shininess,float &amp;Alpha);

        CString material;
        const char *GetMaterial() { return(material); }

        int ReadMaterial(const char * filename, int format);
        int ReadMaterial(int fmt,const char *FileName);

        // Background color
        int GetBackgroundColor(<a class="code" href="class_point.html">Point</a> &amp;c);
        int SetBackgroundColor(const <a class="code" href="class_point.html">Point</a> &amp;c);
        int EditBackgroundColor(const <a class="code" href="class_point.html">Point</a> &amp;c);

        // Ambient Light color / intensity 
        int GetAmbientLight(CString &amp;c);
        int SetAmbientLight(const char *c);


        // used to render to a bitmap context

        int SetContext(int canDisplayShareLists=0);


        int BeginIncrementalUpdates();

        void GetProfileSettings();


        // &lt;0 initialization failed, exit app
        int Initialize(HWND hWnd,HDC hDC,
                        <a class="code" href="class_gdriverhints.html">GDriverHints</a> *driverHints = NULL
#ifdef _D3D_XXX
                         ,const char *driver= NULL,     // preferenced Driver, default "Ramp Driver"
                         BOOL  bOnlySystemMemory = FALSE,
                         BOOL  bOnlyEmulation = FALSE
#endif
                );
        
        void Term();




#ifdef _D3D

        <a class="code" href="class_g3lightref.html">G3LightRef</a> headLight; // headLight

#endif

        gbool lightInit; // need initializations of lights 



        int DefineLights(const <a class="code" href="class_point.html">Point</a> &amp;dirx,int headLight, int &amp;firstLightIndex);

        DWORD frameCnt;           // FRAME CNT  

        DWORD lastFrameTime; // in milli secons 

#define NUM_LAST_FRAME_TIMES 8

        int lastFrameTimes[NUM_LAST_FRAME_TIMES];
        int lastFrameTris[NUM_LAST_FRAME_TIMES];
        int lastFramePrims[NUM_LAST_FRAME_TIMES];
        
        int lastFrameTimesI;

        int lastFrameTimesSum; 


        // Auto LOD 
        <a class="code" href="class_gframestats.html">GFrameStats</a> lastFrameStats;             
        <a class="code" href="class_gframestats.html">GFrameStats</a> frameStats;                 
        float nurbsTessellationScale;   


        float targetFrameRate;                  
        float targetFrameRateDegrade;   
        int nurbsTessellationMode;              
        gbool autoTesselation;

        void UpdateNurbsTesselation();

        float lodScale;                                 

        void SetLodScale(float factor);


        void DrawScene(RECT &amp;rc);

        void Resize(int width,int height);

        void Resize(HWND hWnd);

        void Resize(RECT &amp;rect);

        <a class="code" href="class_gvsffloat.html">GvSFFloat</a> windowAspect; 
        <a class="code" href="class_gvsfvec2f.html">GvSFVec2f</a> windowSize;   
        <a class="code" href="class_gvsfnode.html">GvSFNode</a>  event;                
        <a class="code" href="class_gvsfint32.html">GvSFInt32</a> eventMask;    


        // get window properties
        int getWindowSizeX();
        int getWindowSizeY();

        float getWindowAspect();

        // get pressed status of VIRTUAL key code
        // TBD: where are UNICODE keycode defines ??
        gbool isKeyPressed(int key);

        // the mask of needed input events, avoid e.g. mousemoves
        // GBrowserInputEventFlags eventMask; // for now as SFInt32
        // list of observers / outgoing routes

        
        // parse an given filter string and compute an event mask
        static int parseEventMask(const char *filter);
        static const <a class="code" href="class_is.html">IS</a> GEV_table[];



        <a class="code" href="class_gvevent.html">GvEvent</a>* getEvent() const { return (<a class="code" href="class_gvevent.html">GvEvent</a>*) event.<a class="code" href="class_gvsfnode.html#a4">get</a>(); };
        void  triggerEvent() { event.<a class="code" href="class_gvfield.html#a32">touch</a>(); }; // trigger ROUTES
        gbool triggerEvent(const char *type); //

        gbool triggerMouseEvent(GBrowserInputEventFlags mask, const char *type, float x,float y, unsigned int flags);
        
        gbool triggerMouseEvent(GBrowserInputEventFlags mask,const char *type,POINT client, POINT screen, unsigned int flags);
        
        gbool triggerKeyboardEvent(GBrowserInputEventFlags mask,const char *type,unsigned int code, unsigned int flags);
        gbool triggerSizeEvent(GBrowserInputEventFlags mask,const char *type,float x,float y, unsigned int flags);


        // callbacks with MFC Cwindow signature
        void OnSize(UINT nType, int cx, int cy);

        void OnMove(int cx, int cy);

        void OnActivate();



        <a class="code" href="class_gdeform.html">GDeform</a> * deformer;

        <a class="code" href="class_gparameter.html">GParameter</a> *<a class="code" href="class_parameter.html">parameter</a>;

        int BuildShell();

        // Compute a shell for the world
        <a class="code" href="class_gshell.html">GShell</a>* ComputeShell();


        // do background node rendering
        gbool doBackground;
        // node (LayerNode) for background rendering 
        <a class="code" href="class_gvnodehandle.html">GvNodeHandle</a> background;

        // Rotation Node for applying cameraOrientation for VRML 2.0 Background
        <a class="code" href="class_gvnodehandle.html">GvNodeHandle</a> backgroundRotation;

        // do foreground / overlay node rendering
        gbool doForeground;
        
        // node (LayerNode) for foreground rendering 
        <a class="code" href="class_gvmfnode.html">GvMFNode</a> foreground;


        int SetBackground(<a class="code" href="class_gvnode.html">GvNode</a> *node=NULL);

        int SetBackground(<a class="code" href="class_gvrotation.html">GvRotation</a> *rotation,<a class="code" href="class_gvnode.html">GvNode</a> *node);

        //int SetForeground(GvNode *node=NULL);
        
        void addForeground(<a class="code" href="class_gvnode.html">GvNode</a> *node);
        void removeForeground(<a class="code" href="class_gvnode.html">GvNode</a> *node);
        void ClearForeground();


        // clear any background
        void ClearBackground();

        CString backgroundImage;    // name of current background image 
        const char *GetBackgroundImage() { return(backgroundImage); }

        // Set background by creating a layer node
        int SetBackgroundImage(const char *FileName,int format = UNKNOWN_FMT);

        // Edit background + edit scene BackgroundImage node
        int EditBackgroundImage(const char *FileName,int format = UNKNOWN_FMT);

        int RenderBackground();


        // set viewer (Navigation) mode 
        int SetViewerMode(const char *mode);


        // action on do do on select processing
        enum SelectionAction {
                INFO,                   // Display info about object

                INFO_WWWAnchor, // display WWW Anchor information // move
                JUMP_WWWAnchor, // execute www anchor (double click)                    

                DRAG_SENSORS,   // execute www anchor / handle sensors  // mouse down           

                JUMP_OBJECT,    // jump to object                       
                FOLLOW_OBJECT,  // follow object                        
                SELECT,                 // select current object 
                DRAG,                   // drag current object 
                RELEASE,                // drag current object 
        };

        // do selection processing
        int Select(int x, int y, int flags, int action);

        // execute a hit element
        // x,y,flags are the orignial data from the mouse event
        // msg is the message to be displayed
        // sensors contains the list of sensor eventhandlers to be activated
        int DoHitElement(SelectionAction action, int x, int y, int flags, <a class="code" href="class_ghitinfo.html">GHitInfo</a> &amp;hit,<a class="code" href="class_gvnode.html">GvNode</a> *hitNode,CString &amp;msg,<a class="code" href="class_gmultitsensorhandler.html">GMultitSensorHandler</a>* &amp; sensors);

        // detect a Ray-based collision
        // result 1: collisionPosition contains new position 
        int CollisionDetect(const <a class="code" href="class_point.html">Point</a> &amp;oldPosition, const <a class="code" href="class_point.html">Point</a> &amp;newPosition,  <a class="code" href="class_point.html">Point</a> &amp;collisionPosition,<a class="code" href="class_point.html">Point</a> &amp;collisionNormal);

        // result 1: newPosition contains new position 2:gravity, falling down
        int GroundDetect(const <a class="code" href="class_point.html">Point</a> &amp;oldPosition,  <a class="code" href="class_point.html">Point</a> &amp;newPosition,<a class="code" href="class_point.html">Point</a> &amp;hitPosition,<a class="code" href="class_point.html">Point</a> &amp;hitNormal); 

        // execute the url 
        int ExecuteUrl(const char *url);
        int ExecuteUrl(<a class="code" href="class_gvsfstring.html">GvSFString</a> &amp;url);
        int ExecuteUrl(<a class="code" href="class_gvmfstring.html">GvMFString</a> &amp;url);



        // the current traversal in progress
        <a class="code" href="class_gtraversal.html">GTraversal</a> *currentTraversal;

        // last hit information stored by Select
        <a class="code" href="class_ghitinfo.html">GHitInfo</a> *lastHit;

        // the current set of touchsensors with isOver == TRUE 
        <a class="code" href="class_gvmfnode.html">GvMFNode</a> overTouchSensors;

        // the current set of touchsensors with isActive == TRUE 
        <a class="code" href="class_gvmfnode.html">GvMFNode</a> activeTouchSensors;

        // the matrix of the over touchSensors
        <a class="code" href="class_matrixandinverse.html">MatrixAndInverse</a> overTouchSensorsMatrix;

        gbool hasCustomSensorMessage; // setDescription message is sent from VRML via JavaScript

        // node to be executed from Anchor
        <a class="code" href="class_gnode.html">GNode</a> *executeNode;

        // the current set of visibility sensors with isActive == TRUE 
        <a class="code" href="class_gvmfnode.html">GvMFNode</a> activeVisibilitySensors;

        // the current set of active zones with isActive == TRUE 
        // e.g. Occlusion
        <a class="code" href="class_gvmfnode.html">GvMFNode</a> activeZones;

        // inactive visibility sensors, not visible any more 
        void InActivateVisibilitySensors();

        // inactive zone  not visible any more 
        void InActivateZones();



        int needUpdate;         // flag scene need refresh, scanned in CMYglView::OnIdle()


        int abortAllLoads;      // ignore any following inlines / texture load requests

        // set moving mode 
        gbool moving;                   // avatar  is moving
        int SetMoving(gbool mode); 
        gbool Moving() const  { return(moving); }

        // set colliding mode 
        gbool colliding;                        // avatar is colliding
        int SetColliding(gbool mode); 
        gbool Colliding() const  { return(colliding); }

        // set flying mode 
        gbool flying;                   // avatar is flying
        int SetFlying(gbool mode); 
        gbool Flying() const  { return(flying); }

        float startRenderTime;  // time rendering has started

        // Degrading 
        int degradeDuringMove;
        int autoDegrade;        // automatically try to degrade
        int degrade;    // flag, sceen should be rendered degraded
        int degraded;   // current display is rendered degraded

        float degradeLastFrameTime;

        float degradeMaxFrameTime;

        // rendering mode flags for degraded mode 
        GRenderMode degradeRenderMode;
        gbool degradeTextured;
        gbool degradeTransparency;
        gbool degradeLightMode;


        void SetDegradeDefaults();

        // start degrading on next update
        int BeginDegrade();

        // end degrading 
        int EndDegrade();

        // saved rendering mode flags for degraded mode 
        GRenderMode degradeSaveRenderMode;
        gbool degradeSaveRenderTextured;
        gbool degradeSaveRenderTransparency;
        gbool degradeSaveRenderLightMode;

        // extended customized OGL rendering mode
        <a class="code" href="class_renderflags.html">RenderFlags</a> degradeSaveVertices;
        <a class="code" href="class_renderflags.html">RenderFlags</a> degradeSaveNormals;
        <a class="code" href="class_renderflags.html">RenderFlags</a> degradeSaveEdges;
        <a class="code" href="class_renderflags.html">RenderFlags</a> degradeSaveFaces;
        <a class="code" href="class_renderflags.html">RenderFlags</a> degradeSaveBboxes;

        // set rendering state to degraded rendering mode
        void SetDegradeMode();

        // restore rendering state to state before degraded rendering mode
        void UnSetDegradeMode();


        <a class="code" href="class_gloadtask.html">GLoadTask</a> *tasks;

        int AddTask(<a class="code" href="class_gloadtask.html">GLoadTask</a> *newTask,int where=0);
        void ClearTasks();
        int CheckTasks();

        // update scene info
        int UpdateSceneInfo(gbool fullInfo=FALSE);

        // update scene info incrementally 
        int UpdateSceneInfo(<a class="code" href="class_gvnode.html">GvNode</a> *node); 


        // Traverse current scene
        // update pointer to camera and defaults nodes in traversal
        int <a class="code" href="class_gvnode.html#a41">Traverse</a>(<a class="code" href="class_gtraversal.html">GTraversal</a> &amp;traversal); 

        // Traverse a specific node 
        int <a class="code" href="class_gvnode.html#a41">Traverse</a>(<a class="code" href="class_gtraversal.html">GTraversal</a> &amp;traversal,<a class="code" href="class_gvnode.html">GvNode</a> *theNode); 


        // Traverse world without the avatar 
        int TraverseWithoutAvatar(<a class="code" href="class_gtraversal.html">GTraversal</a> &amp;traversal); 


        // default nodes
        <a class="code" href="class_gvsfnode.html">GvSFNode</a> defaultAppearance; // appearance if appearance field is NULL
        <a class="code" href="class_gvsfnode.html">GvSFNode</a> defaultMaterial; // material if apperance material is NULL     (part of defaultAppearance)
        <a class="code" href="class_gvsfnode.html">GvSFNode</a> defaultTextureTransform; // textureTransform if apperance textureTransform is NULL     (part of defaultAppearance)
        <a class="code" href="class_gvsfnode.html">GvSFNode</a> defaultTexture; // texture if apperance textureTransform is NULL       (part of defaultAppearance)

        <a class="code" href="class_gvsfnode.html">GvSFNode</a> defaultMaterial10; // default material for VRML 1.0 style 

        // create above default nodes
        void InitDefaultNodes();

        // update values from current state
        void UpdateDefaultNodes();


        void ResetDefaults();

        // notification  functions
        // a node has been added to scene
        void OnNodeAdded(<a class="code" href="class_gvnode.html">GvNode</a> *node);
        
        // node will be deleted to scene
        void OnNodeDeleted(<a class="code" href="class_gvnode.html">GvNode</a> *node);

        // node has been changed
        void OnNodeChanged(<a class="code" href="class_gvnode.html">GvNode</a> *node);


#ifdef _GV
// browser fields


// browser methods 
        <a class="code" href="class_gvsfstring.html">GvSFString</a> name;
        <a class="code" href="class_gvsfstring.html">GvSFString</a> version;
        <a class="code" href="class_gvsfstring.html">GvSFString</a> worldUrl;

        // Event Outs in global coordinates 
        <a class="code" href="class_gvsfvec3f.html">GvSFVec3f</a> viewpointPosition;
        <a class="code" href="class_gvsfrotation.html">GvSFRotation</a> viewpointOrientation;

        //
        // script browser  methods 
        //

    const char * <a class="code" href="class_gvnode.html#a5">getName</a>(); 

    const char * getVersion(); 

    float getCurrentSpeed(); 

    float getCurrentFrameRate(); 

    const char *getWorldURL(); 

        void replaceWorld(<a class="code" href="class_gvmfnode.html">GvMFNode</a> *nodes); 

    <a class="code" href="class_gvmfnode.html">GvMFNode</a>* createVrmlFromString(const char* vrmlSyntax,<a class="code" href="class_gvscript.html">GvScript</a> *scriptNode); 

    void createVrmlFromURL(<a class="code" href="class_gvmfstring.html">GvMFString</a> *url, <a class="code" href="class_gvnode.html">GvNode</a> *node, const char *event,<a class="code" href="class_gvscript.html">GvScript</a> *scriptNode); 

    void <a class="code" href="class_gvnode.html#d17">addRoute</a>(<a class="code" href="class_gvnode.html">GvNode</a> *fromNode, const char *fromEventOut, <a class="code" href="class_gvnode.html">GvNode</a> *toNode, const char *toEventIn); 

    void <a class="code" href="class_gvnode.html#d18">deleteRoute</a>(<a class="code" href="class_gvnode.html">GvNode</a> *fromNode, const char *fromEventOut, <a class="code" href="class_gvnode.html">GvNode</a> *toNode, const char *toEventIn); 

    void loadURL(<a class="code" href="class_gvmfstring.html">GvMFString</a> *url, <a class="code" href="class_gvmfstring.html">GvMFString</a> *<a class="code" href="class_parameter.html">parameter</a>,<a class="code" href="class_gvscript.html">GvScript</a> *scriptNode); 

    void setDescription(const char *description); 

    void notifyWhenLoaded(<a class="code" href="class_gvmfnode.html">GvMFNode</a> *nodesToLoad, <a class="code" href="class_gvnode.html">GvNode</a> *nodeToNotify, const char *eventInToNotify); 

        // set the viewpoint depending on mode
        int setViewpointByValue(<a class="code" href="class_point.html">Point</a> position,<a class="code" href="class_rotation.html">Rotation</a> orientation,int mode);
        int getViewpointByValue(<a class="code" href="class_point.html">Point</a> &amp;position,<a class="code" href="class_rotation.html">Rotation</a> &amp;orientation,int mode);

        //
        //
        //


        // some child node has been changed
        int <a class="code" href="class_gvnode.html#a70">OnChildChanged</a>(<a class="code" href="class_gvnode.html">GvNode</a> *child);

        // library managment

        <a class="code" href="class_gvsfnode.html">GvSFNode</a>                library; // a GvScene node
        GvBool                  libraryLoaded; // library loaded ?

        // load global library scene 
        GvBool LoadLibrary(const char *fileName);

        // get global library scene / load if not loaded 

        <a class="code" href="class_gvscene.html">GvScene</a> *GetLibrary();
        <a class="code" href="class_gvmfnode.html">GvMFNode</a> *GetLibraryObjects();
        <a class="code" href="class_gvmfnode.html">GvMFNode</a> *GetLibraryMaterials();
        <a class="code" href="class_gvmfnode.html">GvMFNode</a> *GetLibraryAppearances();

#endif




};

#endif


</div></pre><hr><address><small>Generated at Thu Jan 27 18:47:15 2000 for blaxxunContact3D by
<a href="http://www.stack.nl/~dimitri/doxygen/index.html">
<img src="doxygen.gif" alt="doxygen" align=center border=0 
width=118 height=53></a> 1.0.0 written by <a href="mailto:dimitri@stack.nl">Dimitri van Heesch</a>,
 &copy; 1997-1999</small></address>
</body>
</html>

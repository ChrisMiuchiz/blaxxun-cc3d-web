<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta name="robots" content="noindex">
<title>VsValue Include File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body bgcolor="#ffffff">
<!-- Generated by Doxygen 1.0.0 on Thu Jan 27 18:54:10 2000 -->
<center>
<a class="qindex"href="index.html">Main Page</a> &nbsp; <a class="qindex"href="namespaces.html">Namespace List</a> &nbsp; <a class="qindex"href="hierarchy.html">Class Hierarchy</a> &nbsp; <a class="qindex"href="annotated.html">Compound List</a> &nbsp; <a class="qindex"href="files.html">File List</a> &nbsp; <a class="qindex"href="headers.html">Header Files</a> &nbsp; <a class="qindex"href="namespacemembers.html">Namespace Members</a> &nbsp; <a class="qindex"href="functions.html">Compound Members</a> &nbsp; <a class="qindex"href="globals.html">File Members</a> &nbsp; </center>
<hr><h1>vsstatement.h</h1>This is the verbatim text of the vsstatement.h include file.<div class="fragment"><pre>/*
 * VsStatement.h
 *
 *      Declaration of classes:
 *        VsValue
 *        VsStatement
 *        VsReturn
 *        VsIf
 *        VsFor
 *        VsStatementList
 *
 * Statement support.  Functions are lists of statements that get
 * executed.
 * 
 * Copyright (C) 1996, Silicon Graphics,  Inc.
 */

#ifndef _VS_STATEMENT_
#define _VS_STATEMENT_

#include &lt;gvbasic.h&gt;

#ifdef __sgi
#include &lt;Inventor/SbPList.h&gt;
#include &lt;Inventor/SbString.h&gt;
#else
#include "vbplist.h"
#endif

class <a class="code" href="class_vsstatementlist.html">VsStatementList</a>;
class <a class="code" href="class_vsfunctioncall.html">VsFunctionCall</a>;
class <a class="code" href="class_vsexpr.html">VsExpr</a>;
class <a class="code" href="class_vsvar.html">VsVar</a>;

class <a class="code" href="class_gvstring.html">GvString</a>;
class <a class="code" href="class_gvnode.html">GvNode</a>;
class <a class="code" href="class_gvfield.html">GvField</a>;

class <a class="code" href="class_vsfield.html">VsField</a>;


//
// VsValues are passed around and represent values of various types.
// Since JavaScript is pretty much untyped, having one value class
// makes things a lot cleaner.  KEEP THIS STRUCTURE AS SMALL AS
// POSSIBLE!  VsValues tend to be passed around by value, so should be kept
// as lightweight as possible.
//

struct <a class="code" href="class_vsfloatarray.html">VsFloatArray</a> {
    float *array;
    int32_t length;
};

struct <a class="code" href="class_vsint32array.html">VsInt32Array</a> {
    int32_t *array;
    int32_t length;
};

struct <a class="code" href="class_vsvoidarray.html">VsVoidArray</a> {
    void **array;
    int32_t length;
};

struct <a class="code" href="class_vsstringarray.html">VsStringArray</a> {
    <a class="code" href="class_gvstring.html">GvString</a> *array;
    int32_t length;
};

class <a class="code" href="class_vsvalue.html">VsValue</a> {

public:

    <a class="code" href="class_vsvalue.html#a11">VsValue</a>(double num) 
        {
            type = vNUMBER;
                number = num;
        }

    <a class="code" href="class_vsvalue.html#a11">VsValue</a>(float num) 
        {
            type = vNUMBER;
                number = num;
        }
 

    <a class="code" href="class_vsvalue.html#a11">VsValue</a>(int num) 
        {
            type = vNUMBER;
                number = num;
        }

    <a class="code" href="class_vsvalue.html#a11">VsValue</a>(long num) 
        {
            type = vNUMBER;
                number = num;
        }

    <a class="code" href="class_vsvalue.html#a11">VsValue</a>(unsigned long num) 
        {
            type = vNUMBER;
                number = num;
        }

        // warning pointers are references only, no value is copied
    <a class="code" href="class_vsvalue.html#a11">VsValue</a>(void *ptr)
        {
                type = vVOID;
                data = ptr;
        }

    <a class="code" href="class_vsvalue.html#a11">VsValue</a>(char *str)
        {
                type = vSTRING;
                string = str;
        }

    <a class="code" href="class_vsvalue.html#a11">VsValue</a>(const char *str)
        {
                type = vSTRING;
                string = (char *) str;
        }

    <a class="code" href="class_vsvalue.html#a11">VsValue</a>(<a class="code" href="class_gvnode.html">GvNode</a> * node);


        <a class="code" href="class_vsvalue.html#a11">VsValue</a>(const <a class="code" href="class_vsvalue.html">VsValue</a> &amp;b);

        <a class="code" href="class_vsvalue.html#a11">VsValue</a>(<a class="code" href="class_vsfield.html">VsField</a>  *f);


    <a class="code" href="class_vsvalue.html#a11">VsValue</a>() { data = NULL; type = vVOID; };

        <a class="code" href="class_vsvalue.html#a12">~VsValue</a>();

        inline void <a class="code" href="class_vsvalue.html#a13">construct</a>() {       type = vVOID; } 

        // destruct value, unref pointers 
        void <a class="code" href="class_vsvalue.html#a14">destruct</a>();

        <a class="code" href="class_vsvalue.html">VsValue</a> &amp;operator=(const <a class="code" href="class_vsvalue.html">VsValue</a> &amp;b);


    GvBool              <a class="code" href="class_vsvalue.html#a16">getBool</a>() const;  // Returns value as boolean (0 or 1)
    GvBool              <a class="code" href="class_vsvalue.html#a17">getString</a>(<a class="code" href="class_gvstring.html">GvString</a> &amp;s) const;  // Returns value as string  (0 or 1)
        
        inline GvBool           <a class="code" href="class_vsvalue.html#a18">get</a>(int &amp;value) 
        {
                switch (type) {
                        case vNUMBER: value = (int) number; return(TRUE); // may be overflow
                        default: break;
                }
                return FALSE;
        }

        inline GvBool           <a class="code" href="class_vsvalue.html#a18">get</a>(double &amp;value) 
        {
                switch (type) {
                        case vNUMBER: value = number; return(TRUE);
                        default: break;
                }
                return FALSE;
        }
        
        inline GvBool           <a class="code" href="class_vsvalue.html#a18">get</a>(float &amp;value) 
        {
                switch (type) {
                        case vNUMBER: value  = (float) number; return(TRUE); // may be overflow
                        default: break;
                }
                return FALSE;
        }

        // get a string 
        const char *<a class="code" href="class_vsvalue.html#a17">getString</a>() const;

    <a class="code" href="class_gvnode.html">GvNode</a>*     <a class="code" href="class_vsvalue.html#a22">getNode</a>() const;  // Returns value as node 


    union {
                double number;
                char  *string;
                void  *data;
                <a class="code" href="class_vsfloatarray.html">VsFloatArray</a> *floatArray;
                <a class="code" href="class_vsint32array.html">VsInt32Array</a> *int32Array;
                <a class="code" href="class_vsvoidarray.html">VsVoidArray</a>  *voidArray;
                <a class="code" href="class_vsstringarray.html">VsStringArray</a> *stringArray;

                <a class="code" href="class_gvstring.html">GvString</a> *gvString;
                <a class="code" href="class_gvnode.html">GvNode</a>   *node;

                <a class="code" href="class_vsfield.html">VsField</a>  *field;

    };

    enum Type {
                vUNKNOWN, vVOID,
                vNUMBER, vSTRING,
                vOBJECT, vFUNCTION, 

/* obsolete, done via vFIELD 
                vFLOAT_ARRAY,
                vINT32_ARRAY,
                vSTRING_ARRAY,
                vVOID_ARRAY,
                vROTATION,
*/

                vGVSTRING,              // string alloacted 
                vNODE,                  // VRML node 
                vFIELD                  // VRML field
                
    };
        
        inline gbool <a class="code" href="class_vsvalue.html#a23">isString</a>() const { return type == vSTRING || type == vGVSTRING; }

    unsigned char type; // One of the above ENUM values

    static const <a class="code" href="class_vsvalue.html">VsValue</a> nothing;
        static const <a class="code" href="class_vsvalue.html">VsValue</a> zero;
};    

//
// Statement base class:
//
class <a class="code" href="class_vsstatement.html">VsStatement</a> {
  public:
    // These status codes are returned from statements to tell the
    // enclosing controls structure (loop, if-test, function) what to
    // do:
    enum Status {
                NORMAL,   // Normal return, continue executing statements
                BREAK,    // Break out of enclosing loop/if
                CONTINUE, // Continue enclosing loop/if
                RETURN,   // Return from enclosing function
    };

    <a class="code" href="class_vsstatement.html#a0">VsStatement</a>();
    virtual <a class="code" href="class_vsstatement.html#a1">~VsStatement</a>();

    // Statement subclasses should override this to do whatever they
    // do and return a Status code.  References to function arguments
    // (which are buried down inside expressions) need to know what
    // function they're executing inside of, which is why a
    // VsFunctionCall is passed in to this routine:
    virtual Status      <a class="code" href="class_vsstatement.html#a2">execute</a>(<a class="code" href="class_vsfunctioncall.html">VsFunctionCall</a> *) = 0;
};

//
// Return statement.
//
class <a class="code" href="class_vsreturn.html">VsReturn</a> : public <a class="code" href="class_vsstatement.html">VsStatement</a> {
  public:
    <a class="code" href="class_vsreturn.html#a0">VsReturn</a>(<a class="code" href="class_vsexpr.html">VsExpr</a> *expr);
    virtual <a class="code" href="class_vsreturn.html#a1">~VsReturn</a>();

    // Standard execute.  Evalutes expression (if any given), returns
    // a status of RETURN.
    virtual VsStatement::Status <a class="code" href="class_vsstatement.html#a2">execute</a>(<a class="code" href="class_vsfunctioncall.html">VsFunctionCall</a> *);

  private:
    <a class="code" href="class_vsexpr.html">VsExpr</a> *expression;
};

//
// If statement.
//
class <a class="code" href="class_vsif.html">VsIf</a> : public <a class="code" href="class_vsstatement.html">VsStatement</a> {
  public:
    // Pass in expression for condition, if statements, and else
    // statements (NULL if just a "bare" if).
    <a class="code" href="class_vsif.html#a0">VsIf</a>(<a class="code" href="class_vsexpr.html">VsExpr</a> *condition, <a class="code" href="class_vsstatementlist.html">VsStatementList</a> *ifStatements,
         <a class="code" href="class_vsstatementlist.html">VsStatementList</a> *elseStatements);
    virtual <a class="code" href="class_vsif.html#a1">~VsIf</a>();

    // Evaluates.  Depending on condition expression, either if or
    // else statements are executed.
    virtual VsStatement::Status <a class="code" href="class_vsstatement.html#a2">execute</a>(<a class="code" href="class_vsfunctioncall.html">VsFunctionCall</a> *);

  private:
    <a class="code" href="class_vsexpr.html">VsExpr</a> *condition;
    <a class="code" href="class_vsstatementlist.html">VsStatementList</a> *ifStatements, *elseStatements;
};

//
// For statement.
//
class <a class="code" href="class_vsfor.html">VsFor</a> : public <a class="code" href="class_vsstatement.html">VsStatement</a> {
  public:
    <a class="code" href="class_vsfor.html#a0">VsFor</a>(<a class="code" href="class_vsexpr.html">VsExpr</a> *initial, <a class="code" href="class_vsexpr.html">VsExpr</a> *condition, <a class="code" href="class_vsexpr.html">VsExpr</a> *increment, 
          <a class="code" href="class_vsstatementlist.html">VsStatementList</a> *body);
    virtual <a class="code" href="class_vsfor.html#a1">~VsFor</a>();

    // Execute statements repeatedly until terminate expression is
    // true.
    virtual VsStatement::Status <a class="code" href="class_vsstatement.html#a2">execute</a>(<a class="code" href="class_vsfunctioncall.html">VsFunctionCall</a> *);

  private:
    <a class="code" href="class_vsexpr.html">VsExpr</a> *initial, *increment, *condition;
    <a class="code" href="class_vsstatementlist.html">VsStatementList</a> *body;
};

//
// For..In statement.
//
class <a class="code" href="class_vsforin.html">VsForIn</a> : public <a class="code" href="class_vsstatement.html">VsStatement</a> {
  public:
    <a class="code" href="class_vsforin.html#a0">VsForIn</a>(<a class="code" href="class_vsvar.html">VsVar</a> *variable, <a class="code" href="class_vsexpr.html">VsExpr</a> *object, <a class="code" href="class_vsstatementlist.html">VsStatementList</a> *body);
    virtual <a class="code" href="class_vsforin.html#a1">~VsForIn</a>();

    virtual VsStatement::Status <a class="code" href="class_vsstatement.html#a2">execute</a>(<a class="code" href="class_vsfunctioncall.html">VsFunctionCall</a> *);
    
  private:
    <a class="code" href="class_vsvar.html">VsVar</a>  *variable;
    <a class="code" href="class_vsexpr.html">VsExpr</a> *object;
    <a class="code" href="class_vsstatementlist.html">VsStatementList</a> *body;
};

//
// While statement.
//
class <a class="code" href="class_vswhile.html">VsWhile</a> : public <a class="code" href="class_vsstatement.html">VsStatement</a> {
  public:
    <a class="code" href="class_vswhile.html#a0">VsWhile</a>(<a class="code" href="class_vsexpr.html">VsExpr</a> *condition, <a class="code" href="class_vsstatementlist.html">VsStatementList</a> *body);
    virtual <a class="code" href="class_vswhile.html#a1">~VsWhile</a>();

    // Execute statements repeatedly until terminate expression is
    // true.
    virtual VsStatement::Status <a class="code" href="class_vsstatement.html#a2">execute</a>(<a class="code" href="class_vsfunctioncall.html">VsFunctionCall</a> *);

  private:
    <a class="code" href="class_vsexpr.html">VsExpr</a> *condition;
    <a class="code" href="class_vsstatementlist.html">VsStatementList</a> *body;
};

//
// Break statement.
//
class <a class="code" href="class_vsbreak.html">VsBreak</a> : public <a class="code" href="class_vsstatement.html">VsStatement</a> {
  public:
    <a class="code" href="class_vsbreak.html#a0">VsBreak</a>();

    virtual <a class="code" href="class_vsbreak.html#a1">~VsBreak</a>();

    // Execute statements repeatedly until terminate expression is
    // true.
    virtual VsStatement::Status <a class="code" href="class_vsstatement.html#a2">execute</a>(<a class="code" href="class_vsfunctioncall.html">VsFunctionCall</a> *);

};

//
// Continue statement.
//
class <a class="code" href="class_vscontinue.html">VsContinue</a> : public <a class="code" href="class_vsstatement.html">VsStatement</a> {
  public:
    <a class="code" href="class_vscontinue.html#a0">VsContinue</a>();
    virtual <a class="code" href="class_vscontinue.html#a1">~VsContinue</a>();

    // Execute statements repeatedly until terminate expression is
    // true.
    virtual VsStatement::Status <a class="code" href="class_vsstatement.html#a2">execute</a>(<a class="code" href="class_vsfunctioncall.html">VsFunctionCall</a> *);

};

//
// With statement.
//
class <a class="code" href="class_vswith.html">VsWith</a> : public <a class="code" href="class_vsstatement.html">VsStatement</a> {
  public:
    <a class="code" href="class_vswith.html#a0">VsWith</a>(<a class="code" href="class_vsexpr.html">VsExpr</a> *object, <a class="code" href="class_vsstatementlist.html">VsStatementList</a> *body );

    virtual <a class="code" href="class_vswith.html#a1">~VsWith</a>();

    // Execute statements repeatedly until terminate expression is
    // true.
    virtual VsStatement::Status <a class="code" href="class_vsstatement.html#a2">execute</a>(<a class="code" href="class_vsfunctioncall.html">VsFunctionCall</a> *);

    private:
        <a class="code" href="class_vsexpr.html">VsExpr</a>* object;
        
        <a class="code" href="class_vsstatementlist.html">VsStatementList</a>* body;
};

//
// Little wrapper class for VbPList that bundles up some annoying casting:
//
class <a class="code" href="class_vsstatementlist.html">VsStatementList</a> : public <a class="code" href="class_vbplist.html">VbPList</a> {
  public:
    <a class="code" href="class_vsstatementlist.html#a0">VsStatementList</a>()                                 {}
    <a class="code" href="class_vsstatementlist.html#a0">VsStatementList</a>(int initSize) : <a class="code" href="class_vbplist.html">VbPList</a>(initSize) {}
    <a class="code" href="class_vsstatementlist.html#a2">~VsStatementList</a>(); // Destructor deletes all statements

    // Useful routine, executes all while return status is NORMAL:
    VsStatement::Status <a class="code" href="class_vsstatement.html#a2">execute</a>(<a class="code" href="class_vsfunctioncall.html">VsFunctionCall</a> *);

    void    <a class="code" href="class_vbplist.html#a4">append</a>(<a class="code" href="class_vsstatement.html">VsStatement</a> *statement)
                { if (statement != NULL) { this-&gt;VbPList::append((void *)statement); }}
    int     <a class="code" href="class_vbplist.html#a5">find</a>(<a class="code" href="class_vsstatement.html">VsStatement</a> *statement)
                { return this-&gt;VbPList::find((void *)statement); }
    void    <a class="code" href="class_vbplist.html#a6">insert</a>(<a class="code" href="class_vsstatement.html">VsStatement</a> *statement, int addBefore)
                { if (statement != NULL) {this-&gt;VbPList::insert((void *)statement, addBefore); }}
    <a class="code" href="class_vsstatement.html">VsStatement</a>* &amp;operator [](int i) const
                { return (<a class="code" href="class_vsstatement.html">VsStatement</a> * &amp;)(this-&gt;VbPList::operator[](i)); }
};


//
// VAR statement.
//
class <a class="code" href="class_vsvarstatement.html">VsVarStatement</a> : public <a class="code" href="class_vsstatement.html">VsStatement</a> {
  public:
    <a class="code" href="class_vsvarstatement.html#a0">VsVarStatement</a>(<a class="code" href="class_vsstatementlist.html">VsStatementList</a> *body);
    virtual <a class="code" href="class_vsvarstatement.html#a1">~VsVarStatement</a>();

    // Execute statements repeatedly until terminate expression is
    // true.
    virtual VsStatement::Status <a class="code" href="class_vsstatement.html#a2">execute</a>(<a class="code" href="class_vsfunctioncall.html">VsFunctionCall</a> *);

  private:
    <a class="code" href="class_vsstatementlist.html">VsStatementList</a> *body;
};

#endif /* _VS_STATEMENT_ */
</div></pre><hr><address><small>Generated at Thu Jan 27 18:54:10 2000 for blaxxunContact3D by
<a href="http://www.stack.nl/~dimitri/doxygen/index.html">
<img src="doxygen.gif" alt="doxygen" align=center border=0 
width=118 height=53></a> 1.0.0 written by <a href="mailto:dimitri@stack.nl">Dimitri van Heesch</a>,
 &copy; 1997-1999</small></address>
</body>
</html>

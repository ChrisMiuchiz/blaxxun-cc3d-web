<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta name="robots" content="noindex">
<title>Point4 Include File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body bgcolor="#ffffff">
<!-- Generated by Doxygen 1.0.0 on Thu Jan 27 18:51:11 2000 -->
<center>
<a class="qindex"href="index.html">Main Page</a> &nbsp; <a class="qindex"href="namespaces.html">Namespace List</a> &nbsp; <a class="qindex"href="hierarchy.html">Class Hierarchy</a> &nbsp; <a class="qindex"href="annotated.html">Compound List</a> &nbsp; <a class="qindex"href="files.html">File List</a> &nbsp; <a class="qindex"href="headers.html">Header Files</a> &nbsp; <a class="qindex"href="namespacemembers.html">Namespace Members</a> &nbsp; <a class="qindex"href="functions.html">Compound Members</a> &nbsp; <a class="qindex"href="globals.html">File Members</a> &nbsp; </center>
<hr><h1>point4.h</h1>This is the verbatim text of the point4.h include file.<div class="fragment"><pre>

#ifdef _XXXX_KATMAI 

#include &lt;xmmintrin.h&gt; 

#endif


class <a class="code" href="class_point4.html">Point4</a> {
public:
        
        union  {
                 __m128 vec;
                 struct { float x,y,z,w; };
        };

        // constructors
        <a class="code" href="class_point4.html#a0">Point</a>(float v_=0.0) { x=v_; y=v_; z=v_; w=1.0f; }

        <a class="code" href="class_point4.html#a0">Point</a>(const float v[3]) { x=v[0]; y=v[1]; z=v[2]; w=1.0f;}

        <a class="code" href="class_point4.html#a0">Point</a>(float x_, float y_, float z_=0.0, float w_=1.0) { x=x_; y=y_; z=z_; w=w_; }
        <a class="code" href="class_point4.html#a0">Point</a>(const <a class="code" href="class_point.html">Point</a> &amp;p) { x=p.x; y=p.y; z=p.z; w=p.w; }

        // Access
        float&amp; operator[] (int i) {
                //if (i == 0) return x; else if (i == 1) return y; else return z;
                return *((&amp;x)+i); // assume continous memory
        }

        const float&amp; operator[] (int i) const {
                // if (i == 0) return x; else if (i == 1) return y;else return z;
                return *((&amp;x)+i); // assume continous memory
        }

#ifdef _D3D
    operator D3DVECTOR&amp;() { return * ((D3DVECTOR *) &amp;x); } 
    operator const D3DVECTOR&amp;() const  { return * ((D3DVECTOR *) &amp;x); } 

    // convert to/ from D3D colorvalue 
        void <a class="code" href="class_point4.html#a6">Set</a>(const D3DCOLORVALUE &amp;p) { x=p.r; y=p.g; z=p.b; }
        void Get(D3DCOLORVALUE &amp;p,D3DVALUE alpha=1.0) const { p.r=x; p.g=y; p.b =z; p.a = alpha;}

#endif

        /* assigments */
        inline void <a class="code" href="class_point4.html#a6">Set</a>(float x_=0.0, float y_=0.0, float z_=0.0) { x=x_; y=y_; z=z_; }
        inline void <a class="code" href="class_point4.html#a6">Set</a>(const <a class="code" href="class_point.html">Point</a> &amp;p) { x=p.x; y=p.y; z=p.z; }
        inline void <a class="code" href="class_point4.html#a6">Set</a>(const float v[3]) { x=v[0]; y=v[1]; z=v[2]; }

        inline <a class="code" href="class_point.html">Point</a> &amp; <a class="code" href="class_point4.html#a9">Zero</a>() { x=y=z=0.0; return(*this); }
        inline <a class="code" href="class_point.html">Point</a> &amp; <a class="code" href="class_point4.html#a10">One</a>() { x=y=z=1.0; return(*this); }

        const char *<a class="code" href="class_point4.html#a11">ClassName</a>() const { return ("Point"); }


        /* misc */
        inline float <a class="code" href="class_point4.html#a12">Len2</a>() const { return (x*x + y*y + z*z); }         // squared length
        inline float <a class="code" href="class_point4.html#a13">Len</a>() const { return sqrt(<a class="code" href="class_point4.html#a12">Len2</a>()); }               // vector length
        inline float <a class="code" href="class_point4.html#a14">Length</a>() const { return sqrt(<a class="code" href="class_point4.html#a12">Len2</a>()); }            // vector length
        inline float <a class="code" href="class_point4.html#a15">ManhattanLen</a>() const { return (fabs(x)+fabs(y)+fabs(z)); } // vector length

        /* operators */

        // Unary operators returning a new point
        <a class="code" href="class_point.html">Point</a> operator- () const;
        <a class="code" href="class_point.html">Point</a> operator+ () const;


        // Assignment operators
        <a class="code" href="class_point.html">Point</a>&amp; operator+= (const <a class="code" href="class_point.html">Point</a>&amp; A);
        <a class="code" href="class_point.html">Point</a>&amp; operator-= (const <a class="code" href="class_point.html">Point</a>&amp; A);
        <a class="code" href="class_point.html">Point</a>&amp; operator*= (const <a class="code" href="class_point.html">Point</a>&amp; A);
        <a class="code" href="class_point.html">Point</a>&amp; operator/= (const <a class="code" href="class_point.html">Point</a>&amp; A);
        <a class="code" href="class_point.html">Point</a>&amp; operator+= (float A);
        <a class="code" href="class_point.html">Point</a>&amp; operator-= (float A);
        <a class="code" href="class_point.html">Point</a>&amp; operator*= (float A);
        <a class="code" href="class_point.html">Point</a>&amp; operator/= (float A);


        inline <a class="code" href="class_point.html">Point</a>&amp; <a class="code" href="class_point4.html#a26">Normalize</a>()       { 
                float l=<a class="code" href="class_point4.html#a13">Len</a>();
                if (l != 0.0) l= 1.0/l; else l=1.0;
                x *= l; y *=l; z*=l; return(*this);
                }

        // Binary operators returning a new point
        friend <a class="code" href="class_point.html">Point</a> operator+ (const <a class="code" href="class_point.html">Point</a>&amp; A, const <a class="code" href="class_point.html">Point</a>&amp; B);
        friend <a class="code" href="class_point.html">Point</a> operator- (const <a class="code" href="class_point.html">Point</a>&amp; A, const <a class="code" href="class_point.html">Point</a>&amp; B);
        friend <a class="code" href="class_point.html">Point</a> operator* (const <a class="code" href="class_point.html">Point</a>&amp; A, const <a class="code" href="class_point.html">Point</a>&amp; B);
        friend <a class="code" href="class_point.html">Point</a> operator* (const <a class="code" href="class_point.html">Point</a>&amp; A, float B);
        friend <a class="code" href="class_point.html">Point</a> operator* (float A, const <a class="code" href="class_point.html">Point</a>&amp; B);
        friend <a class="code" href="class_point.html">Point</a> operator* (const <a class="code" href="class_matrix.html">Matrix</a>&amp;, const <a class="code" href="class_point.html">Point</a>&amp;);
        friend <a class="code" href="class_point.html">Point</a> operator/ (const <a class="code" href="class_point.html">Point</a>&amp; A, const <a class="code" href="class_point.html">Point</a>&amp; B);
        friend <a class="code" href="class_point.html">Point</a> operator/ (const <a class="code" href="class_point.html">Point</a>&amp; A, float B);

        friend int operator&lt; (const <a class="code" href="class_point.html">Point</a>&amp; A, const <a class="code" href="class_point.html">Point</a>&amp; B);

        friend int operator== (const <a class="code" href="class_point.html">Point</a>&amp; A, const <a class="code" href="class_point.html">Point</a>&amp; B);
        friend int operator!= (const <a class="code" href="class_point.html">Point</a>&amp; A, const <a class="code" href="class_point.html">Point</a>&amp; B);

        friend int <a class="code" href="class_point4.html#l11">Equal</a>(const <a class="code" href="class_point.html">Point</a>&amp; A, const <a class="code" href="class_point.html">Point</a>&amp; B,float Epsilon=EPS);

        <a class="code" href="class_point.html">Point</a>&amp; operator*= (const <a class="code" href="class_matrix.html">Matrix</a> &amp;A) { <a class="code" href="class_point4.html#a6">Set</a>(A* *this); return(*this); }

        inline float <a class="code" href="class_point4.html#a28">Dot</a>(const <a class="code" href="class_point.html">Point</a>&amp; B) const
        {
                return x * B.x + y * B.y + z * B.z;
        }

        friend float <a class="code" href="class_point4.html#l12">DotProd</a>(const <a class="code" href="class_point.html">Point</a>&amp; A, const <a class="code" href="class_point.html">Point</a>&amp; B);
        
        inline <a class="code" href="class_point.html">Point</a>&amp; <a class="code" href="class_point4.html#a29">Cross</a> (const <a class="code" href="class_point.html">Point</a>&amp; A, const <a class="code" href="class_point.html">Point</a>&amp; B)
        {
           <a class="code" href="class_point4.html#a6">Set</a>(A.y * B.z - A.z * B.y,
                        A.z * B.x - A.x * B.z,
                        A.x * B.y - A.y * B.x);
        return(*this);
        }


        friend <a class="code" href="class_point.html">Point</a> <a class="code" href="class_point4.html#l13">CrossProd</a> (const <a class="code" href="class_point.html">Point</a>&amp; A, const <a class="code" href="class_point.html">Point</a>&amp; B);

        friend <a class="code" href="class_point.html">Point</a> <a class="code" href="class_point4.html#l14">NormCrossProd</a> (const <a class="code" href="class_point.html">Point</a>&amp; A, const <a class="code" href="class_point.html">Point</a>&amp; B);

        inline <a class="code" href="class_point.html">Point</a>&amp; <a class="code" href="class_point4.html#a30">Interpolate</a> (float ta, const <a class="code" href="class_point.html">Point</a>&amp; B,float tb, <a class="code" href="class_point.html">Point</a> &amp;Result);

        friend inline <a class="code" href="class_point.html">Point</a> <a class="code" href="class_point4.html#a30">Interpolate</a> (const <a class="code" href="class_point.html">Point</a>&amp; A, float ta, const <a class="code" href="class_point.html">Point</a>&amp; B,float tb);

        friend inline <a class="code" href="class_point.html">Point</a>&amp; <a class="code" href="class_point4.html#a30">Interpolate</a> (const <a class="code" href="class_point.html">Point</a>&amp; A, float ta, const <a class="code" href="class_point.html">Point</a>&amp; B,float tb,<a class="code" href="class_point.html">Point</a> &amp;Result);

        void <a class="code" href="class_point4.html#a31">MinMax</a>(<a class="code" href="class_point.html">Point</a> &amp;mi,<a class="code" href="class_point.html">Point</a> &amp;ma) const;


    inline int <a class="code" href="class_point4.html#a32">Dominant</a>() const  {
        int axis = 0;
        float tMax = fabs(x);
        if (fabs(y) &gt; tMax) { 
                tMax = fabs(y);   
                axis = 1;
        }
        if (fabs(z) &gt; tMax)     
                axis = 2;               
        return(axis);
    }


    void <a class="code" href="class_point4.html#a33">Project</a>(float&amp; px, float&amp; py, int axis) const {

        switch (axis) {
          case 0:
            px = y; py = z;
            break;
          case 1:
            px = x; py = z;
            break;
          default:
            px = x; py = y;
            break;
        }
    }
        
    inline void <a class="code" href="class_point4.html#a34">ProjectIndex</a>(int&amp; px, int&amp; py, int axis) const {

        switch (axis) {
          case 0:
            px = 1; py = 2;
            break;
          case 1:
            px = 0; py = 2;
            break;
          default:
            px = 0; py = 1;
            break;
        }
    }


        void <a class="code" href="class_point4.html#a35">Rotate</a>(const <a class="code" href="class_point.html">Point</a>&amp; AxisDir, float angle);
        void <a class="code" href="class_point4.html#a35">Rotate</a>(const <a class="code" href="class_point.html">Point</a>&amp; AxisPt, const <a class="code" href="class_point.html">Point</a>&amp; AxisDir,float angle);

        friend class <a class="code" href="class_point.html">Point</a> RotateOnly(const <a class="code" href="class_matrix.html">Matrix</a>&amp; M, const <a class="code" href="class_point.html">Point</a>&amp; v);

    float <a class="code" href="class_point4.html#a37">Angle</a>(const <a class="code" href="class_point.html">Point</a> &amp;v1) const {
                // return (double)acos(dot(v1)/v1.length()/v.length());

                float xx = y*v1.z - z*v1.y;
                float yy = z*v1.x - x*v1.z;
                float zz = x*v1.y - y*v1.x;
                float cross = sqrt(xx*xx + yy*yy + zz*zz);

                return fabs(atan2(cross, <a class="code" href="class_point4.html#a28">Dot</a>(v1)));
    }



        /* io */
        //friend ostream&amp; operator&lt;&lt; (ostream &amp;os,const Point &amp;a);
        int <a class="code" href="class_point4.html#a38">io</a>(<a class="code" href="class_astream.html">AStream</a> &amp;<a class="code" href="class_a.html">a</a>);

};

inline float <a class="code" href="point4.h.html#a0">Magnitude</a>(const <a class="code" href="class_point.html">Point</a>&amp; v)
{
        return sqrt(v.x*v.x + v.y*v.y + v.z*v.z);
}

inline <a class="code" href="class_point.html">Point</a> <a class="code" href="point4.h.html#a1">Normalize</a>(const <a class="code" href="class_point.html">Point</a>&amp; A)
{
        return A / <a class="code" href="point4.h.html#a0">Magnitude</a>(A);
}

inline float <a class="code" href="point4.h.html#a2">DotProd</a> (const <a class="code" href="class_point.html">Point</a>&amp; A, const <a class="code" href="class_point.html">Point</a>&amp; B)
{
        return A.x * B.x + A.y * B.y + A.z * B.z;
}

inline <a class="code" href="class_point.html">Point</a> Point::operator+ () const
{
        return *this;
}

inline <a class="code" href="class_point.html">Point</a> Point::operator- () const
{
        return Point(-x, -y, -z);
}

inline <a class="code" href="class_point.html">Point</a>&amp; Point::operator+= (const <a class="code" href="class_point.html">Point</a>&amp; A)
{
        x += A.x;  y += A.y; z += A.z;
        return *this;
}

inline <a class="code" href="class_point.html">Point</a>&amp; Point::operator-= (const <a class="code" href="class_point.html">Point</a>&amp; A)
{
        x -= A.x;  y -= A.y;  z -= A.z;
        return *this;
}

inline <a class="code" href="class_point.html">Point</a>&amp; Point::operator+= (float A)
{
        x += A;  y += A;  z += A;
        return *this;
}

inline <a class="code" href="class_point.html">Point</a>&amp; Point::operator-= (float A)
{
        x -= A;  y -= A;  z -= A;
        return *this;
}

inline <a class="code" href="class_point.html">Point</a>&amp; Point::operator*= (float A)
{
        x *= A;  y *= A;  z *= A;
        return *this;
}

inline <a class="code" href="class_point.html">Point</a>&amp; Point::operator/= (float A)
{
        x /= A;  y /= A;  z /= A;
        return *this;
}

inline <a class="code" href="class_point.html">Point</a>&amp; Point::operator*= (const <a class="code" href="class_point.html">Point</a>&amp; A)
{
        x *= A.x;  y *= A.y;  z *= A.z;
        return *this;
}

inline <a class="code" href="class_point.html">Point</a>&amp; Point::operator/= (const <a class="code" href="class_point.html">Point</a>&amp; A)
{
        x /= A.x;  y /= A.y;  z /= A.z;
        return *this;
}

inline <a class="code" href="class_point.html">Point</a> operator+ (const <a class="code" href="class_point.html">Point</a>&amp; A, const <a class="code" href="class_point.html">Point</a>&amp; B)
{
        return Point(A.x + B.x, A.y + B.y, A.z + B.z);
}

inline <a class="code" href="class_point.html">Point</a> operator- (const <a class="code" href="class_point.html">Point</a>&amp; A, const <a class="code" href="class_point.html">Point</a>&amp; B)
{
        return Point(A.x - B.x, A.y - B.y, A.z - B.z);
}

inline <a class="code" href="class_point.html">Point</a> operator* (const <a class="code" href="class_point.html">Point</a>&amp; A, const <a class="code" href="class_point.html">Point</a>&amp; B)
{
        return Point(A.x * B.x, A.y * B.y, A.z * B.z);
}

inline <a class="code" href="class_point.html">Point</a> operator* (const <a class="code" href="class_point.html">Point</a>&amp; A, float B)
{
        return Point(A.x * B, A.y * B, A.z * B);
}

inline <a class="code" href="class_point.html">Point</a> operator* (float A, const <a class="code" href="class_point.html">Point</a>&amp; B)
{
        return B * A;
}

inline <a class="code" href="class_point.html">Point</a> operator/ (const <a class="code" href="class_point.html">Point</a>&amp; A, const <a class="code" href="class_point.html">Point</a>&amp; B)
{
        return Point(A.x / B.x, A.y / B.y, A.z / B.z);
}

inline <a class="code" href="class_point.html">Point</a> operator/ (const <a class="code" href="class_point.html">Point</a>&amp; A, float B)
{
        return Point(A.x / B, A.y / B, A.z / B);
}

inline int operator&lt; (const <a class="code" href="class_point.html">Point</a>&amp; A, const <a class="code" href="class_point.html">Point</a>&amp; B)
{
        return A.x &lt; B.x &amp;&amp; A.y &lt; B.y &amp;&amp; A.z &lt; B.z;
}

inline int operator== (const <a class="code" href="class_point.html">Point</a>&amp; A, const <a class="code" href="class_point.html">Point</a>&amp; B)
{
        return (A.x == B.x) &amp;&amp; (A.y == B.y) &amp;&amp; (A.z == B.z);
}

inline int operator!= (const <a class="code" href="class_point.html">Point</a>&amp; A, const <a class="code" href="class_point.html">Point</a>&amp; B)
{
        return !(A == B);
}

inline int <a class="code" href="point4.h.html#a13">Equal</a>(const <a class="code" href="class_point.html">Point</a>&amp; A, const <a class="code" href="class_point.html">Point</a>&amp; B,float Epsilon)
{
        return  fabs(A.x - B.x) &lt;= Epsilon &amp;&amp;
                fabs(A.y -  B.y) &lt;= Epsilon &amp;&amp;
                fabs(A.z - B.z) &lt;= Epsilon;
}

inline <a class="code" href="class_point.html">Point</a> <a class="code" href="point4.h.html#a14">CrossProd</a> (const <a class="code" href="class_point.html">Point</a>&amp; A, const <a class="code" href="class_point.html">Point</a>&amp; B)
{
        return Point(A.y * B.z - A.z * B.y,
                        A.z * B.x - A.x * B.z,
                        A.x * B.y - A.y * B.x);
}

inline <a class="code" href="class_point.html">Point</a> <a class="code" href="point4.h.html#a15">NormCrossProd</a> (const <a class="code" href="class_point.html">Point</a>&amp; A, const <a class="code" href="class_point.html">Point</a>&amp; B)
{
        return (Point(A.y * B.z - A.z * B.y,
                        A.z * B.x - A.x * B.z,
                        A.x * B.y - A.y * B.x).Normalize());
}


inline <a class="code" href="class_point.html">Point</a>&amp; <a class="code" href="class_point.html#a30">Point::Interpolate</a> (float ta, const <a class="code" href="class_point.html">Point</a>&amp; B,float tb, <a class="code" href="class_point.html">Point</a> &amp;Result)
{
  Result = *this;
  Result *= ta;
  Result += B*tb;
  return(Result);
}

// a + (b-a) * t  == a * (1-t) + b * t
inline <a class="code" href="class_point.html">Point</a>&amp; <a class="code" href="point4.h.html#a16">Interpolate</a> (const <a class="code" href="class_point.html">Point</a>&amp; A, float ta, const <a class="code" href="class_point.html">Point</a>&amp; B,float tb, <a class="code" href="class_point.html">Point</a> &amp;Result)
{ Result = A;
  Result *= ta;
  Result += B*tb;
  return(Result);
}

inline <a class="code" href="class_point.html">Point</a> <a class="code" href="point4.h.html#a16">Interpolate</a> (const <a class="code" href="class_point.html">Point</a>&amp; A, float ta, const <a class="code" href="class_point.html">Point</a>&amp; B,float tb)
{ <a class="code" href="class_point.html">Point</a> result(A);
  result *= ta;
  result += B*tb;
  return(result);
}


// update minmax
inline void <a class="code" href="class_point.html#a31">Point::MinMax</a>(<a class="code" href="class_point.html">Point</a> &amp;mi,<a class="code" href="class_point.html">Point</a> &amp;ma) const
{
  if (x &lt; mi.x) mi.x = x; else if (x&gt;ma.x) ma.x=x;
  if (y &lt; mi.y) mi.y = y; else if (y&gt;ma.y) ma.y=y;
  if (z &lt; mi.z) mi.z = z; else if (z&gt;ma.z) ma.z=z;
}


//@class same as Point, but stores a direction vector 
class <a class="code" href="class_vector.html">Vector</a>    : public <a class="code" href="class_point.html">Point</a> {
public:
        // constructors

        <a class="code" href="class_vector.html#a0">Vector</a>(float v_=0.0) { x=v_; y=v_; z=v_; w=0.0f; }
        <a class="code" href="class_vector.html#a0">Vector</a>(float x_, float y_, float z_=0.0, float w_=0.0) { x=x_; y=y_; z=z_; w=w_;}
        <a class="code" href="class_vector.html#a0">Vector</a>(const <a class="code" href="class_point.html">Point</a> &amp;p) { x=p.x; y=p.y; z=p.z; w=p.w; }
        <a class="code" href="class_vector.html#a0">Vector</a>(const <a class="code" href="class_vector.html">Vector</a> &amp;p) { x=p.x; y=p.y; z=p.z; w=p.w; }

        <a class="code" href="class_vector.html">Vector</a> <a class="code" href="class_vector.html#a4">Reflect</a>(const <a class="code" href="class_vector.html">Vector</a> &amp; Normal) {
                return (Normal * ( 2.0 * <a class="code" href="class_point.html#l12">DotProd</a>(Normal,- *this )) + *this);
                }


//      friend Vector operator* (const Matrix&amp;, const Vector&amp;);

};





</div></pre><hr><address><small>Generated at Thu Jan 27 18:51:11 2000 for blaxxunContact3D by
<a href="http://www.stack.nl/~dimitri/doxygen/index.html">
<img src="doxygen.gif" alt="doxygen" align=center border=0 
width=118 height=53></a> 1.0.0 written by <a href="mailto:dimitri@stack.nl">Dimitri van Heesch</a>,
 &copy; 1997-1999</small></address>
</body>
</html>

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta name="robots" content="noindex">
<title>GMultitSensorHandler Include File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body bgcolor="#ffffff">
<!-- Generated by Doxygen 1.0.0 on Thu Jan 27 18:45:56 2000 -->
<center>
<a class="qindex"href="index.html">Main Page</a> &nbsp; <a class="qindex"href="namespaces.html">Namespace List</a> &nbsp; <a class="qindex"href="hierarchy.html">Class Hierarchy</a> &nbsp; <a class="qindex"href="annotated.html">Compound List</a> &nbsp; <a class="qindex"href="files.html">File List</a> &nbsp; <a class="qindex"href="headers.html">Header Files</a> &nbsp; <a class="qindex"href="namespacemembers.html">Namespace Members</a> &nbsp; <a class="qindex"href="functions.html">Compound Members</a> &nbsp; <a class="qindex"href="globals.html">File Members</a> &nbsp; </center>
<hr><h1>gevent.h</h1>This is the verbatim text of the gevent.h include file.<div class="fragment"><pre>/*=============================================================================

This code is licensed under the Web3D-blaxxun Community Source License,
provided in distribution file LICENSE.TXT and available online at
http://www.web3D.org/TaskGroups/x3d/blaxxun/Web3D-blaxxunCommunitySourceAgreement.html
and may only be used for non-commercial use as specified in that license.

THE WEB3D CONSORTIUM AND BLAXXUN DO NOT MAKE AND HEREBY DISCLAIM ANY EXPRESS
OR IMPLIED WARRANTIES RELATING TO THIS CODE, INCLUDING BUT NOT LIMITED TO,
WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY OR FITNESS FOR A PARTICULAR
PURPOSE, OR ANY WARRANTIES THAT MIGHT ARISE FROM A COURSE OF DEALING, USAGE
OR TRADE PRACTICE.  THE COMMUNITY SOURCE CODE IS PROVIDED UNDER THIS
AGREEMENT "AS IS," WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
INCLUDING, WITHOUT LIMITATION, WARRANTIES THAT THE COMMUNITY SOURCE CODE ARE
FREE OF DEFECTS, MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE OR
NON-INFRINGING OR IN ANY WAY CONSTITUTE THE COMPLETE PRODUCT MARKETED UNDER
THE NAMES GIVEN SAID CODE.

==============================================================================*/
#ifndef _GEvent_h
#define _GEvent_h
/******************************************************************************
@doc

@module GEvent.h - GLView event handler classes|

Copyright (c) 1996      by Holger Grahn
All rights reserved

Purpose:

Classes:
&lt;c GEventHandler&gt;

Notes:

Changes:

Todo :

******************************************************************************/

#include "quaternation.h"


class <a class="code" href="class_gview.html">GView</a>;

class <a class="code" href="class_gvgroup.html">GvGroup</a>;

//
// GEventHandler 
// base class for EventHandlers
//

class <a class="code" href="class_geventhandler.html">GEventHandler</a> : public <a class="code" href="class_rtroot.html">RTRoot</a> {
public:
        <a class="code" href="class_gvnode.html#a0">RT</a>(<a class="code" href="class_geventhandler.html">GEventHandler</a>);

        // the current state of eventhandler 
        int refCnt;
        void <a class="code" href="class_gvnode.html#a9">ref</a>() { refCnt ++; }
        void <a class="code" href="class_gvnode.html#a10">unref</a>() { refCnt--; if (refCnt&lt;=0) delete this; }


        int state; 

        // the view this eventhandler is attached to
        <a class="code" href="class_gview.html">GView</a> *view;

        <a class="code" href="class_geventhandler.html#a3">GEventHandler</a>(<a class="code" href="class_gview.html">GView</a> *View =NULL) : view(View) { refCnt = 0; state = 0; }
        virtual <a class="code" href="class_geventhandler.html#a4">~GEventHandler</a>();

        // get reference to camera in effect for view 
        <a class="code" href="class_gcamera.html">GCamera</a> &amp;<a class="code" href="class_geventhandler.html#a5">GetCamera</a>() { return *view-&gt;<a class="code" href="class_gview.html#a88">GetPhysicalCamera</a>(); }

        // set state variable
        void <a class="code" href="class_geventhandler.html#a6">SetState</a>(int State) { state=State; }

        // get state variable
        int <a class="code" href="class_geventhandler.html#a7">State</a>() const { return(state); }

        <a class="code" href="class_point.html">Point</a> firstPoint;
        UINT  firstFlags;

        // event handler action routines

        // nFlags are the OS status flags, point is in normalized screen space with dept undefined (0)
        virtual int <a class="code" href="class_geventhandler.html#a8">OnLButtonDown</a>(UINT nFlags, <a class="code" href="class_point.html">Point</a> &amp;point);
        virtual int <a class="code" href="class_geventhandler.html#a9">OnLButtonDblClk</a>(UINT nFlags, <a class="code" href="class_point.html">Point</a> &amp;point);
        virtual int <a class="code" href="class_geventhandler.html#a10">OnMouseMove</a>(UINT nFlags, <a class="code" href="class_point.html">Point</a> &amp;point);
        virtual int <a class="code" href="class_geventhandler.html#a11">OnLButtonUp</a>(UINT nFlags,  <a class="code" href="class_point.html">Point</a> &amp;point);
        virtual int <a class="code" href="class_geventhandler.html#a12">OnTimer</a>();

        enum EventStatus {
                                EV_OK,          // event was handled, continue
                                EV_CANCEL,      // event handler should terminate
                                EV_DONE,        // event handler done, terminate
                                EV_POP          // event handler done, pop from stack and unref 
                        };


        // coorindate mapping mode
        enum MapMode {
                                MAP_SCREEN,             // drag in screen plane
                                MAP_WORLD,              // drag in world plane
                                MAP_LOCAL               // drag in local object plane
                        };

};


//
// GPathHandler 
// handler maintain a path to a scene node 
//


class <a class="code" href="class_gpathhandler.html">GPathHandler</a> : public <a class="code" href="class_geventhandler.html">GEventHandler</a> {
public:
        <a class="code" href="class_gvnode.html#a0">RT</a>(<a class="code" href="class_geventhandler.html">GEventHandler</a>);

        <a class="code" href="class_gpathhandler.html#a1">GPathHandler</a>(<a class="code" href="class_gview.html">GView</a> *View =NULL) : <a class="code" href="class_geventhandler.html">GEventHandler</a>(View) {  }
        <a class="code" href="class_gpathhandler.html#a2">~GPathHandler</a>();

        // transform from world to local 
        <a class="code" href="class_matrixandinverse.html">MatrixAndInverse</a> m;


        // path to node affected by handler 
        <a class="code" href="class_gvpath.html">GvPath</a> path;

        // hit information from ComputeRayHit
        <a class="code" href="class_ghitinfo.html">GHitInfo</a> lastHit;

        void <a class="code" href="class_gpathhandler.html#a3">World2Local</a>(const <a class="code" href="class_point.html">Point</a> &amp;world, <a class="code" href="class_point.html">Point</a> &amp;local) {  local = m.<a class="code" href="class_matrixandinverse.html#a1">Inverse</a>() * world; }
        void <a class="code" href="class_gpathhandler.html#a4">Local2World</a>(const <a class="code" href="class_point.html">Point</a> &amp;local, <a class="code" href="class_point.html">Point</a> &amp;world) {  world = m.<a class="code" href="class_matrixandinverse.html#a2">M</a>() * local; }




        // Compute hit ray with scene and initialize path
        gbool <a class="code" href="class_gpathhandler.html#a5">ComputeRayHit</a>(<a class="code" href="class_rayrange.html">RayRange</a>     &amp;ray);



};




//
// GSensorHandler: event handler for handling VRML 2.0 geometry sensors 
//


class <a class="code" href="class_gsensorhandler.html">GSensorHandler</a> : public <a class="code" href="class_gpathhandler.html">GPathHandler</a> { //{GTransformPathHandler {
public:
        <a class="code" href="class_gvnode.html#a0">RT</a>(<a class="code" href="class_gsensorhandler.html">GSensorHandler</a>);

        <a class="code" href="class_gsensorhandler.html#a1">GSensorHandler</a>(<a class="code" href="class_gview.html">GView</a> *View =NULL) : <a class="code" href="class_gpathhandler.html">GPathHandler</a>(View) 
                        { sensorType = NO_SENSOR; 
                          <a class="code" href="class_gtransformpathhandler.html#a3">SetMapMode</a>(MAP_LOCAL);
                          mapPlane.<a class="code" href="class_plane.html#a10">SetZ</a>();
                        }
        <a class="code" href="class_gsensorhandler.html#a2">~GSensorHandler</a>();

        <a class="code" href="class_point.html">Point</a> firstS; // first point screen
        <a class="code" href="class_point.html">Point</a> firstO; // first point object     


        <a class="code" href="class_point.html">Point</a> lastS; // last point screen
        <a class="code" href="class_point.html">Point</a> lastO; // last point object       

        <a class="code" href="class_point.html">Point</a> centerS; // trackball center screen
        float radiusS; // trackball radius screen
        <a class="code" href="class_point.html">Point</a> centerL; // trackball center local
        float radiusL; // trackball radius local
        gbool diskMode; // diskMode for cylinder Sensor 

        <a class="code" href="class_point.html">Point</a> V0, V0L;
        <a class="code" href="class_vector.html">Vector</a> VectorS;

        MapMode mapMode;
        <a class="code" href="class_plane.html">Plane</a> mapPlane;

        // the drag computation is based on the last valid mouse move on the sphere/sensor
        <a class="code" href="class_vector.html">Vector</a> mouseMove;
        float lastRotation, mouseMoveLength;
        <a class="code" href="class_vector.html">Vector</a> rotationAxis;

        // in order to limit the rotation we need to save the accumulated rotation
        // the rotation quat [0;3.14] !
        float totalRotation;


        void <a class="code" href="class_gtransformpathhandler.html#a3">SetMapMode</a>(int mode) { if (mode &gt;= MAP_SCREEN &amp;&amp; mode &lt;= MAP_LOCAL) mapMode = (MapMode) mode; }


        // map coordinates 
        gbool <a class="code" href="class_gtransformpathhandler.html#a10">MapPoint</a>(const <a class="code" href="class_point.html">Point</a> &amp;screen, <a class="code" href="class_point.html">Point</a> &amp;world, <a class="code" href="class_point.html">Point</a> &amp;local);



        <a class="code" href="class_quaternation.html">Quaternation</a> rotation;  // accumulated rotation 


        typedef enum {
                NO_SENSOR,
                TOUCH_SENSOR,
                PLANE_SENSOR,
                SPHERE_SENSOR,
                CYLINDER_SENSOR
        } SensorType;
        
        SensorType sensorType;

        // set the sensor node handled by the event handler 
        void <a class="code" href="class_gsensorhandler.html#a5">SetSensor</a>(<a class="code" href="class_gvnode.html">GvNode</a> *sensor);
        <a class="code" href="class_gvnodehandle.html">GvNodeHandle</a> sensor;

        // set path  and matrix based on lastHit + sensor 
        gbool <a class="code" href="class_gtransformpathhandler.html#a22">InitPath</a>();


        int <a class="code" href="class_geventhandler.html#a8">OnLButtonDown</a>(UINT nFlags, <a class="code" href="class_point.html">Point</a> &amp;point);
        int <a class="code" href="class_geventhandler.html#a9">OnLButtonDblClk</a>(UINT nFlags, <a class="code" href="class_point.html">Point</a> &amp;point);
        int <a class="code" href="class_geventhandler.html#a10">OnMouseMove</a>(UINT nFlags,  <a class="code" href="class_point.html">Point</a> &amp;point);
        int <a class="code" href="class_geventhandler.html#a11">OnLButtonUp</a>(UINT nFlags,  <a class="code" href="class_point.html">Point</a> &amp;point);

};



//
// GMultitSensorHandler: event handler handling a set of geometry sensors 
//

class <a class="code" href="class_gmultitsensorhandler.html">GMultitSensorHandler</a> : public <a class="code" href="class_geventhandler.html">GEventHandler</a> 
{


        // the list of activate sensor handlers
        <a class="code" href="class_array.html">Array</a>&lt;<a class="code" href="class_gsensorhandler.html">GSensorHandler</a> *&gt; handlers;
        gbool hasTouchSensors;

        <a class="code" href="class_gvnode.html#a0">RT</a>(<a class="code" href="class_gmultitsensorhandler.html">GMultitSensorHandler</a>);

        <a class="code" href="class_gmultitsensorhandler.html#c1">GMultitSensorHandler</a>(<a class="code" href="class_gview.html">GView</a> *View =NULL) : <a class="code" href="class_geventhandler.html">GEventHandler</a>(View) { hasTouchSensors = FALSE; }
        <a class="code" href="class_gmultitsensorhandler.html#c2">~GMultitSensorHandler</a>();


        // add a new handler to list
        void <a class="code" href="class_gmultitsensorhandler.html#c3">add</a>( <a class="code" href="class_gsensorhandler.html">GSensorHandler</a> * newHandler);
        // remove a new handler from list
        void <a class="code" href="class_gmultitsensorhandler.html#c4">remove</a>(int i);

        // propagate events to all handlers and check for EV_POP
        int <a class="code" href="class_geventhandler.html#a8">OnLButtonDown</a>(UINT nFlags, <a class="code" href="class_point.html">Point</a> &amp;point);
        int <a class="code" href="class_geventhandler.html#a9">OnLButtonDblClk</a>(UINT nFlags, <a class="code" href="class_point.html">Point</a> &amp;point);
        int <a class="code" href="class_geventhandler.html#a10">OnMouseMove</a>(UINT nFlags,  <a class="code" href="class_point.html">Point</a> &amp;point);
        int <a class="code" href="class_geventhandler.html#a11">OnLButtonUp</a>(UINT nFlags,  <a class="code" href="class_point.html">Point</a> &amp;point);


};




#endif




</div></pre><hr><address><small>Generated at Thu Jan 27 18:45:56 2000 for blaxxunContact3D by
<a href="http://www.stack.nl/~dimitri/doxygen/index.html">
<img src="doxygen.gif" alt="doxygen" align=center border=0 
width=118 height=53></a> 1.0.0 written by <a href="mailto:dimitri@stack.nl">Dimitri van Heesch</a>,
 &copy; 1997-1999</small></address>
</body>
</html>

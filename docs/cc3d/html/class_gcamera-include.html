<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta name="robots" content="noindex">
<title>GCamera Include File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body bgcolor="#ffffff">
<!-- Generated by Doxygen 1.0.0 on Thu Jan 27 18:44:13 2000 -->
<center>
<a class="qindex"href="index.html">Main Page</a> &nbsp; <a class="qindex"href="namespaces.html">Namespace List</a> &nbsp; <a class="qindex"href="hierarchy.html">Class Hierarchy</a> &nbsp; <a class="qindex"href="annotated.html">Compound List</a> &nbsp; <a class="qindex"href="files.html">File List</a> &nbsp; <a class="qindex"href="headers.html">Header Files</a> &nbsp; <a class="qindex"href="namespacemembers.html">Namespace Members</a> &nbsp; <a class="qindex"href="functions.html">Compound Members</a> &nbsp; <a class="qindex"href="globals.html">File Members</a> &nbsp; </center>
<hr><h1>gcamera.h</h1>This is the verbatim text of the gcamera.h include file.<div class="fragment"><pre>/*=============================================================================

This code is licensed under the Web3D-blaxxun Community Source License,
provided in distribution file LICENSE.TXT and available online at
http://www.web3D.org/TaskGroups/x3d/blaxxun/Web3D-blaxxunCommunitySourceAgreement.html
and may only be used for non-commercial use as specified in that license.

THE WEB3D CONSORTIUM AND BLAXXUN DO NOT MAKE AND HEREBY DISCLAIM ANY EXPRESS
OR IMPLIED WARRANTIES RELATING TO THIS CODE, INCLUDING BUT NOT LIMITED TO,
WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY OR FITNESS FOR A PARTICULAR
PURPOSE, OR ANY WARRANTIES THAT MIGHT ARISE FROM A COURSE OF DEALING, USAGE
OR TRADE PRACTICE.  THE COMMUNITY SOURCE CODE IS PROVIDED UNDER THIS
AGREEMENT "AS IS," WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
INCLUDING, WITHOUT LIMITATION, WARRANTIES THAT THE COMMUNITY SOURCE CODE ARE
FREE OF DEFECTS, MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE OR
NON-INFRINGING OR IN ANY WAY CONSTITUTE THE COMPLETE PRODUCT MARKETED UNDER
THE NAMES GIVEN SAID CODE.

==============================================================================*/
// GCamera Class header file

#ifndef _gcamera_h
#define _gcamera_h

//#include "point.h"

class <a class="code" href="class_gvperspectivecamera.html">GvPerspectiveCamera</a>;
class <a class="code" href="class_gvorthographiccamera.html">GvOrthographicCamera</a>;
class <a class="code" href="class_gvviewpoint.html">GvViewpoint</a>;


class <a class="code" href="class_gcamera.html">GCamera</a> {
public:

   static float znearFactor; // a factor to compute znear from zfar : znear = zfar * znearFactor
   // Limiting values
   static float panMax;
   static float orbitMax;
   static float zoomMax;
   static float rollMax;
   static float dollyMax;

   
   // compute znearFactor based on z-buffer depth 
   static float <a class="code" href="class_gcamera.html#d0">SetZNearFactor</a>(int zbufferDepth=24);
    
   <a class="code" href="class_point.html">Point</a> position;                      // camera position = eye location
   <a class="code" href="class_point.html">Point</a> target;                        // camera target point = destination
   <a class="code" href="class_point.html">Point</a> up;                            // 
   float width,height;          // field, size of the view rectangle in view plane
   int perspective;                     // perspective projection flag

   float znear,zfar;        // near far clipping planes

   // additional variables to provide a absolute frame of movement
   <a class="code" href="class_point.html">Point</a> worldUp;                       // absolute up-vector
   float worldUpDist;       // distance from origin together with worldUp defines a plane
   <a class="code" href="class_point.html">Point</a> worldCenter;           // center of world
   <a class="code" href="class_bbox.html">BBox</a>  worldBBox;         // world bounding box

   <a class="code" href="class_bbox.html">BBox</a>  worldLimit;        // world bounding box limit

   <a class="code" href="class_point.html">Point</a> orbitCenter;           // center point for orbit 

   // computed matrices
   <a class="code" href="class_matrix.html">Matrix</a> viewMatrix;           // transform world to viewpoint
   <a class="code" href="class_matrix.html">Matrix</a> projectionMatrix;     // project 

   int world2pValid,p2worldValid;
   <a class="code" href="class_matrix.html">Matrix</a> world2p;                      // world 2 projection (device) space
   <a class="code" href="class_matrix.html">Matrix</a> p2world;                      // projection 2 world space

   // get matrix transforming from world 2 projection (device) space
   const <a class="code" href="class_matrix.html">Matrix</a>&amp; <a class="code" href="class_gcamera.html#a0">World2p</a>();
   const <a class="code" href="class_matrix.html">Matrix</a>&amp; <a class="code" href="class_gcamera.html#a1">P2World</a>();

   // transform point from world 2 projection space
   void <a class="code" href="class_gcamera.html#a2">Project</a>(const <a class="code" href="class_point.html">Point</a> &amp;pin, <a class="code" href="class_point.html">Point</a> &amp;pout);
   int  <a class="code" href="class_gcamera.html#a3">UnProject</a>(const <a class="code" href="class_point.html">Point</a> &amp;p, <a class="code" href="class_point.html">Point</a> &amp;pout);

        // compute a ray defined by start &amp; ending point in world space
        // input : x,y coordinate in normalized view space 0..1


   // output objP, objP1 start / end point 
        void <a class="code" href="class_gcamera.html#a4">ComputeWorldRay</a>(float x,float y,<a class="code" href="class_point.html">Point</a> &amp;objP,<a class="code" href="class_point.html">Point</a> &amp;objP2,
                                                          float znear=0.0,float zfar=1.0);


   void <a class="code" href="class_gcamera.html#a5">SetWorldReference</a>(const <a class="code" href="class_bbox.html">BBox</a> &amp;bbox);
   void <a class="code" href="class_gcamera.html#a5">SetWorldReference</a>(const <a class="code" href="class_bbox.html">BBox</a> &amp;bbox, const <a class="code" href="class_point.html">Point</a> &amp;center, const <a class="code" href="class_point.html">Point</a> &amp;up, float distance=0.0);
   void <a class="code" href="class_gcamera.html#a7">ComputeWorldUpFromUp</a>();
   
   // Limit view to this box
   void <a class="code" href="class_gcamera.html#a8">SetWorldLimit</a>(const <a class="code" href="class_bbox.html">BBox</a> &amp;bbox,float scale=1.0);



   float aspect;                        // Aspect ratio of screen window
   float fovy;                          // Field of view
   
   float widthPixel,heightPixel;        // size of window in pixel
   float widthWorld,heightWorld;        // actual field, after checking for aspect

   <a class="code" href="class_gcamera.html#a9">GCamera</a>();

   <a class="code" href="class_gcamera.html">GCamera</a>&amp; <a class="code" href="class_gcamera.html#a10">SetByVolume</a>(float x1,float x2,float y1,float y2); 
   <a class="code" href="class_gcamera.html">GCamera</a>&amp; <a class="code" href="class_gcamera.html#a10">SetByVolume</a>(const <a class="code" href="class_point.html">Point</a> &amp;p1,const <a class="code" href="class_point.html">Point</a> &amp;p2); 
   
   <a class="code" href="class_gcamera.html">GCamera</a>&amp; <a class="code" href="class_gcamera.html#a12">SetAspect</a>(float Aspect) { aspect = Aspect; return(*this); }

   <a class="code" href="class_gcamera.html">GCamera</a>&amp; operator+=(const <a class="code" href="class_point.html">Point</a> &amp;p);
  
   <a class="code" href="class_gcamera.html">GCamera</a>&amp; <a class="code" href="class_gcamera.html#a14">OrbitX</a>(float dw,int worldRelative=0);       // Rotate position around target
   <a class="code" href="class_gcamera.html">GCamera</a>&amp; <a class="code" href="class_gcamera.html#a15">OrbitY</a>(float dw,int worldRelative=0);
   <a class="code" href="class_gcamera.html">GCamera</a>&amp; <a class="code" href="class_gcamera.html#a16">PanX</a>(float dw,int worldRelative=0);         // rotate target around position
   <a class="code" href="class_gcamera.html">GCamera</a>&amp; <a class="code" href="class_gcamera.html#a17">PanY</a>(float dw,int worldRelative=0);

   // move in x /y Z direction
   <a class="code" href="class_gcamera.html">GCamera</a>&amp; <a class="code" href="class_gcamera.html#a18">DollyX</a>(float d,int worldRelative=0);
   <a class="code" href="class_gcamera.html">GCamera</a>&amp; <a class="code" href="class_gcamera.html#a19">DollyY</a>(float d,int worldRelative=0);
   <a class="code" href="class_gcamera.html">GCamera</a>&amp; <a class="code" href="class_gcamera.html#a20">DollyZ</a>(float d,int worldRelative=0);
   
   // zoom by camera field
   <a class="code" href="class_gcamera.html">GCamera</a>&amp; <a class="code" href="class_gcamera.html#a21">Zoom</a>(float f); 


   // rotate up vector along viewaxis
   <a class="code" href="class_gcamera.html">GCamera</a>&amp; <a class="code" href="class_gcamera.html#a22">Roll</a>(float dw);      
   
   // Zoom distance to target
   <a class="code" href="class_gcamera.html">GCamera</a>&amp; <a class="code" href="class_gcamera.html#a23">ZoomDistance</a>(float f);


   // look left/right, up/down
   // world relative means, axis reference is worldUp instead of up
   <a class="code" href="class_gcamera.html">GCamera</a>&amp; <a class="code" href="class_gcamera.html#a24">Pan</a>(float wx,float wy,int worldRelative=0); 

   // rotate around target
   <a class="code" href="class_gcamera.html">GCamera</a>&amp; <a class="code" href="class_gcamera.html#a25">Orbit</a>(float wx,float wy,int worldRelative=0); 

   // rotate around orbitCenter
   <a class="code" href="class_gcamera.html">GCamera</a>&amp; <a class="code" href="class_gcamera.html#a26">OrbitCenter</a>(float wx,float wy,int worldRelative=0); 
   
   // move left/right up/down in/out
   <a class="code" href="class_gcamera.html">GCamera</a>&amp; <a class="code" href="class_gcamera.html#a27">Dolly</a>(float dx,float dy,float dz,int worldRelative=0);

   <a class="code" href="class_gcamera.html">GCamera</a>&amp; <a class="code" href="class_gcamera.html#a28">PanMax</a>(float wx,float wy,int worldRelative=0) 
   {
       if (wx&lt;-panMax) wx = -panMax; else if (wx&gt;panMax) wx =panMax;
       if (wy&lt;-panMax) wy = -panMax; else if (wy&gt;panMax) wy =panMax;
       return(<a class="code" href="class_gcamera.html#a24">Pan</a>(wx,wy,worldRelative));
   }       

   <a class="code" href="class_gcamera.html">GCamera</a>&amp; <a class="code" href="class_gcamera.html#a29">OrbitMax</a>(float wx,float wy,int worldRelative=0) 
   {
       if (wx&lt;-orbitMax) wx = -orbitMax; else if (wx&gt;orbitMax) wx = orbitMax;
       if (wy&lt;-orbitMax) wy = -orbitMax; else if (wy&gt;orbitMax) wy = orbitMax;
       return(<a class="code" href="class_gcamera.html#a25">Orbit</a>(wx,wy,worldRelative));
   }       

   <a class="code" href="class_gcamera.html">GCamera</a>&amp; <a class="code" href="class_gcamera.html#a30">OrbitCenterMax</a>(float wx,float wy,int worldRelative=0) 
   {
       if (wx&lt;-orbitMax) wx = -orbitMax; else if (wx&gt;orbitMax) wx = orbitMax;
       if (wy&lt;-orbitMax) wy = -orbitMax; else if (wy&gt;orbitMax) wy = orbitMax;
       return(<a class="code" href="class_gcamera.html#a26">OrbitCenter</a>(wx,wy,worldRelative));
   }       


   <a class="code" href="class_gcamera.html">GCamera</a>&amp; <a class="code" href="class_gcamera.html#a31">DollyMax</a>(float dx,float dy,float dz,int worldRelative=0) 
   {
       return(<a class="code" href="class_gcamera.html#a27">Dolly</a>(dx,dy,dz,  worldRelative));
   }

   // zoom by camera field
   <a class="code" href="class_gcamera.html">GCamera</a>&amp; <a class="code" href="class_gcamera.html#a32">ZoomMax</a>(float f) 
   {
       return(<a class="code" href="class_gcamera.html#a21">Zoom</a>(f));
   }       


   // rotate up vector along viewaxis
   <a class="code" href="class_gcamera.html">GCamera</a>&amp; <a class="code" href="class_gcamera.html#a33">RollMax</a>(float dw)
   {
       if (dw&lt;-rollMax) dw = -rollMax; else if (dw&gt;rollMax) dw =rollMax;
       return(<a class="code" href="class_gcamera.html#a22">Roll</a>(dw));
   }       



   // vector pointing to position
   <a class="code" href="class_point.html">Point</a> <a class="code" href="class_gcamera.html#a34">Direction</a>() { return(position-target); };
   <a class="code" href="class_point.html">Point</a> <a class="code" href="class_gcamera.html#a35">NormDirection</a> () {  <a class="code" href="class_point.html">Point</a> dir =position-target; 
                                                        dir.<a class="code" href="class_point.html#a26">Normalize</a>();
                                                        return(dir);
                                                 };

   // set direction to target 
   void <a class="code" href="class_gcamera.html#a36">SetTargetDirection</a>(const <a class="code" href="class_point.html">Point</a> &amp;dir);
   void <a class="code" href="class_gcamera.html#a37">CheckUpVector</a>();

   // vector pointing to target
   <a class="code" href="class_point.html">Point</a> <a class="code" href="class_gcamera.html#a38">TargetDirection</a> () { return(target-position); };
   <a class="code" href="class_point.html">Point</a> <a class="code" href="class_gcamera.html#a39">NormTargetDirection</a>() {  <a class="code" href="class_point.html">Point</a> dir =target-position; 
                                                        dir.<a class="code" href="class_point.html#a26">Normalize</a>();
                                                        return(dir);
                                                 };

   // Vector pointing to the "right", the x axis of the camera 
   <a class="code" href="class_point.html">Point</a> <a class="code" href="class_gcamera.html#a40">Right</a>() { return CrossProd(up,<a class="code" href="class_gcamera.html#a35">NormDirection</a>()); };
   <a class="code" href="class_point.html">Point</a> <a class="code" href="class_gcamera.html#a41">NormRight</a>() { <a class="code" href="class_point.html">Point</a> dir(<a class="code" href="class_gcamera.html#a40">Right</a>());
                                           dir.<a class="code" href="class_point.html#a26">Normalize</a>(); 
                                           return(dir);
                                         };

   // Vector pointing to the "right", in world x axis of the camera 
   <a class="code" href="class_point.html">Point</a> <a class="code" href="class_gcamera.html#a42">WorldRight</a>();
   <a class="code" href="class_point.html">Point</a> <a class="code" href="class_gcamera.html#a43">WorldNormRight</a>();

   // vector pointing to target, in world "z" axis of the camera
   <a class="code" href="class_point.html">Point</a> <a class="code" href="class_gcamera.html#a44">WorldTargetDirection</a> ();
   <a class="code" href="class_point.html">Point</a> <a class="code" href="class_gcamera.html#a45">WorldNormTargetDirection</a>();

   
   float <a class="code" href="class_gcamera.html#a46">TargetDistance</a>() { <a class="code" href="class_point.html">Point</a> dir=<a class="code" href="class_gcamera.html#a34">Direction</a>(); return(dir.<a class="code" href="class_point.html#a13">Len</a>()); }

   double <a class="code" href="class_gcamera.html#a47">GetFovY</a>();

   // Compute the  view orientation matrix
   int <a class="code" href="class_gcamera.html#a48">GetViewMatrix</a>( <a class="code" href="class_matrix.html">Matrix</a> &amp;m);

   
   <a class="code" href="class_point.html">Point</a> &amp;<a class="code" href="class_gcamera.html#a49">Up</a>() { return(up); }
   <a class="code" href="class_point.html">Point</a> &amp;<a class="code" href="class_gcamera.html#a50">Target</a>() { return(target); }
   <a class="code" href="class_point.html">Point</a> &amp;<a class="code" href="class_gcamera.html#a51">Position</a>() { return(position); }

   
   // Changed management
   int changed;     // each time setting is change, increment
   int changeLevel;
   gbool isDefault;   // current setting is a default camera computed
   gbool zrangeIsDefault;   // current z-range setting is a default camera computed
   gbool targetDistanceIsDefault; // camera target distance is default
   
   // recompute z range, to view scene
   int <a class="code" href="class_gcamera.html#a52">SetZRange</a>(const <a class="code" href="class_bbox.html">BBox</a> &amp;bbox);

   // recompute target distance based on bbox
   int <a class="code" href="class_gcamera.html#a53">SetTargetDistance</a>(const <a class="code" href="class_bbox.html">BBox</a> &amp;bbox);
   
   // call on each change, to invalidate state of computed variables
   virtual void <a class="code" href="class_gcamera.html#a54">OnChanged</a>();

   gbool <a class="code" href="class_gcamera.html#a55">Changed</a>() const { return(changed&gt;0); }
   
   gbool <a class="code" href="class_gcamera.html#a56">IsDefault</a>() const { return(isDefault); }
   
   // set size of output window in pixel to allow for coordinate transformation
   void <a class="code" href="class_gcamera.html#a57">SetFieldPixel</a>(int width,int height)  // if with = dx, call with width=dx-1
                { widthPixel = width;
                  heightPixel = height;
                }

   // Transform distance from pixel to world space 
   void <a class="code" href="class_gcamera.html#a58">Pixel2WorldDelta</a>(const <a class="code" href="class_point.html">Point</a> &amp;ppixel, <a class="code" href="class_point.html">Point</a> &amp;pworld) 
   { pworld.Set(widthWorld * ppixel.x / widthPixel,
                                 heightWorld * ppixel.y / heightPixel,0.0);
   }

   // transform by matrix
   <a class="code" href="class_gcamera.html">GCamera</a>&amp; <a class="code" href="class_gcamera.html#a59">Transform</a>(const <a class="code" href="class_matrix.html">Matrix</a> &amp;m);

   // set by a GvLib cameraNode 
   int  <a class="code" href="class_gtraversal.html#a9">Set</a>(<a class="code" href="class_gvperspectivecamera.html">GvPerspectiveCamera</a> *c,const <a class="code" href="class_matrix.html">Matrix</a> *cameraTransform=NULL); // in GModel.c
   int  <a class="code" href="class_gtraversal.html#a9">Set</a>(<a class="code" href="class_gvorthographiccamera.html">GvOrthographicCamera</a> *c,const <a class="code" href="class_matrix.html">Matrix</a> *cameraTransform=NULL); // in GModel.c
   int  <a class="code" href="class_gtraversal.html#a9">Set</a>(<a class="code" href="class_gvviewpoint.html">GvViewpoint</a> *c,const <a class="code" href="class_matrix.html">Matrix</a> *cameraTransform=NULL); // in GModel.c

   // compute the view &amp; projection matrix
   int <a class="code" href="class_gcamera.html#a63">UpdateViewProjectionMatrix</a>();

   //gl
#ifdef _OGL
   void glSet();
#endif


};


// Information about view transformation

class <a class="code" href="class_gviewinfo.html">GViewInfo</a> 
{
public:
    <a class="code" href="class_bbox.html">BBox</a> viewVolume;

    <a class="code" href="class_matrixandinverse.html">MatrixAndInverse</a> view;
    <a class="code" href="class_matrixandinverse.html">MatrixAndInverse</a> cam;
    
    <a class="code" href="class_matrixandinverse.html">MatrixAndInverse</a> object;
    
    int object2viewOk;
    <a class="code" href="class_matrixandinverse.html">MatrixAndInverse</a> object2view;

    int <a class="code" href="class_gviewinfo.html#a0">View2World</a>(const <a class="code" href="class_point.html">Point</a> &amp;p, <a class="code" href="class_point.html">Point</a> &amp;result);
    int <a class="code" href="class_gviewinfo.html#a1">World2View</a>(const <a class="code" href="class_point.html">Point</a> &amp;p, <a class="code" href="class_point.html">Point</a> &amp;result);

    int <a class="code" href="class_gviewinfo.html#a2">World2Cam</a>(const <a class="code" href="class_point.html">Point</a> &amp;p, <a class="code" href="class_point.html">Point</a> &amp;result);
    int <a class="code" href="class_gviewinfo.html#a3">Cam2World</a>(const <a class="code" href="class_point.html">Point</a> &amp;p, <a class="code" href="class_point.html">Point</a> &amp;result);
    
    int <a class="code" href="class_gviewinfo.html#a12">View2Object</a>(const <a class="code" href="class_point.html">Point</a> &amp;p, <a class="code" href="class_point.html">Point</a> &amp;result)
    {
        const <a class="code" href="class_matrix.html">Matrix</a>&amp; m=<a class="code" href="class_gviewinfo.html#a12">View2Object</a>();
        result = m * p;
        return(1);
    }

    int <a class="code" href="class_gviewinfo.html#a11">Object2View</a>(const <a class="code" href="class_point.html">Point</a> &amp;p, <a class="code" href="class_point.html">Point</a> &amp;result) 
    {
        const <a class="code" href="class_matrix.html">Matrix</a>&amp; m=<a class="code" href="class_gviewinfo.html#a11">Object2View</a>();
        result = m * p;
        return(1);
    }



    int <a class="code" href="class_gviewinfo.html#a6">glGet</a>();



    <a class="code" href="class_gviewinfo.html#a7">GViewInfo</a>() { object2viewOk=0;}

    void <a class="code" href="class_gviewinfo.html#a8">SetObject</a>(const <a class="code" href="class_matrix.html">Matrix</a> &amp;m) {
        object.<a class="code" href="class_matrixandinverse.html#a5">Set</a>(m);
        object2viewOk=0;
    }
    
    void <a class="code" href="class_gviewinfo.html#a9">SetView</a>(const <a class="code" href="class_matrix.html">Matrix</a> &amp;m) {
        view.<a class="code" href="class_matrixandinverse.html#a5">Set</a>(m);
        object2viewOk=0;
    }

    void <a class="code" href="class_gviewinfo.html#a10">SetCam</a>(const <a class="code" href="class_matrix.html">Matrix</a> &amp;m) {
        cam.<a class="code" href="class_matrixandinverse.html#a5">Set</a>(m);
        //object2viewOk=0;
    }


    const <a class="code" href="class_matrix.html">Matrix</a> &amp; <a class="code" href="class_gviewinfo.html#a11">Object2View</a>() 
    {
        if (!object2viewOk) {
            object2view.m = object.m;
            object2view.<a class="code" href="class_matrixandinverse.html#a6">Append</a>(view.m);
        }
        return (object2view.<a class="code" href="class_matrixandinverse.html#a2">M</a>());
    }

    const <a class="code" href="class_matrix.html">Matrix</a> &amp; <a class="code" href="class_gviewinfo.html#a12">View2Object</a>() 
    {
        if (!object2viewOk) {
            object2view.m = object.m;
            object2view.<a class="code" href="class_matrixandinverse.html#a6">Append</a>(view.m);
        }
        return (object2view.<a class="code" href="class_matrixandinverse.html#a1">Inverse</a>());
    }


};




#endif

</div></pre><hr><address><small>Generated at Thu Jan 27 18:44:14 2000 for blaxxunContact3D by
<a href="http://www.stack.nl/~dimitri/doxygen/index.html">
<img src="doxygen.gif" alt="doxygen" align=center border=0 
width=118 height=53></a> 1.0.0 written by <a href="mailto:dimitri@stack.nl">Dimitri van Heesch</a>,
 &copy; 1997-1999</small></address>
</body>
</html>

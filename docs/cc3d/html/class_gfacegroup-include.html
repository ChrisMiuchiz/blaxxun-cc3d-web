<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta name="robots" content="noindex">
<title>GFaceGroup Include File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body bgcolor="#ffffff">
<!-- Generated by Doxygen 1.0.0 on Thu Jan 27 18:44:51 2000 -->
<center>
<a class="qindex"href="index.html">Main Page</a> &nbsp; <a class="qindex"href="namespaces.html">Namespace List</a> &nbsp; <a class="qindex"href="hierarchy.html">Class Hierarchy</a> &nbsp; <a class="qindex"href="annotated.html">Compound List</a> &nbsp; <a class="qindex"href="files.html">File List</a> &nbsp; <a class="qindex"href="headers.html">Header Files</a> &nbsp; <a class="qindex"href="namespacemembers.html">Namespace Members</a> &nbsp; <a class="qindex"href="functions.html">Compound Members</a> &nbsp; <a class="qindex"href="globals.html">File Members</a> &nbsp; </center>
<hr><h1>gshelli.h</h1>This is the verbatim text of the gshelli.h include file.<div class="fragment"><pre>/*=============================================================================

This code is licensed under the Web3D-blaxxun Community Source License,
provided in distribution file LICENSE.TXT and available online at
http://www.web3D.org/TaskGroups/x3d/blaxxun/Web3D-blaxxunCommunitySourceAgreement.html
and may only be used for non-commercial use as specified in that license.

THE WEB3D CONSORTIUM AND BLAXXUN DO NOT MAKE AND HEREBY DISCLAIM ANY EXPRESS
OR IMPLIED WARRANTIES RELATING TO THIS CODE, INCLUDING BUT NOT LIMITED TO,
WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY OR FITNESS FOR A PARTICULAR
PURPOSE, OR ANY WARRANTIES THAT MIGHT ARISE FROM A COURSE OF DEALING, USAGE
OR TRADE PRACTICE.  THE COMMUNITY SOURCE CODE IS PROVIDED UNDER THIS
AGREEMENT "AS IS," WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
INCLUDING, WITHOUT LIMITATION, WARRANTIES THAT THE COMMUNITY SOURCE CODE ARE
FREE OF DEFECTS, MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE OR
NON-INFRINGING OR IN ANY WAY CONSTITUTE THE COMPLETE PRODUCT MARKETED UNDER
THE NAMES GIVEN SAID CODE.

==============================================================================*/
#ifndef _GSHELLI_H
#define _GSHELLI_H
/******************************************************************************
@doc

@module GShellI.h - GLView GShellI object       |

Copyright (c) 1995      by Holger Grahn
All rights reserved

Purpose:

Classes:
&lt;c GFaceGroup&gt;
&lt;c GShellI&gt;
Notes:

Changes:

$Revision: 1.26 $
$Log: gshelli.h,v $
Revision 1.26  1999/07/06 16:54:55  tom
*** empty log message ***

Revision 1.10  1998/08/20 17:22:16  holger
empty message



Todo :

******************************************************************************/

class <a class="code" href="class_gfacegroup.html">GFaceGroup</a>;

class <a class="code" href="class_gshelli.html">GShellI</a>;


int <a class="code" href="gshelli.h.html#a0">computeNormalIndices</a>(int nci, const long *cind,
                                                 int ncoords, const <a class="code" href="class_point.html">Point</a> *coords,
                                                 float creaseAngle, gbool ccw,
                                                 <a class="code" href="class_pointarray.html">PointArray</a> &amp;fn,<a class="code" href="class_intarray.html">IntArray</a> &amp;normalIndex);

int <a class="code" href="gshelli.h.html#a0">computeNormalIndices</a> (const <a class="code" href="class_gfacelist.html">GFaceList</a> &amp;f,
                                                 <a class="code" href="class_array.html">Array</a>&lt;<a class="code" href="class_gvertexi.html">GVertexI</a>&gt; &amp;verts,
                                                 int ncoords, const <a class="code" href="class_point.html">Point</a> *coords,
                                                 float creaseAngle, gbool ccw,
                                                 <a class="code" href="class_pointarray.html">PointArray</a> &amp;fn);


 
class <a class="code" href="class_gfacegroup.html">GFaceGroup</a> {
public:

        int flags;
        enum {
                COLOR=1,        // color attribute set
        };

        <a class="code" href="class_point.html">Point</a> color;
        char name[60];  // name of this group

        int offset; // face offset (not saved )
        int cnt;        // face count

        <a class="code" href="class_gfacegroup.html#a0">GFaceGroup</a>() { flags = 0; name[0]=0; }

        <a class="code" href="class_gfacegroup.html#a0">GFaceGroup</a>(const <a class="code" href="class_gfacegroup.html">GFaceGroup</a> &amp;src) { flags = src.flags; strcpy(name,src.name); color = src.color; }

        // material
        void <a class="code" href="class_gfacegroup.html#a2">SetColor</a>(const <a class="code" href="class_point.html">Point</a> &amp;NewColor) { color = NewColor; flags |= COLOR; }
        int <a class="code" href="class_gfacegroup.html#a3">HasColor</a>() { return (flags &amp; COLOR)!=0; }
        void <a class="code" href="class_gfacegroup.html#a4">SetName</a>(const char *NewName) { strcpy(name,NewName); }
        int <a class="code" href="class_gfacegroup.html#a5">MatchName</a>(const char *SearchName) { return(<a class="code" href="gutils.h.html#a36">streq</a>(SearchName,name)); }

#ifdef _3DV
        // IO : input/output
        int io(<a class="code" href="class_astream.html">AStream</a> &amp;<a class="code" href="class_a.html">a</a>);
#endif _3DV

};




class <a class="code" href="class_gshelli.html">GShellI</a> : public <a class="code" href="class_gshell.html">GShell</a>  {
public:
        <a class="code" href="class_gshell.html#a0">RT</a>(<a class="code" href="class_gshelli.html">GShellI</a>);

        <a class="code" href="class_array.html">Array</a>&lt;<a class="code" href="class_gvertexi.html">GVertexI</a>&gt; verts;

        <a class="code" href="class_gshelli.html#a1">GShellI</a>();
    <a class="code" href="class_gshelli.html#a1">GShellI</a>(    int new_nv,const <a class="code" href="class_point.html">Point</a> *new_v,
                                int new_nf=0,const int *new_f=NULL,gbool normalsPerFace=gfalse);

         
    <a class="code" href="class_gshelli.html#a1">GShellI</a>(int cols,int rows,const <a class="code" href="class_point.html">Point</a> *new_v,gbool normalsPerFace=gfalse);


        <a class="code" href="class_gshelli.html#a4">~GShellI</a>();

        virtual int <a class="code" href="class_gshell.html#a5">Update</a>(); 

        virtual void <a class="code" href="class_gshell.html#a103">UpdateSubMeshVertices</a>(int what=0);

        int <a class="code" href="class_gshell.html#a64">isPlanar</a>(<a class="code" href="class_plane.html">Plane</a> &amp;plane);

    virtual int <a class="code" href="class_gshell.html#a73">ComputeMaxVertexI</a>( <a class="code" href="class_gvertexi.html">GVertexI</a> &amp;vert);

        virtual int <a class="code" href="class_gshell.html#a48">GetVertexCnt</a>() { return (verts.<a class="code" href="class_array.html#a21">Length</a>());}


        void <a class="code" href="class_gshelli.html#a10">SetVertices</a>(int new_nv,const <a class="code" href="class_gvertexi.html">GVertexI</a> *new_v);
        void <a class="code" href="class_gshelli.html#a10">SetVertices</a>(const <a class="code" href="class_array.html">Array</a>&lt;<a class="code" href="class_gvertexi.html">GVertexI</a>&gt; &amp;new_v);

        virtual int <a class="code" href="class_gshell.html#a70">GetVertex</a>(int i, <a class="code" href="class_gvertex.html">GVertex</a> &amp;vert);

        virtual int <a class="code" href="class_gshell.html#a71">SetVertex</a>(int i, const <a class="code" href="class_gvertex.html">GVertex</a> &amp;vert)
        {

                if (i &lt; v.Length())   v[i] = vert.v;    // the vertex coordinates
                if (i &lt; vn.Length()) vn[i] = vert.n;    // the vertex normal
                if (i &lt; vc.Length()) vc[i] = vert.c;    // the vertex color
                if (i &lt; vp.Length()) vp[i] = vert.p;    // the vertex parameter
                return(0);
        }

        int <a class="code" href="class_gshelli.html#a14">SetVertsLength</a>(int newLen)
        {
       if (newLen != verts.<a class="code" href="class_array.html#a21">Length</a>()) edit_flags |= SHELL_VERTS_LENGTH_CHANGED;
       verts.<a class="code" href="class_array.html#a33">SetLength</a>(newLen);
                 return (verts.<a class="code" href="class_array.html#a21">Length</a>());
        };

        virtual int <a class="code" href="class_gshell.html#a72">GetVertexI</a>(int i, <a class="code" href="class_gvertexi.html">GVertexI</a> &amp;vert)
        {

                if (i &lt; verts.<a class="code" href="class_array.html#a21">Length</a>())  {
                   vert = verts[i]; // all vert information
                   return(0);
                } else return(-1);
        }

        virtual int <a class="code" href="class_gshelli.html#a16">SetVertexI</a>(int i, const <a class="code" href="class_gvertexi.html">GVertexI</a> &amp;vert)
        {

                if (i &lt; verts.<a class="code" href="class_array.html#a21">Length</a>())  {
                   verts[i] = vert; // all vert information
                   return(0);
                } else return(-1);
        }

        // !append a single GVertexI, optionally with lookup
        int <a class="code" href="class_gshell.html#a49">AppendVertex</a>(const <a class="code" href="class_gvertexi.html">GVertexI</a> &amp;p,int doLookup=1);

        virtual int <a class="code" href="class_gshell.html#a49">AppendVertex</a>(const <a class="code" href="class_gvertex.html">GVertex</a> &amp;vert);


        virtual int <a class="code" href="class_gshell.html#a49">AppendVertex</a>(const <a class="code" href="class_point.html">Point</a> &amp;p,int doLookup=1);
        
    // append a list of points, optionally lookup points and return vertex indices in old2new
        //virtual int AppendVertex(const PointArray &amp;p,int doLookup,IntArray *old2new)

        int <a class="code" href="class_gshelli.html#a20">ExtractFace</a>(int flen, const int *fp, int *outfp);

        void <a class="code" href="class_gshell.html#a78">ComputeFaceNormals</a>(int allocFaceinfo=0);

        int <a class="code" href="class_gshell.html#a79">ComputeVertexNormals</a>();


        int <a class="code" href="class_gshell.html#a82">ComputeVertexColorsFromFaceColors</a>();

        int <a class="code" href="class_gshell.html#a83">ComputeFaceColorsFromVertexColors</a>();


        int <a class="code" href="class_gshell.html#a84">ComputeEdgeList</a>();


        <a class="code" href="class_intarray.html">IntArray</a> fg;    // mapping face index to fgroup

        <a class="code" href="class_array.html">Array</a>&lt;<a class="code" href="class_gfacegroup.html">GFaceGroup</a>&gt; fgroup;

        int <a class="code" href="class_gshelli.html#a26">FindFaceGroup</a>(const char *name) {
                        int i; for(i=0; i&lt;fgroup.<a class="code" href="class_array.html#a21">Length</a>(); i++) {
                                if (fgroup[i].MatchName(name)) return(i); }
                         return(-1);
           }

        
        int <a class="code" href="class_gshelli.html#a27">AppendFaceGroup</a>(<a class="code" href="class_gfacegroup.html">GFaceGroup</a> &amp;NewGroup)
           {
                        fgroup.<a class="code" href="class_array.html#a38">Append</a>(NewGroup);
                        return(fgroup.<a class="code" href="class_array.html#a21">Length</a>()) -1;
           }

        
        int <a class="code" href="class_gshelli.html#a28">ComputeFaceColorsFromGroups</a>();
        
        <a class="code" href="class_gshell.html">GShell</a> *<a class="code" href="class_gshelli.html#a29">ComputeShell</a>(<a class="code" href="class_gshell.html">GShell</a> *s=0,int copyAttributes=1);


    GEvalAs_TYPE* <a class="code" href="class_gshell.html#a97">EvalAs</a>(<a class="code" href="class_typeid.html">TypeId</a> type,int copyAttributes=1); 
        
        int <a class="code" href="class_gshell.html#a67">ComputeTriangles</a>(<a class="code" href="class_gfacelist.html">GFaceList</a> &amp;<a class="code" href="class_tri.html">tri</a>,<a class="code" href="class_intarray.html">IntArray</a> &amp;tri2face,int useTriangulator);




#ifdef _OGL
        // OPENGL Rendering
        void RenderGlEdges(<a class="code" href="class_renderstate.html">RenderState</a> &amp;state,int VN=0,int VC=0,int VP=0);
        void RenderGlFaces(<a class="code" href="class_renderstate.html">RenderState</a> &amp;state,int FN=1, int VN=0, int VC=0, int VP=0);
#endif

#ifdef _D3D
    virtual int GetVertex(RenderState &amp;state,int flipNormals,D3DVERTEX *V);

        
        virtual int <a class="code" href="class_gshell.html#a70">GetVertex</a>(<a class="code" href="class_renderstate.html">RenderState</a> &amp;state,int flipNormals,DWORD flags, D3DCOLOR diffuse, D3DVALUE *V);

        virtual int <a class="code" href="class_gshell.html#a70">GetVertex</a>(<a class="code" href="class_renderstate.html">RenderState</a> &amp;state,int flipNormals, D3DCVERTEX *V);


        virtual int <a class="code" href="class_gshell.html#a70">GetVertex</a>(<a class="code" href="class_renderstate.html">RenderState</a> &amp;state,D3DCOLOR color, D3DCOLOR specular,D3DLVERTEX *V);
        
        virtual int <a class="code" href="class_gshell.html#a70">GetVertex</a>(<a class="code" href="class_renderstate.html">RenderState</a> &amp;state,int flipNormals,D3DVERTEX *V,<a class="code" href="class_intarray.html">IntArray</a> &amp;map);

        virtual int <a class="code" href="class_gshell.html#a70">GetVertex</a>(<a class="code" href="class_renderstate.html">RenderState</a> &amp;state,D3DCOLOR color, D3DCOLOR specular,D3DLVERTEX *V,<a class="code" href="class_intarray.html">IntArray</a> &amp;map);

        virtual int D3dRenderTL(<a class="code" href="class_gglrendertraversal.html">GglRenderTraversal</a> &amp;traversalState);


#endif


    virtual int <a class="code" href="class_gshell.html#a110">IntersectFaces</a>(<a class="code" href="class_grayselecttraversal.html">GRaySelectTraversal</a> &amp;traversal,const <a class="code" href="class_gfacelist.html">GFaceList</a> &amp;f,<a class="code" href="class_rayrange.html">RayRange</a> &amp;ray, <a class="code" href="class_ghitinfo.html">GHitInfo</a> &amp;info); // declared in GShell.h implemented in GRaySelect
        virtual void <a class="code" href="class_gshell.html#a109">ComputeRapidModel</a>();
        int <a class="code" href="class_gshell.html#a111">CollideFaces</a>(const <a class="code" href="class_gfacelist.html">GFaceList</a> &amp;f,<a class="code" href="class_gconvexvolume.html">GConvexVolume</a> &amp;volume, <a class="code" href="class_gcollisionresponse.html">GCollisionResponse</a> &amp;response, <a class="code" href="class_ghitinfo.html">GHitInfo</a> &amp;hitInfo);

#ifdef _3DV
        int io(AStream &amp;a);
#endif _3DV


#ifdef _VRML
        virtual int WriteVrml(AStream &amp;a,gbool vrml2);
#endif


}; // GShellI


// Helping class for computing set of verts for shelli
class <a class="code" href="class_gvertexientry.html">GVertexIEntry</a> {
public:
                int vi; // ref to vertex number in verts table
                <a class="code" href="class_gvertexientry.html">GVertexIEntry</a> *next;

                <a class="code" href="class_gvertexientry.html#a0">GVertexIEntry</a>(int VI,<a class="code" href="class_gvertexientry.html">GVertexIEntry</a> *NEXT=NULL) {
                                                vi = VI;
                                                next = NEXT; }

};

// helper class
// to lookup and enter GVertexI elements
// quickly into an Array&lt;GVertexI&gt; 


class <a class="code" href="class_gvertexitable.html">GVertexITable</a> {
public :
                <a class="code" href="class_gvertexientry.html">GVertexIEntry</a> * *v;
                int nv;
                <a class="code" href="class_array.html">Array</a>&lt;<a class="code" href="class_gvertexi.html">GVertexI</a>&gt; &amp;verts; // reference to vert table
                int nverts;

                // initialize vertex table
                <a class="code" href="class_gvertexitable.html#a0">GVertexITable</a>(<a class="code" href="class_array.html">Array</a>&lt;<a class="code" href="class_gvertexi.html">GVertexI</a>&gt; &amp;Verts,
                        int NV /* max vert.v used as v table key */);


                <a class="code" href="class_gvertexitable.html#a1">~GVertexITable</a>();

                // Enter Vertex vert into verts table, 
                // Return index of vert if inserted,
                // or -1 if enter == 0 and vert not found
                int <a class="code" href="class_gvertexitable.html#a2">Lookup</a>(<a class="code" href="class_gvertexi.html">GVertexI</a> &amp;vert,int enter=1);
};

//@class a polyline Indexed with optional facelist 

class <a class="code" href="class_gpolylinei.html">GPolylineI</a> : public <a class="code" href="class_gshelli.html">GShellI</a> {
public :
                <a class="code" href="class_gshell.html#a0">RT</a>(<a class="code" href="class_gpolylinei.html">GPolylineI</a>);
                
                <a class="code" href="class_gpolylinei.html#a1">GPolylineI</a>();

                int <a class="code" href="class_gshell.html#a77">GetFaceList</a>(<a class="code" href="class_gfacelist.html">GFaceList</a> &amp;flist);

                int <a class="code" href="class_gshell.html#a105">Do</a>(<a class="code" href="class_grayselecttraversal.html">GRaySelectTraversal</a> &amp;state);

#ifdef _OGL
                // render the faces as LINE_STRIP
                void RenderGlFaces(<a class="code" href="class_renderstate.html">RenderState</a> &amp;state,int FN, int VN, int VC, int VP);
                int glRender(<a class="code" href="class_renderstate.html">RenderState</a> &amp;state);
#endif

#ifdef _D3D
                // Create execute buffer for shell,
                // result 0 error, 1 ok
                virtual int CreateExBuf(<a class="code" href="class_renderstate.html">RenderState</a> &amp;state,<a class="code" href="class_g3objref.html">G3ObjRef</a> &amp;objBuf);
                virtual int D3dRenderTL(<a class="code" href="class_gglrendertraversal.html">GglRenderTraversal</a> &amp;traversalState);

#endif



};






// compute default VRML texture coordinates based on Bounding Box for a set of points
void <a class="code" href="gshelli.h.html#a2">ComputeBoxParams</a>(const <a class="code" href="class_bbox.html">BBox</a> &amp;bbox, const <a class="code" href="class_pointarray.html">PointArray</a> &amp;p, <a class="code" href="class_pointarray.html">PointArray</a> &amp;params);
void <a class="code" href="gshelli.h.html#a2">ComputeBoxParams</a>(const <a class="code" href="class_bbox.html">BBox</a> &amp;bbox, const <a class="code" href="class_array.html">Array</a>&lt;<a class="code" href="class_gvertexi.html">GVertexI</a>&gt; &amp;verts, const <a class="code" href="class_pointarray.html">PointArray</a> &amp;p, <a class="code" href="class_pointarray.html">PointArray</a> &amp;params);


// compute a new Ghell object from a GShellI object with only used V VN VC VP entrys
<a class="code" href="class_gshelli.html">GShellI</a> * <a class="code" href="gshelli.h.html#a4">CompressShell</a>(<a class="code" href="class_gshelli.html">GShellI</a> *old, <a class="code" href="class_gshelli.html">GShellI</a> *s,int copyAttributes,int lookupAttributes);
<a class="code" href="class_gshelli.html">GShellI</a> * <a class="code" href="gshelli.h.html#a4">CompressShell</a>(<a class="code" href="class_gshell.html">GShell</a> *old, <a class="code" href="class_gshelli.html">GShellI</a> *s,int copyAttributes,int lookupAttributes);


int <a class="code" href="gshelli.h.html#a6">ReadShellWavefront</a>(const char *FileName,<a class="code" href="class_gshelli.html">GShellI</a> *&amp;s);

<a class="code" href="class_gshelli.html">GShellI</a> * <a class="code" href="gshelli.h.html#a7">NewBox</a>(float atx=-0.5, float aty=-0.5,float atz=-0.5,
                        float dx=1.0,float dy=1.0,float dz=1.0,<a class="code" href="class_gshelli.html">GShellI</a> *cube=0);


<a class="code" href="class_gshelli.html">GShellI</a> *<a class="code" href="gshelli.h.html#a8">NewCylinder</a>(float cx=0.0,float cy=0.0,float cz=0.0,float r=1.0,float h=2.0,int n=12,<a class="code" href="class_gshelli.html">GShellI</a> *o=0);

<a class="code" href="class_gshelli.html">GShellI</a> *<a class="code" href="gshelli.h.html#a9">NewCylinderVrml</a>(float cx=0.0,float cy=0.0,float cz=0.0,float r=1.0,float h=2.0,int n=12,int parts = -1,<a class="code" href="class_point.html">Point</a> *facolors=NULL,<a class="code" href="class_gshelli.html">GShellI</a> *o=0);
<a class="code" href="class_gshelli.html">GShellI</a> *<a class="code" href="gshelli.h.html#a10">NewConeVrml</a>(float cx=0.0,float cy=0.0,float cz=0.0,float r=1.0,float h=2.0,int n=12,int parts = -1,<a class="code" href="class_point.html">Point</a> *facolors=NULL,<a class="code" href="class_gshelli.html">GShellI</a> *o=0);
<a class="code" href="class_gshelli.html">GShellI</a> * <a class="code" href="gshelli.h.html#a11">NewBoxVrml</a>(float atx=-0.5, float aty=-0.5,float atz=-0.5,
                        float dx=1.0,float dy=1.0,float dz=1.0,<a class="code" href="class_gshelli.html">GShellI</a> *cube=0);

// sphere with parameters arround y
<a class="code" href="class_gshelli.html">GShellI</a> *<a class="code" href="gshelli.h.html#a12">NewSphereVrml</a>(float cx=0.0,float cy=0.0,float cz=0.0,float r=1.0, int n1=16,int n2=8,<a class="code" href="class_point.html">Point</a> *folors=NULL,<a class="code" href="class_gshelli.html">GShellI</a> *o=NULL);



#endif
</div></pre><hr><address><small>Generated at Thu Jan 27 18:44:51 2000 for blaxxunContact3D by
<a href="http://www.stack.nl/~dimitri/doxygen/index.html">
<img src="doxygen.gif" alt="doxygen" align=center border=0 
width=118 height=53></a> 1.0.0 written by <a href="mailto:dimitri@stack.nl">Dimitri van Heesch</a>,
 &copy; 1997-1999</small></address>
</body>
</html>

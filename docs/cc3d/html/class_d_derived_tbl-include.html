<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta name="robots" content="noindex">
<title>d_derived_tbl Include File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body bgcolor="#ffffff">
<!-- Generated by Doxygen 1.0.0 on Thu Jan 27 18:54:45 2000 -->
<center>
<a class="qindex"href="index.html">Main Page</a> &nbsp; <a class="qindex"href="namespaces.html">Namespace List</a> &nbsp; <a class="qindex"href="hierarchy.html">Class Hierarchy</a> &nbsp; <a class="qindex"href="annotated.html">Compound List</a> &nbsp; <a class="qindex"href="files.html">File List</a> &nbsp; <a class="qindex"href="headers.html">Header Files</a> &nbsp; <a class="qindex"href="namespacemembers.html">Namespace Members</a> &nbsp; <a class="qindex"href="functions.html">Compound Members</a> &nbsp; <a class="qindex"href="globals.html">File Members</a> &nbsp; </center>
<hr><h1>jdhuff.h</h1>This is the verbatim text of the jdhuff.h include file.<div class="fragment"><pre>/*
 * jdhuff.h
 *
 * Copyright (C) 1991-1996, Thomas G. Lane.
 * This file is part of the Independent JPEG Group's software.
 * For conditions of distribution and use, see the accompanying README file.
 *
 * This file contains declarations for Huffman entropy decoding routines
 * that are shared between the sequential decoder (jdhuff.c) and the
 * progressive decoder (jdphuff.c).  No other modules need to see these.
 */

/* Short forms of external names for systems with brain-damaged linkers. */

#ifdef NEED_SHORT_EXTERNAL_NAMES
#define jpeg_make_d_derived_tbl jMkDDerived
#define jpeg_fill_bit_buffer    jFilBitBuf
#define jpeg_huff_decode        jHufDecode
#endif /* NEED_SHORT_EXTERNAL_NAMES */


/* Derived data constructed for each Huffman table */

#define HUFF_LOOKAHEAD  8       /* # of bits of lookahead */

typedef struct {
  /* Basic tables: (element [0] of each array is unused) */
  INT32 mincode[17];            /* smallest code of length k */
  INT32 maxcode[18];            /* largest code of length k (-1 if none) */
  /* (maxcode[17] is a sentinel to ensure jpeg_huff_decode terminates) */
  int valptr[17];               /* huffval[] index of 1st symbol of length k */

  /* Link to public Huffman table (needed only in jpeg_huff_decode) */
  <a class="code" href="class_jhuff_tbl.html">JHUFF_TBL</a> *pub;

  /* Lookahead tables: indexed by the next HUFF_LOOKAHEAD bits of
   * the input data stream.  If the next Huffman code is no more
   * than HUFF_LOOKAHEAD bits long, we can obtain its length and
   * the corresponding symbol directly from these tables.
   */
  int look_nbits[1&lt;&lt;HUFF_LOOKAHEAD]; /* # bits, or 0 if too long */
  UINT8 look_sym[1&lt;&lt;HUFF_LOOKAHEAD]; /* symbol, or unused */
} <a class="code" href="class_d_derived_tbl.html">d_derived_tbl</a>;

/* Expand a Huffman table definition into the derived format */
<a class="code" href="cdjpeg.h.html#a10">EXTERN</a>(void) jpeg_make_d_derived_tbl <a class="code" href="jpeglib.h.html#a18">JPP</a>((j_decompress_ptr cinfo,
                                <a class="code" href="class_jhuff_tbl.html">JHUFF_TBL</a> * htbl, <a class="code" href="class_d_derived_tbl.html">d_derived_tbl</a> ** pdtbl));


/*
 * Fetching the next N bits from the input stream is a time-critical operation
 * for the Huffman decoders.  We implement it with a combination of inline
 * macros and out-of-line subroutines.  Note that N (the number of bits
 * demanded at one time) never exceeds 15 for JPEG use.
 *
 * We read source bytes into get_buffer and dole out bits as needed.
 * If get_buffer already contains enough bits, they are fetched in-line
 * by the macros CHECK_BIT_BUFFER and GET_BITS.  When there aren't enough
 * bits, jpeg_fill_bit_buffer is called; it will attempt to fill get_buffer
 * as full as possible (not just to the number of bits needed; this
 * prefetching reduces the overhead cost of calling jpeg_fill_bit_buffer).
 * Note that jpeg_fill_bit_buffer may return FALSE to indicate suspension.
 * On TRUE return, jpeg_fill_bit_buffer guarantees that get_buffer contains
 * at least the requested number of bits --- dummy zeroes are inserted if
 * necessary.
 */

typedef INT32 bit_buf_type;     /* type of bit-extraction buffer */
#define BIT_BUF_SIZE  32        /* size of buffer in bits */

/* If long is &gt; 32 bits on your machine, and shifting/masking longs is
 * reasonably fast, making bit_buf_type be long and setting BIT_BUF_SIZE
 * appropriately should be a win.  Unfortunately we can't do this with
 * something like  #define BIT_BUF_SIZE (sizeof(bit_buf_type)*8)
 * because not all machines measure sizeof in 8-bit bytes.
 */

typedef struct {                /* Bitreading state saved across MCUs */
  bit_buf_type get_buffer;      /* current bit-extraction buffer */
  int bits_left;                /* # of unused bits in it */
  boolean printed_eod;          /* flag to suppress multiple warning msgs */
} <a class="code" href="class_bitread_perm_state.html">bitread_perm_state</a>;

typedef struct {                /* Bitreading working state within an MCU */
  /* current data source state */
  const JOCTET * next_input_byte; /* =&gt; next byte to read from source */
  size_t bytes_in_buffer;       /* # of bytes remaining in source buffer */
  int unread_marker;            /* nonzero if we have hit a marker */
  /* bit input buffer --- note these values are kept in register variables,
   * not in this struct, inside the inner loops.
   */
  bit_buf_type get_buffer;      /* current bit-extraction buffer */
  int bits_left;                /* # of unused bits in it */
  /* pointers needed by jpeg_fill_bit_buffer */
  j_decompress_ptr cinfo;       /* back link to decompress master record */
  boolean * printed_eod_ptr;    /* =&gt; flag in permanent state */
} <a class="code" href="class_bitread_working_state.html">bitread_working_state</a>;

/* Macros to declare and load/save bitread local variables. */
#define BITREAD_STATE_VARS  \
        register bit_buf_type get_buffer;  \
        register int bits_left;  \
        <a class="code" href="class_bitread_working_state.html">bitread_working_state</a> br_state

#define BITREAD_LOAD_STATE(cinfop,permstate)  \
        br_state.cinfo = cinfop; \
        br_state.next_input_byte = cinfop-&gt;src-&gt;next_input_byte; \
        br_state.bytes_in_buffer = cinfop-&gt;src-&gt;bytes_in_buffer; \
        br_state.unread_marker = cinfop-&gt;unread_marker; \
        get_buffer = permstate.get_buffer; \
        bits_left = permstate.bits_left; \
        br_state.printed_eod_ptr = &amp; permstate.printed_eod

#define <a class="code" href="jdhuff.h.html#a4">BITREAD_SAVE_STATE</a>(cinfop,permstate)  \
        cinfop-&gt;src-&gt;next_input_byte = br_state.next_input_byte; \
        cinfop-&gt;src-&gt;bytes_in_buffer = br_state.bytes_in_buffer; \
        cinfop-&gt;unread_marker = br_state.unread_marker; \
        permstate.get_buffer = get_buffer; \
        permstate.bits_left = bits_left

/*
 * These macros provide the in-line portion of bit fetching.
 * Use CHECK_BIT_BUFFER to ensure there are N bits in get_buffer
 * before using GET_BITS, PEEK_BITS, or DROP_BITS.
 * The variables get_buffer and bits_left are assumed to be locals,
 * but the state struct might not be (jpeg_huff_decode needs this).
 *      CHECK_BIT_BUFFER(state,n,action);
 *              Ensure there are N bits in get_buffer; if suspend, take action.
 *      val = GET_BITS(n);
 *              Fetch next N bits.
 *      val = PEEK_BITS(n);
 *              Fetch next N bits without removing them from the buffer.
 *      DROP_BITS(n);
 *              Discard next N bits.
 * The value N should be a simple variable, not an expression, because it
 * is evaluated multiple times.
 */

#define CHECK_BIT_BUFFER(state,nbits,action) \
        { if (bits_left &lt; (nbits)) {  \
            if (! jpeg_fill_bit_buffer(&amp;(state),get_buffer,bits_left,nbits))  \
              { action; }  \
            get_buffer = (state).get_buffer; bits_left = (state).bits_left; } }

#define GET_BITS(nbits) \
        (((int) (get_buffer &gt;&gt; (bits_left -= (nbits)))) &amp; ((1&lt;&lt;(nbits))-1))

#define PEEK_BITS(nbits) \
        (((int) (get_buffer &gt;&gt; (bits_left -  (nbits)))) &amp; ((1&lt;&lt;(nbits))-1))

#define DROP_BITS(nbits) \
        (bits_left -= (nbits))

/* Load up the bit buffer to a depth of at least nbits */
<a class="code" href="cdjpeg.h.html#a10">EXTERN</a>(boolean) jpeg_fill_bit_buffer
        <a class="code" href="jpeglib.h.html#a18">JPP</a>((<a class="code" href="class_bitread_working_state.html">bitread_working_state</a> * state, register bit_buf_type get_buffer,
             register int bits_left, int nbits));


/*
 * Code for extracting next Huffman-coded symbol from input bit stream.
 * Again, this is time-critical and we make the main paths be macros.
 *
 * We use a lookahead table to process codes of up to HUFF_LOOKAHEAD bits
 * without looping.  Usually, more than 95% of the Huffman codes will be 8
 * or fewer bits long.  The few overlength codes are handled with a loop,
 * which need not be inline code.
 *
 * Notes about the HUFF_DECODE macro:
 * 1. Near the end of the data segment, we may fail to get enough bits
 *    for a lookahead.  In that case, we do it the hard way.
 * 2. If the lookahead table contains no entry, the next code must be
 *    more than HUFF_LOOKAHEAD bits long.
 * 3. jpeg_huff_decode returns -1 if forced to suspend.
 */

#define HUFF_DECODE(result,state,htbl,failaction,slowlabel) \
{ register int nb, look; \
  if (bits_left &lt; HUFF_LOOKAHEAD) { \
    if (! jpeg_fill_bit_buffer(&amp;state,get_buffer,bits_left, 0)) {failaction;} \
    get_buffer = state.get_buffer; bits_left = state.bits_left; \
    if (bits_left &lt; HUFF_LOOKAHEAD) { \
      nb = 1; goto slowlabel; \
    } \
  } \
  look = <a class="code" href="jdhuff.h.html#a7">PEEK_BITS</a>(HUFF_LOOKAHEAD); \
  if ((nb = htbl-&gt;look_nbits[look]) != 0) { \
    <a class="code" href="jdhuff.h.html#a8">DROP_BITS</a>(nb); \
    result = htbl-&gt;look_sym[look]; \
  } else { \
    nb = HUFF_LOOKAHEAD+1; \
slowlabel: \
    if ((result=jpeg_huff_decode(&amp;state,get_buffer,bits_left,htbl,nb)) &lt; 0) \
        { failaction; } \
    get_buffer = state.get_buffer; bits_left = state.bits_left; \
  } \
}

/* Out-of-line case for Huffman code fetching */
<a class="code" href="cdjpeg.h.html#a10">EXTERN</a>(int) jpeg_huff_decode
        <a class="code" href="jpeglib.h.html#a18">JPP</a>((<a class="code" href="class_bitread_working_state.html">bitread_working_state</a> * state, register bit_buf_type get_buffer,
             register int bits_left, <a class="code" href="class_d_derived_tbl.html">d_derived_tbl</a> * htbl, int min_bits));
</div></pre><hr><address><small>Generated at Thu Jan 27 18:54:45 2000 for blaxxunContact3D by
<a href="http://www.stack.nl/~dimitri/doxygen/index.html">
<img src="doxygen.gif" alt="doxygen" align=center border=0 
width=118 height=53></a> 1.0.0 written by <a href="mailto:dimitri@stack.nl">Dimitri van Heesch</a>,
 &copy; 1997-1999</small></address>
</body>
</html>

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta name="robots" content="noindex">
<title>GStreamDescStream Include File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body bgcolor="#ffffff">
<!-- Generated by Doxygen 1.0.0 on Thu Jan 27 18:46:33 2000 -->
<center>
<a class="qindex"href="index.html">Main Page</a> &nbsp; <a class="qindex"href="namespaces.html">Namespace List</a> &nbsp; <a class="qindex"href="hierarchy.html">Class Hierarchy</a> &nbsp; <a class="qindex"href="annotated.html">Compound List</a> &nbsp; <a class="qindex"href="files.html">File List</a> &nbsp; <a class="qindex"href="headers.html">Header Files</a> &nbsp; <a class="qindex"href="namespacemembers.html">Namespace Members</a> &nbsp; <a class="qindex"href="functions.html">Compound Members</a> &nbsp; <a class="qindex"href="globals.html">File Members</a> &nbsp; </center>
<hr><h1>gstream.h</h1>This is the verbatim text of the gstream.h include file.<div class="fragment"><pre>
#ifndef _gstream_h
#define _gstream_h

#ifdef G_RMA_MOVIE
// Real G2 SDK problem , conflicting declarations in MSVC 6.0, see comment in pntypes.h !

#if (defined(_MSC_VER)) //  &amp;&amp; (_MSC_VER &gt;= 1200)) // VC6 
#include "pntypes.h"
#endif

#endif


// forward
class <a class="code" href="class_gmemmap.html">GMemMap</a>;

typedef enum {
                GDF_FLOAT,              // 4 byte IEEE float
                GDF_DOUBLE,             // 8 byte IEEE double
                GDF_SHORT,              // 2 byte signed int    
                GDF_FIX_8_8,    // 8.8 fixed signed int 
                GDF_FIX_13_3    // 13.3 fixed signed int

} GDFloatEncoding;

// ! get floating point 
inline  float <a class="code" href="gstream.h.html#a0">Fix8_8</a>(USHORT s) 
{ 
                signed short <a class="code" href="class_a.html">a</a> =s; 
                <a class="code" href="class_a.html">a</a> = (<a class="code" href="class_a.html">a</a>&gt;&gt;8);
                unsigned char b = (s &amp; 0xFF);
                float f = <a class="code" href="class_a.html">a</a>+ 1.0f / (float) b;
                return f;

}

inline  float <a class="code" href="gstream.h.html#a1">Fix13_3</a>(USHORT s) 
{ 
                signed short <a class="code" href="class_a.html">a</a> =s; 
                s&amp;=(1+2+4);
                s=(s&gt;&gt;3);
                unsigned char b = (s &amp; (1+2+4));

                float f = <a class="code" href="class_a.html">a</a>+ 1.0f / (float) b;
                return f;

}



typedef enum {
                GDF_UBYTE,              // 1 byte 
                GDF_USHORT,             // 2 byte 
                GDF_UINT,               // 4 byte 
} GSIntEncoding;




typedef UINT32 GStreamId;
typedef UINT32 GStreamType;

typedef enum {
  G_STYPE_EOF,
          
  G_STYPE_STREAM_DESC,          // a stream describing streams (stream descriptors)             
  G_STYPE_TIME,                         // a stream containing time stamps
  G_STYPE_RESOURCE,                     // a stream containing resources (image materials, textures, vertexbuffers etc)
  G_STYPE_DISPLAYLIST,          // a stream containing a 3D displaylist
  G_STYPE_IMAGE,                        // a stream containing image bits 
  G_STYPE_AUDIO,                        // a stream containing audio bits 
  G_STYPE_DATA,                         // a generic data stream 

} GStreamType_Enum;


class <a class="code" href="class_gstream.html">GStream</a> {
public:

        GStreamId  streamId; 

        GStreamType             streamType;

        const char *name;
        
        const char *mimeType;

        size_t size;    

        UINT32 priority;        

        UINT32 userData;

        <a class="code" href="class_gstream.html#a0">GStream</a>();
        virtual <a class="code" href="class_gstream.html#a1">~GStream</a>();


        virtual gbool <a class="code" href="class_gstream.html#a2">InitDescriptor</a>(GStreamType streamType, <a class="code" href="class_gmemmap.html">GMemMap</a> &amp;p);

        virtual gbool <a class="code" href="class_gstream.html#a3">InitStream</a>(size_t size,<a class="code" href="class_gmemmap.html">GMemMap</a> &amp;p);

        gbool <a class="code" href="class_gstream.html#a4">Init</a>();

        virtual gbool <a class="code" href="class_gstream.html#a5">AddPacket</a>(size_t size, void * data,gbool byRef);
        

        virtual void <a class="code" href="class_gstream.html#a6">Term</a>();

};

typedef UCHAR * GMemPtr;

class <a class="code" href="class_gmemmap.html">GMemMap</a> {
public:
        GMemPtr current;        

        GMemPtr base;           
        size_t  size;           

        GMemPtr <a class="code" href="class_gmemmap.html#a0">Base</a>() { return base; }
        GMemPtr <a class="code" href="class_gmemmap.html#a1">End</a>() { return base + size; }
        GMemPtr <a class="code" href="class_gmemmap.html#a2">Current</a>() { return current; }

        <a class="code" href="class_gmemmap.html#a3">GMemMap</a>(size_t size=0,void *data=NULL) {
                base = current = (GMemPtr) data;
                this-&gt;size = size;
        }               

        void <a class="code" href="class_gmemmap.html#a4">Reset</a>() { current = base; }
        gbool <a class="code" href="class_gmemmap.html#a5">Init</a>(size_t size,void *data) 
        {
                base = current = (GMemPtr) data;
                this-&gt;size = size;
                return (current != NULL);
        }

        void <a class="code" href="class_gmemmap.html#a6">Skip</a>(size_t size) 
        {
                current += size;
        }

        inline gbool <a class="code" href="class_gmemmap.html#a8">Verify</a>(GMemPtr p) {
                ASSERT( (p&gt;=base) &amp;&amp; (p &lt; (base + (size)))); 
                return ((p&gt;=base) &amp;&amp; (p &lt; (base + (size)))); 
        }

        inline gbool <a class="code" href="class_gmemmap.html#a8">Verify</a>() {
                return <a class="code" href="class_gmemmap.html#a8">Verify</a>(current);
        }

        inline USHORT <a class="code" href="class_gmemmap.html#a9">getUSHORT</a>() { return *((USHORT *&amp;)current)++; }
        inline USHORT <a class="code" href="class_gmemmap.html#a10">getCnt</a>() { return <a class="code" href="class_gmemmap.html#a9">getUSHORT</a>(); }
        inline USHORT <a class="code" href="class_gmemmap.html#a11">getIndex</a>() { return <a class="code" href="class_gmemmap.html#a9">getUSHORT</a>(); }
        inline UINT32 <a class="code" href="class_gmemmap.html#a12">getUINT32</a>() { return *((UINT32 *&amp;)current)++; }

        const char * <a class="code" href="class_gmemmap.html#a13">getString</a>() {
                size_t cnt= <a class="code" href="class_gmemmap.html#a9">getUSHORT</a>();
                const char* ret = (char *) current;
                current +=cnt;
                <a class="code" href="class_gmemmap.html#a14">align2</a>();
                return ret;

        }

        void <a class="code" href="class_gmemmap.html#a14">align2</a>() { if (((UINT) current) &amp; 1) current+=1; }
        void <a class="code" href="class_gmemmap.html#a15">align4</a>() { if (((UINT) current) &amp; 2) current+=2; }
        void <a class="code" href="class_gmemmap.html#a16">align8</a>() { }
        void <a class="code" href="class_gmemmap.html#a17">align16</a>() { }
        void <a class="code" href="class_gmemmap.html#a18">align32</a>() { }

        const float * <a class="code" href="class_gmemmap.html#a19">getFloats</a>(GDFloatEncoding encoding, size_t cnt, float *buffer) 
        {

                switch (encoding) {
                case GDF_FLOAT : { size_t s=cnt*sizeof(float);
                                                   <a class="code" href="class_gmemmap.html#a15">align4</a>(); 
                                                   // memcpy(buffer,current,s); 
                                                   float * tmp = (float *) current;
                                                   ((UINT32 *&amp;)current) +=s;
                                                   return tmp;  // avoid memcpy 

                                                 }
                case GDF_DOUBLE : { 
                                                   size_t s=cnt*sizeof(double);
                                                   <a class="code" href="class_gmemmap.html#a16">align8</a>(); 
                                                   const double *p= (const double *) current;
                                                   if (cnt&gt;0) 
                                                   do {
                                                          *buffer++ = *p++;     
                                                   } while (cnt--);        

                                                   ((UINT32 *&amp;)current) +=s;
                                                   
                                                   return buffer; 
                                                 }
                case GDF_SHORT : { 
                                                   size_t s=cnt*sizeof(SHORT);
                                                   const SHORT *p= (const SHORT *) current;
                                                   if (cnt&gt;0) 
                                                   do {
                                                          *buffer++ = *p++;     
                                                   } while (cnt--);        

                                                   ((UINT32 *&amp;)current) +=s;
                                                   
                                                   return buffer; 
                                                 }
                case GDF_FIX_8_8 : { 
                                                   size_t s=cnt*sizeof(SHORT);
                                                   const SHORT *p= (const SHORT *) current;
                                                   if (cnt&gt;0) 
                                                   do {
                                                          *buffer++ = <a class="code" href="gstream.h.html#a0">Fix8_8</a>(*p++);     
                                                   } while (cnt--);        

                                                   ((UINT32 *&amp;)current) +=s;
                                                   
                                                   return buffer; 
                                                 }

                case GDF_FIX_13_3 : { 
                                                   size_t s=cnt*sizeof(SHORT);
                                                   const SHORT *p= (const SHORT *) current;
                                                   if (cnt&gt;0) 
                                                   do {
                                                          *buffer++ = <a class="code" href="gstream.h.html#a1">Fix13_3</a>(*p++);    
                                                   } while (cnt--);        

                                                   ((UINT32 *&amp;)current) +=s;
                                                   
                                                   return buffer; 
                                                 }
                }
                return NULL;
        }


};

class <a class="code" href="class_gfilemap.html">GFileMap</a> : public <a class="code" href="class_gmemmap.html">GMemMap</a> {

protected:

    HANDLE hFile, hMapping;

public :
        
        <a class="code" href="class_gfilemap.html#a0">GFileMap</a>();

        <a class="code" href="class_gfilemap.html#a1">~GFileMap</a>();

        virtual gbool <a class="code" href="class_gmemmap.html#a5">Init</a>(LPCTSTR lpName);
        virtual void <a class="code" href="class_gfilemap.html#a3">Term</a>();

};

/*

  DescStream described the other streams occuring in the file

*/

class <a class="code" href="class_gstreamdescstream.html">GStreamDescStream</a> : public <a class="code" href="class_gstream.html">GStream</a>
{
        <a class="code" href="class_array.html">Array</a>&lt;<a class="code" href="class_gstream.html">GStream</a> *&gt; streams;  // list of stream


public:

        <a class="code" href="class_gstreamdescstream.html#a0">GStreamDescStream</a>();
        <a class="code" href="class_gstreamdescstream.html#a1">~GStreamDescStream</a>();

        inline int <a class="code" href="class_gstreamdescstream.html#a2">NumStreams</a>() const {return streams.<a class="code" href="class_array.html#a21">Length</a>(); }

        inline <a class="code" href="class_gstream.html">GStream</a> *<a class="code" href="class_gstreamdescstream.html#a3">GetStream</a>(int streamNum) { return streams[streamNum]; }

        virtual void <a class="code" href="class_gstreamdescstream.html#a4">AddStream</a>(UINT32  streamId,<a class="code" href="class_gstream.html">GStream</a>* s); 
        
        virtual void <a class="code" href="class_gstreamdescstream.html#a5">DeleteStream</a>(UINT32  streamId);
        
        virtual <a class="code" href="class_gstream.html">GStream</a> * <a class="code" href="class_gstreamdescstream.html#a6">NewStream</a>(GStreamType streamType);


        <a class="code" href="class_gstream.html">GStream</a> *<a class="code" href="class_gstreamdescstream.html#a7">GetStreamById</a>(UINT32 streamId);

        virtual gbool <a class="code" href="class_gstream.html#a5">AddPacket</a>(size_t size, void * data,gbool byRef);
        

        virtual void <a class="code" href="class_gstream.html#a6">Term</a>();
};


// ! basic operations 
typedef enum 
{ G_OP_NOP,
  G_OP_NEW,
  G_OP_DELETE,
  G_OP_APPEND,
  G_OP_REPLACE,

} G_STREAM_OP;



typedef enum 
{
        G_RS_MATERIAL,  // &lt;matId&gt; &lt;material&gt;
        
        G_RS_TEXTURE,   // &lt;id&gt; &lt;repeatS&gt; &lt;repeatT&gt; &lt;streamId&gt;

        G_RS_TEXTURE_TRANSFORM, // &lt;matId&gt;  &lt;type&gt;  &lt;data&gt;
        
        G_RS_APPEARANCE,        // &lt;appId&gt;  &lt;matId&gt; &lt;texId&gt; &lt;texTransformId&gt;

        G_RS_COLOR,             // &lt;ColorId&gt; &lt;floatEncoding&gt; &lt;cnt&gt; &lt;float3data&gt;
        G_RS_COORD,             // &lt;CoordId&gt; &lt;floatEncoding&gt; &lt;cnt&gt; &lt;float3data&gt;
        G_RS_NORMAL,    // &lt;NormalId&gt; &lt;floatEncoding&gt; &lt;cnt&gt; &lt;float3data&gt;
        G_RS_TEX_COORD, // &lt;TexCoordId&gt; &lt;floatEncoding&gt; &lt;cnt&gt; &lt;float2data&gt;
        
        G_RS_VERTEX_BUFFER,     // &lt;VbId&gt; &lt;indexEncoding&gt; &lt;cnt&gt; ( &lt;ColorId&gt; &lt;CoordId&gt;&lt;NormalId&gt;&lt;TexCoordid0..n&gt;
        
        G_RS_AUDIO_CLIP,        // &lt;AudioId&gt; &lt;streamId&gt;
        G_RS_WHICH_CHOICE,      // &lt;intEncoding&gt; &lt;cnt&gt; &lt;ints&gt;

} G_RS_STREAM_SUBTYPE;


/*  Resource stream data :

        &lt;Op&gt; &lt;RsStreamSubType&gt; &lt;subTypeData&gt;

        op == replace append 

*/


#endif _gstream_h

</div></pre><hr><address><small>Generated at Thu Jan 27 18:46:33 2000 for blaxxunContact3D by
<a href="http://www.stack.nl/~dimitri/doxygen/index.html">
<img src="doxygen.gif" alt="doxygen" align=center border=0 
width=118 height=53></a> 1.0.0 written by <a href="mailto:dimitri@stack.nl">Dimitri van Heesch</a>,
 &copy; 1997-1999</small></address>
</body>
</html>

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta name="robots" content="noindex">
<title>GTime Include File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body bgcolor="#ffffff">
<!-- Generated by Doxygen 1.0.0 on Thu Jan 27 18:46:49 2000 -->
<center>
<a class="qindex"href="index.html">Main Page</a> &nbsp; <a class="qindex"href="namespaces.html">Namespace List</a> &nbsp; <a class="qindex"href="hierarchy.html">Class Hierarchy</a> &nbsp; <a class="qindex"href="annotated.html">Compound List</a> &nbsp; <a class="qindex"href="files.html">File List</a> &nbsp; <a class="qindex"href="headers.html">Header Files</a> &nbsp; <a class="qindex"href="namespacemembers.html">Namespace Members</a> &nbsp; <a class="qindex"href="functions.html">Compound Members</a> &nbsp; <a class="qindex"href="globals.html">File Members</a> &nbsp; </center>
<hr><h1>gclass.h</h1>This is the verbatim text of the gclass.h include file.<div class="fragment"><pre>/*=============================================================================

This code is licensed under the Web3D-blaxxun Community Source License,
provided in distribution file LICENSE.TXT and available online at
http://www.web3D.org/TaskGroups/x3d/blaxxun/Web3D-blaxxunCommunitySourceAgreement.html
and may only be used for non-commercial use as specified in that license.

THE WEB3D CONSORTIUM AND BLAXXUN DO NOT MAKE AND HEREBY DISCLAIM ANY EXPRESS
OR IMPLIED WARRANTIES RELATING TO THIS CODE, INCLUDING BUT NOT LIMITED TO,
WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY OR FITNESS FOR A PARTICULAR
PURPOSE, OR ANY WARRANTIES THAT MIGHT ARISE FROM A COURSE OF DEALING, USAGE
OR TRADE PRACTICE.  THE COMMUNITY SOURCE CODE IS PROVIDED UNDER THIS
AGREEMENT "AS IS," WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
INCLUDING, WITHOUT LIMITATION, WARRANTIES THAT THE COMMUNITY SOURCE CODE ARE
FREE OF DEFECTS, MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE OR
NON-INFRINGING OR IN ANY WAY CONSTITUTE THE COMPLETE PRODUCT MARKETED UNDER
THE NAMES GIVEN SAID CODE.

==============================================================================*/
#ifndef _GCLASS_H
#define _GCLASS_H

/******************************************************************************
@doc

@module GClass.h -  BasicNode, Node Traversal,  Traversal State classes|

Copyright (c) 1995 - 1998 by Holger Grahn
All rights reserved

Purpose:

Classes:

Notes:

  The traversal code is based on an abstract GNode class, 
not requiring any VRML specific classes.
The Traversal objects are referring in the Do(Node) Method the virtual function invoked
on the nodes.

GvNode is the root class for VRML nodes

Changes:

$Revision: 1.18 $
$Log: gclass.h,v $
Revision 1.18  1998/08/20 17:21:54  holger
empty message



Todo :

******************************************************************************/


#define _GDEBUG

// non VRML scene tree stuff
#ifdef _GLVIEW_IE
        #undef _GFULL
#else
        #define _GFULL
#endif



class <a class="code" href="class_point.html">Point</a>;

class <a class="code" href="class_gnode.html">GNode</a>;

#ifdef _GFULL
class   <a class="code" href="class_gattributenode.html">GAttributeNode</a>;
class           <a class="code" href="class_ggroup.html">GGroup</a>;
class   <a class="code" href="class_ggeometry.html">GGeometry</a>;
class           <a class="code" href="class_ginstance.html">GInstance</a>;

class   <a class="code" href="class_gattribute.html">GAttribute</a>;
class           <a class="code" href="class_gstyle.html">GStyle</a>;
class           <a class="code" href="class_gmatrix.html">GMatrix</a>;
class           <a class="code" href="class_gbbox.html">GBBox</a>;
#endif

class   GStackAttribute;

class   <a class="code" href="class_gtraversal.html">GTraversal</a>;
class           <a class="code" href="class_ggeometrytraversal.html">GGeometryTraversal</a>;
class                   <a class="code" href="class_gpathtraversal.html">GPathTraversal</a>;
class                           <a class="code" href="class_grayselecttraversal.html">GRaySelectTraversal</a>;    // implemented in GRaySelect.cpp
class                           <a class="code" href="class_gfindnodetraversal.html">GFindNodeTraversal</a>;             // implemented in GFindNode.cpp
class                   <a class="code" href="class_gbboxtraversal.html">GBBoxTraversal</a>;
class                   <a class="code" href="class_gglrendertraversal.html">GglRenderTraversal</a>;
class                           <a class="code" href="class_ggltransparencyrendertraversal.html">GglTransparencyRenderTraversal</a>;
class       GD3DRenderTraversal;

class           <a class="code" href="class_giotraversal.html">GioTraversal</a>;
class                   <a class="code" href="class_gpoviotraversal.html">GPovIoTraversal</a>;

// some more
class           <a class="code" href="class_gbuildshelltraversal.html">GBuildShellTraversal</a>;   // implemented in GBuildShell.cpp
class           <a class="code" href="class_goptimizetraversal.html">GOptimizeTraversal</a>;     // implemented in GOptimizeTraversal.cpp
class           GVrml2ConvertTraversal; // implemented in GvVrml2Convert.cpp

class           <a class="code" href="class_gloadinlinestraversal.html">GLoadInlinesTraversal</a>;  // implemented in qvTraverse.cpp

class           <a class="code" href="class_gdisplaytreetraversal.html">GDisplayTreeTraversal</a>;  // implemented in GDisplayTree.cpp

//class         GStatisticsTraversal;


class   GProperty;
class           GFloatProperty;

#ifdef _GFULL
class <a class="code" href="class_gworld.html">GWorld</a>;
#endif


class <a class="code" href="class_gcamera.html">GCamera</a>;
class <a class="code" href="class_gviewinfo.html">GViewInfo</a>;

// for one level qv attributes
class <a class="code" href="class_gvnode.html">GvNode</a>;
class <a class="code" href="class_gvfield.html">GvField</a>;

class <a class="code" href="class_gvshape.html">GvShape</a>;
class <a class="code" href="class_gvappearance.html">GvAppearance</a>;
class <a class="code" href="class_gv2material.html">Gv2Material</a>;
class GvMaterial;
class <a class="code" href="class_gvtexture.html">GvTexture</a>;
class <a class="code" href="class_gv2texturetransform.html">Gv2TextureTransform</a>;

class <a class="code" href="class_gvdict.html">GvDict</a>;
class <a class="code" href="class_gvsfvec3f.html">GvSFVec3f</a>;





#ifdef _GFULL

// Activity Bits, to tell system what to do on next update cycle
enum GActivity {
                GRedraw=1,                      // Redraw this element
                GRedrawSome=2,          // There are childs, to redraw
                GEvaluate=4,            // Evaluate this element
                GEvaluateSome=8,        // There are childs to evaluate
                GMarked=16                      // A Marker
                // GEvaluateBBox

        };
/*
  GRedraw at group means, redraw all childs
*/


// Action indicators, so that object can react
enum GAction {
//      GGeometryAdded,
//      GGeometryDeleted,
        GGeometryChanged,
        GGeometryMovedOut,
        GGeometryMovedIn,
        GGroupAdded,
        GGroupDeleted,
        GAttributeAdded,
        GAttributeDeleted,
        GAttributeChanged
        };

// object type id´s 
// to do: use RTTI
enum GId {
        GIdGroup=1,
        GIdInstance,
        GIdStyle,
        GIdMatrix,      /* Modelling Matrix Attribute */ 
        GIdBBox,        /* Boundingbox Attribute */

};
#endif

//
// GStackableAttribute
// traversal state attribute, to support push and pop of states

class <a class="code" href="class_gstackableattribute.html">GStackableAttribute</a> : public <a class="code" href="class_rtroot.html">RTRoot</a>
{
public:
        <a class="code" href="class_gvnode.html#a0">RT</a>(<a class="code" href="class_gstackableattribute.html">GStackableAttribute</a>);
        int level; // the tree-level this attribute was pushed
        
        <a class="code" href="class_gstackableattribute.html">GStackableAttribute</a> *prev;  // prev element in States attribute stack
        <a class="code" href="class_gstackableattribute.html">GStackableAttribute</a> *prevThisAttr;  // prev element in States attribute stack of same class
        
        static int attrIdCounter; // Global for assigning new attributed id to StackableAttributes
        
        // allocate a new attribute id
        static int <a class="code" href="class_gstackableattribute.html#d0">GetNewAttrId</a>() { return(attrIdCounter++); }

#ifdef WIN32

        static CRITICAL_SECTION section;  
        static void <a class="code" href="class_gstackableattribute.html#d1">Lock</a>() { EnterCriticalSection(&amp;section); }
        static void <a class="code" href="class_gstackableattribute.html#d2">Unlock</a>() { LeaveCriticalSection(&amp;section); }

        static void <a class="code" href="class_gstackableattribute.html#d3">InitClass</a>() { InitializeCriticalSection(&amp;section); }

#else
    static void <a class="code" href="class_gstackableattribute.html#d1">Lock</a>() {}
    static void <a class="code" href="class_gstackableattribute.html#d2">Unlock</a>() {}

    static void <a class="code" href="class_gstackableattribute.html#d3">InitClass</a>() {}

#endif

        static void <a class="code" href="class_gstackableattribute.html#d4">TermClass</a>() { }

        // get attribute id number
        virtual int <a class="code" href="class_gstackableattribute.html#a1">AttrId</a>() = 0;
        
        // assign attribute id number (only one time initialization)
        virtual void <a class="code" href="class_gstackableattribute.html#a2">SetAttrId</a>(int newAttrId) = 0;

        // this attribute instance is made current == top level value
        virtual void <a class="code" href="class_gstackableattribute.html#a3">Set</a>(<a class="code" href="class_gtraversal.html">GTraversal</a> &amp; /* state*/ ) {};
        
        // allocate a new instance of this attribute
        virtual <a class="code" href="class_gstackableattribute.html">GStackableAttribute</a>* <a class="code" href="class_gstackableattribute.html#a4">NewInstance</a>() = 0;

        // function to construct/reinit  element from freelist
        void <a class="code" href="class_gstackableattribute.html#a5">Init</a>() { }


        // free current instance
        virtual void  <a class="code" href="class_gstackableattribute.html#a6">FreeInstance</a>() = 0;

        friend class <a class="code" href="class_gtraversal.html">GTraversal</a>;

};


/*
   each attribute Stack element has a unique identification
   id, maintained as a static element
   each element has a freelist, 
   CLASS::NewInstance allocates, FreeInstance "frees"
*/
#define GSTACKABLE_ATTRIBUTE(CLASS) \
                <a class="code" href="rt.h.html#a3">RT</a>(CLASS);      \
                static int attrId;\
                static CLASS *freeList; \
                virtual int AttrId(); \
                virtual void SetAttrId(int newAttrId);  \
                virtual <a class="code" href="class_gstackableattribute.html">GStackableAttribute</a>* NewInstance(); \
                static CLASS* NewElement(); \
                virtual void FreeInstance(); \
                static void FreeClass();

// TBD: Rethink freelist could cause problems in MT environment,

#define GSTACKABLE_ATTRIBUTE_IMP(CLASS,ROOT) \
                <a class="code" href="rt.h.html#a4">RTIMP</a>(CLASS,0,ROOT);    \
                int CLASS::attrId = 0; \
                CLASS * CLASS::freeList = NULL; \
                int CLASS::AttrId() { return(CLASS::attrId); } \
                void CLASS::SetAttrId(int newAttrId) { CLASS::attrId = newAttrId; } \
                <a class="code" href="class_gstackableattribute.html">GStackableAttribute</a>* CLASS::NewInstance() {  \
                                Lock();  \
                                if (freeList) {CLASS *f= freeList; freeList = (CLASS *) f-&gt;prev; f-&gt;Init(); Unlock(); return(f); } \
                                Unlock(); \
                                return new CLASS ;  \
                }; \
                CLASS* CLASS::NewElement() {  \
                                Lock();  \
                                if (freeList) { CLASS *f= freeList; freeList = (CLASS *) f-&gt;prev; f-&gt;Init(); Unlock(); return(f); } \
                                Unlock(); \
                                return new CLASS ;  \
                }; \
                void CLASS::FreeInstance() { Lock(); this-&gt;prev = freeList; freeList = this; Unlock();}; \
                void CLASS::FreeClass() { Lock();   while (freeList) { CLASS * n= (CLASS *) freeList-&gt;prev; delete freeList; freeList=n; } Unlock(); };




#define GSTACKABLE_DERIVED_ATTRIBUTE(CLASS) \
                <a class="code" href="rt.h.html#a3">RT</a>(CLASS);      \
                static CLASS *freeList; \
                virtual <a class="code" href="class_gstackableattribute.html">GStackableAttribute</a>* NewInstance(); \
                static CLASS* NewElement(); \
                virtual void FreeInstance(); \
                static void FreeClass();

#define GSTACKABLE_DERIVED_ATTRIBUTE_IMP(CLASS,ROOT) \
                <a class="code" href="rt.h.html#a4">RTIMP</a>(CLASS,0,ROOT);    \
                CLASS * CLASS::freeList = NULL; \
                <a class="code" href="class_gstackableattribute.html">GStackableAttribute</a>* CLASS::NewInstance() {  \
                                Lock();  \
                                if (freeList) {CLASS *f= freeList; freeList = (CLASS *) f-&gt;prev; f-&gt;Init(); Unlock(); return(f); } \
                                Unlock(); \
                                return new CLASS ;  \
                }; \
                CLASS* CLASS::NewElement() {  \
                                Lock();  \
                                if (freeList) {  CLASS *f=freeList; freeList = (CLASS *) f-&gt;prev; f-&gt;Init(); Unlock(); return(f); } \
                                Unlock(); \
                                return new CLASS;  \
                }; \
                void CLASS::FreeInstance() { Lock(); this-&gt;prev = freeList; freeList = this; Unlock(); }; \
                void CLASS::FreeClass() { Lock(); while (freeList) { CLASS * n= (CLASS *) freeList-&gt;prev; delete freeList; freeList=n; } Unlock(); };




class <a class="code" href="class_gview.html">GView</a>;
class <a class="code" href="class_cmyglview.html">CMyglView</a>;

//
// GPathElement
// a path store a path through a scene tree to a specific node
//
class <a class="code" href="class_gpathelement.html">GPathElement</a> {
public:
        <a class="code" href="class_gnode.html">GNode</a> *node;            // node
        <a class="code" href="class_gpathelement.html">GPathElement</a> *next;      // linked list, for easy push

        <a class="code" href="class_gvfield.html">GvField</a> *field;         // field of node 
        int index;                      // optional index in field
        void *data;                     // optional  user data 

        <a class="code" href="class_gpathelement.html#a0">GPathElement</a>(<a class="code" href="class_gnode.html">GNode</a> *<a class="code" href="class_node.html">Node</a>,<a class="code" href="class_gpathelement.html">GPathElement</a> *Next, <a class="code" href="class_gvfield.html">GvField</a> *<a class="code" href="class_field.html">Field</a>=NULL,int Index=-1,void *Data=NULL) :
                node(<a class="code" href="class_node.html">Node</a>), next(Next), field(<a class="code" href="class_field.html">Field</a>),index(Index),data(Data)
                { }

        // is this node in path ?
        // gbool IsInPath(GvNode *n);
};

//
//
//


class <a class="code" href="class_gpath.html">GPath</a> : public <a class="code" href="class_stack.html">Stack</a>&lt;GPathElement&gt;
{
public :
//      GPath(int initSíze=30) : Stack&lt;GPathElement&gt;(initSize) { };
//      ~GPath() {} ;

};


// special result codes from Traverse()
#define GV_NODE_ALREADY_SEEN 2
#define GV_NODE_CULLED -1

//
// GTraversal
// A Traversal applies action to whole tree
// root for all specialised traversal actions
//

class <a class="code" href="class_gtraversal.html">GTraversal</a> : public <a class="code" href="class_rtroot.html">RTRoot</a> {

    // state for all attributes
public:


        <a class="code" href="class_gvnode.html#a0">RT</a>(<a class="code" href="class_gtraversal.html">GTraversal</a>);

        // Top attribute pointer, index by AttrId
        <a class="code" href="class_array.html">Array</a>&lt;<a class="code" href="class_gstackableattribute.html">GStackableAttribute</a>*&gt; current;

        // the attribute stack, elements linked together by prev field to form stack
        <a class="code" href="class_gstackableattribute.html">GStackableAttribute</a> *top;

        <a class="code" href="class_gvappearance.html">GvAppearance</a> *defaultAppearance; // appearance if appearance field is NULL
        <a class="code" href="class_gv2material.html">Gv2Material</a> *defaultMaterial; // material if apperance material is NULL (part of defaultAppearance)
        <a class="code" href="class_gv2texturetransform.html">Gv2TextureTransform</a> *defaultTextureTransform; // textureTransform if apperance textureTransform is NULL (part of defaultAppearance)

        GvMaterial *defaultMaterial10; // default / top-level VRML 1.0 material 

        gbool globalPointLights; // treat Point &amp; Spotlight global, has been set up at higher level
        gbool needShapes;               // do we need the expanded sehll geometry 

        gbool appearanceApplied; // 1 : apperance has been applied to rendering pipeline
        gbool initScripts;              // init any scripts not yet initialized 

        //static, one level VRML 2.0 attributes
        <a class="code" href="class_gvappearance.html">GvAppearance</a> *appearance; // current appearance

        <a class="code" href="class_gvshape.html">GvShape</a> *shape; // current leaf shape
        
        <a class="code" href="class_gv2material.html">Gv2Material</a> *material; // current applied appearance material

        int materialStatus;     // MATERIAL_STATUS_FLAGS 
        <a class="code" href="class_gvtexture.html">GvTexture</a> *texture; // current applied appearance texture

        int textureStatus;      // TEXTURE_STATUS_FLAGS 
        <a class="code" href="class_gv2texturetransform.html">Gv2TextureTransform</a> *textureTransform; // current applied appearance textureTransform

        // ShapeHints / culling params, needed for GRaySelectTraversal
        gbool solid;            // true: do culling, false no culling 
        gbool cw;               // true: faces are cw, false faces are ccw      
        
        // set static culling attributes 
        void <a class="code" href="class_gtraversal.html#a1">SetCulling</a>(gbool Solid, gbool Cw) { solid = Solid; cw = Cw; }

        
        <a class="code" href="class_gvnode.html">GvNode</a> *owner; // misc

        <a class="code" href="class_gvdict.html">GvDict</a> *nodeDict;  // helper dict to mark nodes etc 

        void <a class="code" href="class_gtraversal.html#a2">ClearStaticAttributes</a>() {

                appearance =  NULL; // (GvAppearance *) -1; // really set to invalid value 
                appearanceApplied = gfalse;
                initScripts = gtrue;
                shape = (<a class="code" href="class_gvshape.html">GvShape</a>*) -1;
                material = (<a class="code" href="class_gv2material.html">Gv2Material</a>*) -1;
                materialStatus = 0;
                texture = (<a class="code" href="class_gvtexture.html">GvTexture</a>*) -1;
                textureTransform = (<a class="code" href="class_gv2texturetransform.html">Gv2TextureTransform</a>*) -1;
                textureStatus = 0;
                owner = NULL;
                solid=gtrue; 
                cw=gfalse;

        }

        int level;                      // current tree traversal level
        int maxLevel;           // max traveral depth 

        int inlineLevel;         // current loading level
        int maxInlineLevel;  // max depth to load
        int inlineWwwFlags;      // flags for WWW Operation 
        int stop;                       // abort traveral


        gbool traverseAll;      // uncoditionally traverse ALL nodes
        gbool traverseTransformHierarchyOnly;   // if traverseAll, traverse only all in transform hierarchy 
        gbool loadInThread; // load inlines in thread 
        
        int notInTransformHierarchy; // if (&gt;0) currently traversed scene graph not part of transform hierarchy
        
        
        enum LoadMode {
                DONT_LOAD,              
                LOAD_FIRST,             
                LOAD_IF_NEEDED, 
                LOAD_ALL                
        };

        LoadMode loadInlines;   // loading flags for diffent sub media
        LoadMode loadTextures;
        LoadMode loadMovies;    //
        LoadMode loadSounds;
        LoadMode loadProtos;    // 

        int pendingLoads;       

        <a class="code" href="class_gview.html">GView</a> *view;            
        <a class="code" href="class_cmyglview.html">CMyglView</a> *myglView;// ptr to CMyglView if needed
        
        <a class="code" href="class_gview.html">GView</a> *<a class="code" href="class_gvnode.html#a1">getBrowser</a>() { return view; }


        virtual const char* <a class="code" href="class_gtraversal.html#a4">GetUrl</a>(CTime &amp;childrenRefreshTime); // implemented in GvTraverse.cpp
        virtual const char* <a class="code" href="class_gtraversal.html#a5">GetHomeUrl</a>();


        gbool attributesInitialized;    

        <a class="code" href="class_gpathelement.html">GPathElement</a> *topPath;

        <a class="code" href="class_gstackableattribute.html">GStackableAttribute</a>* <a class="code" href="class_gtraversal.html#a6">Get</a>(int attributeId) const { 
                if (attributeId &gt;= current.<a class="code" href="class_array.html#a21">Length</a>()) return NULL;
                return(current[attributeId]);
        }
        
        void <a class="code" href="class_gtraversal.html#a7">SetCurrent</a>(int attributeId,<a class="code" href="class_gstackableattribute.html">GStackableAttribute</a>* attr) { current[attributeId] = attr; };
        
        int <a class="code" href="class_gtraversal.html#a8">Pushed</a>(int attributeId) const { return current[attributeId]-&gt;level &gt;= level; };

        void <a class="code" href="class_array.html#a11">Set</a>(<a class="code" href="class_gstackableattribute.html">GStackableAttribute</a>* attr);


        void <a class="code" href="class_stack.html#a8">Pop</a>(<a class="code" href="class_gstackableattribute.html">GStackableAttribute</a> *attr) {
                        if (!attr) return; // trace should not occure
                        top = attr-&gt;prev;
                        <a class="code" href="class_gtraversal.html#a7">SetCurrent</a>(attr-&gt;<a class="code" href="class_gstackableattribute.html#a1">AttrId</a>(),attr-&gt;prevThisAttr);
                        if (attr-&gt;prevThisAttr) attr-&gt;prevThisAttr-&gt;<a class="code" href="class_array.html#a11">Set</a>(*this);
                        //delete attr;
                        attr-&gt;<a class="code" href="class_gstackableattribute.html#a6">FreeInstance</a>();
        }
        
        void <a class="code" href="class_stack.html#a5">Push</a>(<a class="code" href="class_gstackableattribute.html">GStackableAttribute</a> *newTop) {
                                <a class="code" href="class_stack.html#a5">Push</a>(newTop -&gt;AttrId(),newTop);
                         };

        void <a class="code" href="class_stack.html#a5">Push</a>(int id,<a class="code" href="class_gstackableattribute.html">GStackableAttribute</a> *newTop) {
                        newTop-&gt;prev = top;
                        newTop-&gt;prevThisAttr = <a class="code" href="class_gtraversal.html#a6">Get</a>(id);
                        newTop-&gt;level = level;  // store level
                        if (newTop-&gt;prevThisAttr == 0) {
                          //TRACE("Error: %s::Push attribute %s not initialized \n",this-&gt;ClassName(),newTop-&gt;ClassName());
                          //delete newTop;
                                newTop-&gt;<a class="code" href="class_gstackableattribute.html#a6">FreeInstance</a>();
                        } else {
                          
                          //TRACE("%s::Push  %s prev %s  \n",this-&gt;ClassName(),newTop-&gt;ClassName(),newTop-&gt;prevThisAttr-&gt;ClassName());
                          top = newTop;
                          <a class="code" href="class_gtraversal.html#a7">SetCurrent</a>(id,newTop);
                          newTop-&gt;<a class="code" href="class_gstackableattribute.html#a3">Set</a>(*this);
                        }
        }

        // constructor
        <a class="code" href="class_gtraversal.html#a13">GTraversal</a>();
        <a class="code" href="class_gtraversal.html#a14">~GTraversal</a>();

        int <a class="code" href="class_gtraversal.html#a15">Level</a>() const { return (level); }
        
        void <a class="code" href="class_stack.html#a5">Push</a>() { 
                        level++; 
        //              TRACE("Push %d (\n",level);
        }


        void <a class="code" href="class_stack.html#a8">Pop</a>() {
//                      TRACE("Pop %d )\n",level);
                while (top &amp;&amp; (top-&gt;level&gt;= level)) { 
                                        //TRACE("\tpopping attribute %s\n",top-&gt;ClassName());
                                        <a class="code" href="class_stack.html#a8">Pop</a>(top);
                         }
                         level --;
                }


        // virtual ovverrides
        virtual int <a class="code" href="class_gv2group.html#a12">Do</a>(<a class="code" href="class_gnode.html">GNode</a> *n);


#ifdef _GFULL
        virtual int <a class="code" href="class_gv2group.html#a12">Do</a>(<a class="code" href="class_ggeometry.html">GGeometry</a> *n);
        
        virtual int <a class="code" href="class_gv2group.html#a12">Do</a>(<a class="code" href="class_ggroup.html">GGroup</a> *n);
        virtual int <a class="code" href="class_gtraversal.html#a21">EndDo</a>(<a class="code" href="class_ggroup.html">GGroup</a> *n);

        virtual int <a class="code" href="class_gv2group.html#a12">Do</a>(<a class="code" href="class_gattribute.html">GAttribute</a> *<a class="code" href="class_a.html">a</a>);
        virtual int <a class="code" href="class_gtraversal.html#a21">EndDo</a>(<a class="code" href="class_gattribute.html">GAttribute</a> *<a class="code" href="class_a.html">a</a>);
#endif


        virtual void <a class="code" href="class_gtraversal.html#a24">InitializeAttributes</a>(); 

};

// build a linked list/stack during traversal
// to get the path to the current node 
#define GPUSH_PATH(state,me) \
{\
        <a class="code" href="class_gpathelement.html">GPathElement</a> __newTop(me,state.topPath);\
        state.topPath = &amp;__newTop

#define GPOP_PATH(state) \
        state.topPath = __newTop.next; \
} 

#define GSET_PATH_FIELD(state,Field) \
        state.topPath-&gt;field = &amp;<a class="code" href="class_field.html">Field</a>;

#define GSET_PATH_INDEX(state,Index) \
        state.topPath-&gt;index = Index;

#define GSET_PATH_DATA(state,Data) \
        state.topPath-&gt;data = Data;

//
// GNode
// The root for all Objects in Scene Tree
// defines a list of virtual functions, which can be overridden for spcecial traversal action
class <a class="code" href="class_gnode.html">GNode</a> : public <a class="code" href="class_rtroot.html">RTRoot</a> {
public :   
        <a class="code" href="class_gvnode.html#a0">RT</a>(<a class="code" href="class_rtroot.html">RTRoot</a>);


        <a class="code" href="class_gnode.html#a1">GNode</a>() {};

        // define virtual actions
        virtual <a class="code" href="class_gnode.html#a2">~GNode</a>() {};

        int <a class="code" href="class_gvnode.html#a41">Traverse</a>(<a class="code" href="class_gtraversal.html">GTraversal</a> &amp;state);

        // predefined virtual Traversal actions

        // generic traverseal
        virtual int <a class="code" href="class_gv2group.html#a12">Do</a>(<a class="code" href="class_gtraversal.html">GTraversal</a> &amp;state);  
        
        // Default action for predefined derived actions 
        // is to pass control to Do(GTraversal&amp;)
        // compute bounding box 
        virtual int <a class="code" href="class_gv2group.html#a12">Do</a>(<a class="code" href="class_gbboxtraversal.html">GBBoxTraversal</a> &amp;state)       { return <a class="code" href="class_gv2group.html#a12">Do</a>(*(<a class="code" href="class_gtraversal.html">GTraversal</a> *) &amp; state); } 
#if 0
        virtual int <a class="code" href="class_gv2group.html#a12">Do</a>(<a class="code" href="class_gglrendertraversal.html">GglRenderTraversal</a> &amp;state)   { return <a class="code" href="class_gv2group.html#a12">Do</a>(*(<a class="code" href="class_gtraversal.html">GTraversal</a> *) &amp; state); } 
#else
        virtual int <a class="code" href="class_gv2group.html#a12">Do</a>(<a class="code" href="class_gglrendertraversal.html">GglRenderTraversal</a> &amp;state);
#endif

        virtual int <a class="code" href="class_gv2group.html#a12">Do</a>(<a class="code" href="class_ggltransparencyrendertraversal.html">GglTransparencyRenderTraversal</a> &amp;state)  { return <a class="code" href="class_gv2group.html#a12">Do</a>(*(<a class="code" href="class_gglrendertraversal.html">GglRenderTraversal</a> *) &amp; state); } 

        virtual int <a class="code" href="class_gv2group.html#a12">Do</a>(GD3DRenderTraversal &amp;state)   { return <a class="code" href="class_gv2group.html#a12">Do</a>(*(<a class="code" href="class_gtraversal.html">GTraversal</a> *) &amp; state);} 

        virtual int <a class="code" href="class_gv2group.html#a12">Do</a>(<a class="code" href="class_giotraversal.html">GioTraversal</a> &amp;state);            // implemented in GioTraversal.cpp 
        virtual int <a class="code" href="class_gv2group.html#a12">Do</a>(<a class="code" href="class_gpoviotraversal.html">GPovIoTraversal</a> &amp;state);         // implemented in GioTraversal.cpp 
        virtual int <a class="code" href="class_gv2group.html#a12">Do</a>(<a class="code" href="class_gbuildshelltraversal.html">GBuildShellTraversal</a> &amp;state);// implemented in GBuildShell.cpp
        virtual int <a class="code" href="class_gv2group.html#a12">Do</a>(<a class="code" href="class_goptimizetraversal.html">GOptimizeTraversal</a> &amp;state);      // implemented in GOptimizeTraversal.cpp

        virtual int <a class="code" href="class_gv2group.html#a12">Do</a>(<a class="code" href="class_gpathtraversal.html">GPathTraversal</a> &amp;state); // implemented in GRaySelect.cpp

        virtual int <a class="code" href="class_gv2group.html#a12">Do</a>(<a class="code" href="class_grayselecttraversal.html">GRaySelectTraversal</a> &amp;state); // implemented in GRaySelect.cpp

        virtual int <a class="code" href="class_gv2group.html#a12">Do</a>(<a class="code" href="class_gloadinlinestraversal.html">GLoadInlinesTraversal</a> &amp;state);// implemented in qvTraverse.cpp

        virtual int <a class="code" href="class_gv2group.html#a12">Do</a>(<a class="code" href="class_gdisplaytreetraversal.html">GDisplayTreeTraversal</a> &amp;state); // implemented in GDisplayTree.cpp
        
        virtual int <a class="code" href="class_gv2group.html#a12">Do</a>(GVrml2ConvertTraversal &amp;state)   { return <a class="code" href="class_gv2group.html#a12">Do</a>(*(<a class="code" href="class_gtraversal.html">GTraversal</a> *) &amp; state);} 

        // IO 
        virtual int <a class="code" href="class_gnode.html#a18">io</a>(<a class="code" href="class_astream.html">AStream</a> &amp;<a class="code" href="class_a.html">a</a>);

};

#ifdef _GFULL
//
// ROOT for non VRML based scene graph
//

class <a class="code" href="class_gbasenode.html">GBaseNode</a> : public <a class="code" href="class_gnode.html">GNode</a> 
{
public :

        <a class="code" href="class_gnode.html#a0">RT</a>(<a class="code" href="class_gbasenode.html">GBaseNode</a>);
        <a class="code" href="class_gattribute.html">GAttribute</a> *attributes;         // Points to first attribute

        <a class="code" href="class_gbasenode.html#a1">GBaseNode</a>() : <a class="code" href="class_gnode.html">GNode</a>()  { };


        // stuff not needed for VRML nodes
        <a class="code" href="class_gnode.html">GNode</a> *next;
        int id;         // Object Id: to do use RTTI

        virtual int <a class="code" href="class_gbasenode.html#a2">IsAttribute</a>() ;
        virtual int <a class="code" href="class_gbasenode.html#a3">IsGeometry</a>() ;
        virtual int <a class="code" href="class_gbasenode.html#a4">IsGroup</a>() ;
        
        // what actions need to be performed on next update
        unsigned int activity;
        
        void <a class="code" href="class_gbasenode.html#a5">AddActivity</a>(unsigned int newActivity) { activity |= newActivity; }
        void <a class="code" href="class_gbasenode.html#a6">ClearActivity</a>() { activity = 0; }

        int  <a class="code" href="class_gbasenode.html#a7">IsMarked</a>() { return(activity &amp; GMarked); }
        int  <a class="code" href="class_gbasenode.html#a8">Mark</a>() { return(activity |= GMarked); }
        int  <a class="code" href="class_gbasenode.html#a9">UnMark</a>() { return(activity &amp;= ~GMarked); }

        void <a class="code" href="class_gbasenode.html#a10">SetId</a>(int Id) { id = Id; }

        virtual int <a class="code" href="class_gbasenode.html#a11">Propagate</a>(unsigned int newActivity);




};
//
// GAttributeNode
// a node with a optioanal list of attributes
// traverse would push and pop the attributes
// not used for VRML 

class <a class="code" href="class_gattributenode.html">GAttributeNode</a> : public <a class="code" href="class_gbasenode.html">GBaseNode</a>  {
public :
        <a class="code" href="class_gbasenode.html#a0">RT</a>(<a class="code" href="class_gnode.html">GNode</a>);
        <a class="code" href="class_gattribute.html">GAttribute</a> *attributes;         // Points to first attribute

        <a class="code" href="class_gattributenode.html#a1">GAttributeNode</a>() : <a class="code" href="class_gbasenode.html">GBaseNode</a>() 
                                { 
                                 attributes = NULL; 
                                };
        <a class="code" href="class_gattributenode.html#a2">~GAttributeNode</a>();
        int <a class="code" href="class_gattributenode.html#a3">HasAttributes</a>() { return (attributes != NULL); }

        // set a Attribute and take control over node
        void <a class="code" href="class_array.html#a11">Set</a>(<a class="code" href="class_gattribute.html">GAttribute</a>  *AttributeNode);
        
        // UnSet attribute with id Id
        // if found delete it and notify and return 1
        // else return 0

        int  <a class="code" href="class_gattributenode.html#a5">UnSet</a>(GId Id);

        <a class="code" href="class_gattribute.html">GAttribute</a> * <a class="code" href="class_gattributenode.html#a6">FindAttribute</a>(GId Id);
        void <a class="code" href="class_gattributenode.html#a7">DeleteAttributes</a>();
        virtual int <a class="code" href="class_gattributenode.html#a8">Notify</a>(GAction action, <a class="code" href="class_gattribute.html">GAttribute</a> *n);

        int <a class="code" href="class_gnode.html#a3">Traverse</a>(<a class="code" href="class_gtraversal.html">GTraversal</a> &amp;state,int mode);

        // IO 
        virtual int <a class="code" href="class_gnode.html#a18">io</a>(<a class="code" href="class_astream.html">AStream</a> &amp;<a class="code" href="class_a.html">a</a>);
};

//
// not used for VRML 
//

class <a class="code" href="class_ggroup.html">GGroup</a> : public <a class="code" href="class_gattributenode.html">GAttributeNode</a>  {
public :
        <a class="code" href="class_gattributenode.html#a0">RT</a>(<a class="code" href="class_gattributenode.html">GAttributeNode</a>);
        <a class="code" href="class_ggroup.html">GGroup</a> *next;                   // Next brother to form list of subgroups
        <a class="code" href="class_ggroup.html">GGroup</a> *subgroups;      // Points to first subgroup
        <a class="code" href="class_ggroup.html">GGroup</a> *owner;                  // Points to father
        
        char *name;                             // name, if any
        
        <a class="code" href="class_ggeometry.html">GGeometry</a> *geometry;    // Points to first geometry

        <a class="code" href="class_ggroup.html#a1">GGroup</a>() : <a class="code" href="class_gattributenode.html">GAttributeNode</a>() { next = NULL; subgroups = NULL; owner = NULL;
                                 name = NULL; attributes = NULL; geometry = NULL; 
                           };
        <a class="code" href="class_ggroup.html#a2">~GGroup</a>();
        
        int <a class="code" href="class_gbasenode.html#a4">IsGroup</a>();
        
        void <a class="code" href="class_ggroup.html#a4">SetName</a>(const char *Name,int len = -1);
        
        int <a class="code" href="class_ggroup.html#a5">HasGeometry</a>() { return (geometry != NULL); }
        int <a class="code" href="class_ggroup.html#a6">HasSubGroups</a>() { return (subgroups != NULL); }

        // Traversal
        int <a class="code" href="class_gattributenode.html#a9">Traverse</a>(<a class="code" href="class_gtraversal.html">GTraversal</a> &amp;state);
        int <a class="code" href="class_ggroup.html#a8">TraverseAttributes</a>(<a class="code" href="class_gtraversal.html">GTraversal</a> &amp;state,int mode);

        // insert a Geometry node and take control
        void <a class="code" href="class_array.html#a39">Insert</a>(<a class="code" href="class_ggeometry.html">GGeometry</a> *GeometryNode);

        // link out the the geometry node and call destructor for node
        int  <a class="code" href="class_array.html#a40">Delete</a>(<a class="code" href="class_ggeometry.html">GGeometry</a> *GeometryNode);

        // link in the the geometry node
        int  <a class="code" href="class_ggroup.html#a11">LinkIn</a>(<a class="code" href="class_ggeometry.html">GGeometry</a> *GeometryNode);

        // link out the the geometry node
        int  <a class="code" href="class_ggroup.html#a12">LinkOut</a>(<a class="code" href="class_ggeometry.html">GGeometry</a> *GeometryNode);

        // link in the subgroup node
        int  <a class="code" href="class_ggroup.html#a11">LinkIn</a>(<a class="code" href="class_ggroup.html">GGroup</a> *<a class="code" href="class_node.html">Node</a>);

        // link out the subgroup node
        int  <a class="code" href="class_ggroup.html#a12">LinkOut</a>(<a class="code" href="class_ggroup.html">GGroup</a> *<a class="code" href="class_node.html">Node</a>);


        <a class="code" href="class_ggeometry.html">GGeometry</a> * <a class="code" href="class_ggroup.html#a15">FindGeometry</a>(GId Id);

        void <a class="code" href="class_ggroup.html#a16">DeleteGeometry</a>();
        void <a class="code" href="class_ggroup.html#a17">DeleteSubGroups</a>();
        
        // Empty Group
        void <a class="code" href="class_ggroup.html#a18">Empty</a>() { 
                <a class="code" href="class_ggroup.html#a16">DeleteGeometry</a>(); 
                <a class="code" href="class_ggroup.html#a17">DeleteSubGroups</a>(); 
                <a class="code" href="class_gattributenode.html#a7">DeleteAttributes</a>(); 
        }


        // delete types
        // Find a group by pathname, starting by this
        <a class="code" href="class_ggroup.html">GGroup</a>* <a class="code" href="class_ggroup.html#a19">FindSubGroup</a>(const char *name,int name_len = -1,int create = 0);

    // move node to new group
    int <a class="code" href="class_ggroup.html#a20">Move</a>(<a class="code" href="class_ggroup.html">GGroup</a> *target);
        
        // Add Activity, and propagate to owners
        int <a class="code" href="class_gbasenode.html#a11">Propagate</a>(unsigned int Activity);

        // Notify Group that action has/(will ?) bee performed
        int <a class="code" href="class_gattributenode.html#a8">Notify</a>(GAction action, <a class="code" href="class_ggroup.html">GGroup</a> *n);
        int <a class="code" href="class_gattributenode.html#a8">Notify</a>(GAction action, <a class="code" href="class_ggeometry.html">GGeometry</a> *n);

        // IO 
        virtual int <a class="code" href="class_gattributenode.html#a10">io</a>(<a class="code" href="class_astream.html">AStream</a> &amp;<a class="code" href="class_a.html">a</a>);

};


#define ForGroups(LIST,ELEMENT) for(GGroup *ELEMENT=LIST; ELEMENT != NULL; ELEMENT = ELEMENT-&gt;next)
#define ForAttributes(LIST,ELEMENT) for(GAttribute *ELEMENT=LIST; ELEMENT != NULL; ELEMENT = ELEMENT-&gt;next)
#define ForGeometry(LIST,ELEMENT) for(GGeometry *ELEMENT=LIST; ELEMENT != NULL; ELEMENT = ELEMENT-&gt;next)

//
// Root for all Attribute nodes
// not used for VRML

class <a class="code" href="class_gattribute.html">GAttribute</a> : public <a class="code" href="class_gbasenode.html">GBaseNode</a> {
public :
        <a class="code" href="class_gattributenode.html#a0">RT</a>(<a class="code" href="class_gnode.html">GNode</a>);

        <a class="code" href="class_gattribute.html">GAttribute</a> *next;

        <a class="code" href="class_gattribute.html#a1">GAttribute</a>() : <a class="code" href="class_gbasenode.html">GBaseNode</a>() { next = 0; }
        int <a class="code" href="class_gbasenode.html#a2">IsAttribute</a>();

        virtual int <a class="code" href="class_gattributenode.html#a9">Traverse</a>(<a class="code" href="class_gtraversal.html">GTraversal</a> &amp;state,int mode);
        // Assign Attribute (only if same type)
        virtual int <a class="code" href="class_gattributenode.html#a4">Set</a>(<a class="code" href="class_gattribute.html">GAttribute</a> *<a class="code" href="class_a.html">a</a>);
};

// Root for all geometry nodes
//
class <a class="code" href="class_ggeometry.html">GGeometry</a> : public <a class="code" href="class_gattributenode.html">GAttributeNode</a> {
public:
        <a class="code" href="class_gattributenode.html#a0">RT</a>(<a class="code" href="class_ggeometry.html">GGeometry</a>);

        <a class="code" href="class_ggeometry.html">GGeometry</a> *next;
        <a class="code" href="class_ggroup.html">GGroup</a> *owner;

        <a class="code" href="class_ggeometry.html#a1">GGeometry</a>(<a class="code" href="class_ggeometry.html">GGeometry</a> * Next = NULL, <a class="code" href="class_ggroup.html">GGroup</a> *Owner=NULL) : <a class="code" href="class_gattributenode.html">GAttributeNode</a>()
                                { next = Next; owner = Owner; }

        void <a class="code" href="class_ggeometry.html#a2">SetOwner</a>(<a class="code" href="class_ggroup.html">GGroup</a> *Owner) { owner = Owner; }

        int <a class="code" href="class_gbasenode.html#a3">IsGeometry</a>();
        virtual int <a class="code" href="class_gattributenode.html#a9">Traverse</a>(<a class="code" href="class_gtraversal.html">GTraversal</a> &amp;state);


        // move node to new group
        int <a class="code" href="class_ggeometry.html#a5">Move</a>(<a class="code" href="class_ggroup.html">GGroup</a> *target);

        int <a class="code" href="class_gattributenode.html#a8">Notify</a>(GAction action) { if (owner) owner-&gt;<a class="code" href="class_ggroup.html#a22">Notify</a>(action,this); return(0); };

        // Call this if node contents has been changed
        int <a class="code" href="class_ggeometry.html#a7">NotifyChanged</a>() { <a class="code" href="class_gbasenode.html#a5">AddActivity</a>(GRedraw);
                                                  return (<a class="code" href="class_gattributenode.html#a8">Notify</a>(GGeometryChanged));
                                                };      

};

class <a class="code" href="class_ginstance.html">GInstance</a> : public <a class="code" href="class_ggeometry.html">GGeometry</a>
{
public :
        <a class="code" href="class_gattributenode.html#a0">RT</a>(<a class="code" href="class_ggeometry.html">GGeometry</a>);

        <a class="code" href="class_ggroup.html">GGroup</a> *target;         // Group to be included


        <a class="code" href="class_ginstance.html#a1">GInstance</a>(<a class="code" href="class_ggroup.html">GGroup</a> *Target=NULL) : <a class="code" href="class_ggeometry.html">GGeometry</a>() { <a class="code" href="class_gbasenode.html#a10">SetId</a>(GIdInstance); target = Target; }

        int <a class="code" href="class_gattributenode.html#a9">Traverse</a>(<a class="code" href="class_gtraversal.html">GTraversal</a> &amp;state);
        // IO 
        int <a class="code" href="class_gattributenode.html#a10">io</a>(<a class="code" href="class_astream.html">AStream</a> &amp;<a class="code" href="class_a.html">a</a>);
};

// Attribute GStyle : a refrence to target group style
class <a class="code" href="class_gstyle.html">GStyle</a> : public <a class="code" href="class_gattribute.html">GAttribute</a>
{
public :
        <a class="code" href="class_gattribute.html#a0">RT</a>(<a class="code" href="class_gattribute.html">GAttribute</a>);

        <a class="code" href="class_ggroup.html">GGroup</a> *target;
        <a class="code" href="class_gstyle.html#a1">GStyle</a>(<a class="code" href="class_ggroup.html">GGroup</a> *Target=0) : <a class="code" href="class_gattribute.html">GAttribute</a>() { <a class="code" href="class_gbasenode.html#a10">SetId</a>(GIdStyle); target = Target; }

        int <a class="code" href="class_gattribute.html#a3">Traverse</a>(<a class="code" href="class_gtraversal.html">GTraversal</a> &amp;state,int mode);
        // IO
        int <a class="code" href="class_gnode.html#a18">io</a>(<a class="code" href="class_astream.html">AStream</a> &amp;<a class="code" href="class_a.html">a</a>);
};

#endif



class <a class="code" href="class_gmatrixstack.html">GMatrixStack</a> : public <a class="code" href="class_gstackableattribute.html">GStackableAttribute</a>
{
   
   public :
   <a class="code" href="class_gmatrixstack.html#a0">GSTACKABLE_ATTRIBUTE</a>(<a class="code" href="class_gmatrixstack.html">GMatrixStack</a>)

   GMatrixStack() : <a class="code" href="class_gstackableattribute.html">GStackableAttribute</a>() { 
           mInverseOk = viewpointLocalOk= viewVolumeLocalOk=0;  
           model2screenOk=0;
           viewPlaneLocalOk=0;
   }

   void <a class="code" href="class_gstackableattribute.html#a5">Init</a>() { mInverseOk = viewpointLocalOk = viewVolumeLocalOk=viewPlaneLocalOk=0; model2screenOk=0;  }

   <a class="code" href="class_matrix.html">Matrix</a> m;                    
   <a class="code" href="class_matrix.html">Matrix</a> mInverse;             
   
   <a class="code" href="class_matrix.html">Matrix</a> model2screen; 
                                                // for custom lighting 

   BEGIN_PACKED_STRUCT //struct  { // GCC does not like this ?
                int mInverseOk:1;               
                int viewpointLocalOk:1; 
                int viewVolumeLocalOk:1;
                int model2screenOk:1;   
                int viewPlaneLocalOk:1; 
   END_PACKED_STRUCT //};


   <a class="code" href="class_point.html">Point</a> viewpointLocal;                
   
   <a class="code" href="class_pointarray.html">PointArray</a> viewVolumeLocal;  

   <a class="code" href="class_planearray.html">PlaneArray</a> viewPlaneLocal;  

   void <a class="code" href="class_gmatrixstack.html#a2">Identity</a>() { m.<a class="code" href="class_matrix.html#a20">Identity</a>(); mInverse.<a class="code" href="class_matrix.html#a20">Identity</a>(); mInverseOk = 1;viewpointLocalOk= viewVolumeLocalOk=viewPlaneLocalOk=0; }

   void <a class="code" href="class_gmatrixstack.html#a3">AppendLeft</a>(const <a class="code" href="class_matrix.html">Matrix</a> &amp;left) { 
           m= left * m; mInverseOk= 0;viewpointLocalOk= viewVolumeLocalOk=viewPlaneLocalOk=0; 
           model2screenOk=0;
   }

   <a class="code" href="class_matrix.html">Matrix</a>&amp; <a class="code" href="class_gmatrixstack.html#a4">GetMatrix</a>() { return(m); }
   <a class="code" href="class_matrix.html">Matrix</a>&amp; <a class="code" href="class_gmatrixstack.html#a5">GetMatrixInverse</a>() { 
           if (!mInverseOk) 
           { mInverse.<a class="code" href="class_matrix.html#a19">SetToInverse</a>(m); // mInverse = Invert(m); 
             mInverseOk= 1;
           } 
           return(mInverse);
   }

   void <a class="code" href="class_gmatrixstack.html#a6">SetMatrix</a>(const <a class="code" href="class_matrix.html">Matrix</a> &amp;newM) { 
           m=newM; 
           mInverseOk = viewpointLocalOk= viewVolumeLocalOk=viewPlaneLocalOk=0;  
           model2screenOk=0;
   }

   void <a class="code" href="class_gmatrixstack.html#a6">SetMatrix</a>(const <a class="code" href="class_matrix.html">Matrix</a> &amp;newM,const <a class="code" href="class_matrix.html">Matrix</a> &amp;newInverse) { 
           m=newM; mInverse = newInverse; 
           mInverseOk= 1; viewpointLocalOk= viewVolumeLocalOk=viewPlaneLocalOk=0;  
           model2screenOk=0;

   }

   void <a class="code" href="class_gmatrixstack.html#a8">SetViewpointLocal</a>(const <a class="code" href="class_point.html">Point</a> &amp;global) {
                viewpointLocal =  <a class="code" href="class_gmatrixstack.html#a5">GetMatrixInverse</a>() * global;
                viewpointLocalOk=1;      
   }

   void <a class="code" href="class_gmatrixstack.html#a9">SetViewVolumeLocal</a>(const <a class="code" href="class_pointarray.html">PointArray</a> &amp;global) 
   {
                const <a class="code" href="class_matrix.html">Matrix</a> &amp;m=<a class="code" href="class_gmatrixstack.html#a5">GetMatrixInverse</a>();

                int l= global.<a class="code" href="class_point.html#a14">Length</a>();
                
                viewVolumeLocal.<a class="code" href="class_array.html#a33">SetLength</a>(l);
                for(int i=0; i&lt; l; i++) 
                        viewVolumeLocal[i] = m * global[i];

                viewVolumeLocalOk=1;     
        }

   void <a class="code" href="class_gmatrixstack.html#a10">SetViewPlanesLocal</a>(const <a class="code" href="class_planearray.html">PlaneArray</a> &amp;global) 
   {
                const <a class="code" href="class_matrix.html">Matrix</a> &amp;m=<a class="code" href="class_gmatrixstack.html#a5">GetMatrixInverse</a>();

                int l= global.<a class="code" href="class_point.html#a14">Length</a>();
                
                viewPlaneLocal.<a class="code" href="class_array.html#a33">SetLength</a>(l);
                for(int i=0; i&lt; l; i++) 
                        viewPlaneLocal[i] = m * global[i];

                viewPlaneLocalOk=1;      
        }

   
   
};

//
//  glVersion  of state Matrix attibute
//  implementation will set the Matrix in rendering layer 
class <a class="code" href="class_gglmatrixstack.html">GglMatrixStack</a> : public <a class="code" href="class_gmatrixstack.html">GMatrixStack</a> {

public :
    <a class="code" href="class_gglmatrixstack.html#a0">GSTACKABLE_DERIVED_ATTRIBUTE</a>(<a class="code" href="class_gglmatrixstack.html">GglMatrixStack</a>)
    GglMatrixStack() : <a class="code" href="class_gmatrixstack.html">GMatrixStack</a>() { }
        
        void <a class="code" href="class_gmatrixstack.html#a1">Init</a>() { <a class="code" href="class_gstackableattribute.html#a5">GMatrixStack::Init</a>(); }

        // overwritten virtual set function to set opengl state variables
        void <a class="code" href="class_gattribute.html#a4">Set</a>(<a class="code" href="class_gtraversal.html">GTraversal</a> &amp;state);
};


// GMatrixStack a matrix entry, pushable on traversal stack
class <a class="code" href="class_gtexturematrixstack.html">GTextureMatrixStack</a> : public <a class="code" href="class_gstackableattribute.html">GStackableAttribute</a>
{
   
   public :
   <a class="code" href="class_gmatrixstack.html#a0">GSTACKABLE_ATTRIBUTE</a>(<a class="code" href="class_gtexturematrixstack.html">GTextureMatrixStack</a>)
   GTextureMatrixStack() : <a class="code" href="class_gstackableattribute.html">GStackableAttribute</a>() { }

   <a class="code" href="class_matrix.html">Matrix</a> m;

   void <a class="code" href="class_gmatrixstack.html#a2">Identity</a>() { m.<a class="code" href="class_matrix.html#a20">Identity</a>();  }

   void <a class="code" href="class_gmatrixstack.html#a3">AppendLeft</a>(const <a class="code" href="class_matrix.html">Matrix</a> &amp;left) { m= left * m; }
   <a class="code" href="class_matrix.html">Matrix</a>&amp; <a class="code" href="class_gmatrixstack.html#a4">GetMatrix</a>() { return(m); }
   
   void <a class="code" href="class_gmatrixstack.html#a6">SetMatrix</a>(const <a class="code" href="class_matrix.html">Matrix</a> &amp;newM) { m=newM;  }
};

//  glVersion 
class <a class="code" href="class_ggltexturematrixstack.html">GglTextureMatrixStack</a> : public <a class="code" href="class_gtexturematrixstack.html">GTextureMatrixStack</a> {

public :
    <a class="code" href="class_ggltexturematrixstack.html#a0">GSTACKABLE_DERIVED_ATTRIBUTE</a>(<a class="code" href="class_ggltexturematrixstack.html">GglTextureMatrixStack</a>)
    
    GglTextureMatrixStack() : <a class="code" href="class_gtexturematrixstack.html">GTextureMatrixStack</a>() 
        { 
                mVersion = 0; // needed for D3D
        }

        void <a class="code" href="class_gmatrixstack.html#a1">Init</a>() { 
                mVersion = 0;
                <a class="code" href="class_gmatrixstack.html#a1">GTextureMatrixStack::Init</a>(); 
        }

        // overwritten virtual set function to set opengl state variables
        void <a class="code" href="class_gattribute.html#a4">Set</a>(<a class="code" href="class_gtraversal.html">GTraversal</a> &amp;state);

        long mVersion; // need to give each Matrix a distinctive version
                                   // because matrix need to applied directly to objects        
};


#ifdef _GFULL

class <a class="code" href="class_gmatrix.html">GMatrix</a> : public <a class="code" href="class_gattribute.html">GAttribute</a>
{
public :
        <a class="code" href="class_gattribute.html#a0">RT</a>(<a class="code" href="class_gattribute.html">GAttribute</a>);
        <a class="code" href="class_matrix.html">Matrix</a> m;
        <a class="code" href="class_gmatrix.html#a1">GMatrix</a> () { <a class="code" href="class_gbasenode.html#a10">SetId</a>(GIdMatrix); m=IdentityMatrix(); }
        <a class="code" href="class_gmatrix.html#a1">GMatrix</a>(const <a class="code" href="class_matrix.html">Matrix</a> &amp;M) { <a class="code" href="class_gbasenode.html#a10">SetId</a>(GIdMatrix); m=M; <a class="code" href="class_gbasenode.html#a5">AddActivity</a>(GRedraw); }
        //GMatrix(const float M[4][4]) : m(M) { SetId(GIdMatrix);  AddActivity(GRedraw); }

        void <a class="code" href="class_array.html#a36">Append</a>(const <a class="code" href="class_matrix.html">Matrix</a> &amp;M) { m*=M; <a class="code" href="class_gbasenode.html#a5">AddActivity</a>(GRedraw); }
        void <a class="code" href="class_gattribute.html#a4">Set</a>(const <a class="code" href="class_matrix.html">Matrix</a> &amp;M) { m=M; <a class="code" href="class_gbasenode.html#a5">AddActivity</a>(GRedraw); }

        int <a class="code" href="class_gattribute.html#a4">Set</a>(<a class="code" href="class_gattribute.html">GAttribute</a> *<a class="code" href="class_a.html">a</a>);

        int <a class="code" href="class_gattribute.html#a3">Traverse</a>(<a class="code" href="class_ggeometrytraversal.html">GGeometryTraversal</a> &amp;state,int mode);
        
        int <a class="code" href="class_gnode.html#a4">Do</a>(<a class="code" href="class_gtraversal.html">GTraversal</a> &amp;state);   

#if 0   
        int <a class="code" href="class_gnode.html#a4">Do</a>(<a class="code" href="class_gglrendertraversal.html">GglRenderTraversal</a> &amp;state);   
        int EndDo(<a class="code" href="class_gglrendertraversal.html">GglRenderTraversal</a> &amp;state);
#endif

        //virtual int Do(GBBoxTraversal &amp;state)       { return(-1); } 

        // IO
        int <a class="code" href="class_gnode.html#a18">io</a>(<a class="code" href="class_astream.html">AStream</a> &amp;<a class="code" href="class_a.html">a</a>);
};
#endif


//
// GFaceColor
//
class <a class="code" href="class_gfacecolorstack.html">GFaceColorStack</a> : public <a class="code" href="class_gstackableattribute.html">GStackableAttribute</a>
{
public :
   <a class="code" href="class_gmatrixstack.html#a0">GSTACKABLE_ATTRIBUTE</a>(<a class="code" href="class_gfacecolorstack.html">GFaceColorStack</a>)
   <a class="code" href="class_gfacecolorstack.html#a1">GFaceColorStack</a>() : <a class="code" href="class_gstackableattribute.html">GStackableAttribute</a>() { }
   <a class="code" href="class_gfacecolorstack.html#a1">GFaceColorStack</a>(const <a class="code" href="class_point.html">Point</a> &amp;Color) : color(Color) { }

   <a class="code" href="class_point.html">Point</a> color;
   
};


// 
class <a class="code" href="class_gglfacecolorstack.html">GglFaceColorStack</a> : public <a class="code" href="class_gfacecolorstack.html">GFaceColorStack</a> {

public :
    <a class="code" href="class_gglfacecolorstack.html#a0">GSTACKABLE_DERIVED_ATTRIBUTE</a>(<a class="code" href="class_gglfacecolorstack.html">GglFaceColorStack</a>)

        // overwritten virutal set function to set opengl state variables
        <a class="code" href="class_gglfacecolorstack.html#a1">GglFaceColorStack</a>() : <a class="code" href="class_gfacecolorstack.html">GFaceColorStack</a>() { }
        <a class="code" href="class_gglfacecolorstack.html#a1">GglFaceColorStack</a>(const <a class="code" href="class_point.html">Point</a> &amp;Color) : <a class="code" href="class_gfacecolorstack.html">GFaceColorStack</a>(Color) { }
        void <a class="code" href="class_gattribute.html#a4">Set</a>(<a class="code" href="class_gtraversal.html">GTraversal</a> &amp;state);
};


#ifdef _GFULL

class <a class="code" href="class_gfacecolor.html">GFaceColor</a> : public <a class="code" href="class_gattribute.html">GAttribute</a>
{
public :
        <a class="code" href="class_gattribute.html#a0">RT</a>(<a class="code" href="class_gattribute.html">GAttribute</a>);
        <a class="code" href="class_point.html">Point</a> color;
        <a class="code" href="class_gfacecolor.html#a1">GFaceColor</a> () { }
        <a class="code" href="class_gfacecolor.html#a1">GFaceColor</a>(const <a class="code" href="class_point.html">Point</a> &amp;Color) { color = Color; <a class="code" href="class_gbasenode.html#a5">AddActivity</a>(GRedraw); }
        void <a class="code" href="class_gattribute.html#a4">Set</a>(const <a class="code" href="class_point.html">Point</a> &amp;Color) { color = Color; <a class="code" href="class_gbasenode.html#a5">AddActivity</a>(GRedraw); }

//      int Set(GAttribute *a);
        int <a class="code" href="class_gnode.html#a4">Do</a>(<a class="code" href="class_gtraversal.html">GTraversal</a> &amp;state);   

        // IO
        int <a class="code" href="class_gnode.html#a18">io</a>(<a class="code" href="class_astream.html">AStream</a> &amp;<a class="code" href="class_a.html">a</a>);
};

class <a class="code" href="class_gbbox.html">GBBox</a> : public <a class="code" href="class_gattribute.html">GAttribute</a>
{
public :
        <a class="code" href="class_gattribute.html#a0">RT</a>(<a class="code" href="class_gattribute.html">GAttribute</a>);

        <a class="code" href="class_bbox.html">BBox</a> m;
        <a class="code" href="class_gbbox.html#a1">GBBox</a> () { <a class="code" href="class_gbasenode.html#a10">SetId</a>(GIdBBox); }
        
        <a class="code" href="class_gbbox.html#a1">GBBox</a>(const <a class="code" href="class_bbox.html">BBox</a> &amp;M) { <a class="code" href="class_gbasenode.html#a10">SetId</a>(GIdBBox); m=M; /*AddActivity(GRedraw);*/ }

        void <a class="code" href="class_array.html#a36">Append</a>(const <a class="code" href="class_matrix.html">Matrix</a> &amp;M) { m*=M; /* AddActivity(GRedraw); */ }
        void <a class="code" href="class_gattribute.html#a4">Set</a>(const <a class="code" href="class_bbox.html">BBox</a> &amp;M) { m=M; /* AddActivity(GRedraw);*/ }

        int <a class="code" href="class_gattribute.html#a4">Set</a>(<a class="code" href="class_gattribute.html">GAttribute</a> *<a class="code" href="class_a.html">a</a>) { if (<a class="code" href="class_a.html">a</a>-&gt;id  == id) {
                                                                <a class="code" href="class_gattribute.html#a4">Set</a>(((<a class="code" href="class_gbbox.html">GBBox</a> *) <a class="code" href="class_a.html">a</a>) -&gt; m); 
                                                                return(1);
                                                          }
                                                          return(0);
                                                        }       

        int <a class="code" href="class_gattribute.html#a3">Traverse</a>(<a class="code" href="class_ggeometrytraversal.html">GGeometryTraversal</a> &amp;state,int mode);

        // IO
        int <a class="code" href="class_gnode.html#a18">io</a>(<a class="code" href="class_astream.html">AStream</a> &amp;<a class="code" href="class_a.html">a</a>);

};
#endif


//@class time status for animation
class <a class="code" href="class_gtime.html">GTime</a> {
public :
        //@cmember the current time
        float t;

        //@cmember the current time in global time frame 
        //double now; // == start time + t 

        //@cmember the current time step from previous time
        float dt;

        //@cmember the current time range 
        float t0,t1;

        //@cmember if animation is enabled
        int enabled;

        //@cmember if animation is paused
        gbool pause;

        //@cmember if animation repeats
        gbool wrap;
        
        //@cmember current frame number 
        int <a class="code" href="class_frame.html">frame</a>;
        
        <a class="code" href="class_gtime.html#a0">GTime</a>() { t=0.0; t0 = 0.0; t1= 10.0; dt = 0.1; 
                          enabled = 1; pause=0; wrap = 1; 
                          <a class="code" href="class_frame.html">frame</a> = 0;  
                                // now = 0.0; 
                        }

        //@cmember step to next time frame
        void <a class="code" href="class_gtime.html#a2">Step</a>(float DT) 
                { 
                t+=DT; 
                //now += DT; 
                
                if (DT &gt;0) {
                        if (t&gt;t1)  { 
                                if (wrap) { t=t0; <a class="code" href="class_frame.html">frame</a>++;} 
                                else enabled = 0;
                        }
                } else {
                        if (t&lt;t0)  { 
                                if (wrap) { t=t1; <a class="code" href="class_frame.html">frame</a>++;} 
                                else enabled = 0;
                        }
                }
                
                }

        //@cmember step to next time frame
        void <a class="code" href="class_gtime.html#a2">Step</a>() { <a class="code" href="class_gtime.html#a2">Step</a>(dt); }

        //@cmember reset local time 
        void <a class="code" href="class_gtime.html#a3">Reset</a>() { t = t0; <a class="code" href="class_frame.html">frame</a>=0; }

        //@cmember reverse direction 
        void <a class="code" href="class_gtime.html#a4">Reverse</a>() { dt = -dt; }

        //@cmember set local time range 
        void <a class="code" href="class_gtime.html#a5">SetRange</a>(float T0, float T1) { t0 = T0, t1 = T1;
                                        if (T1 &lt; T0) { t0 = T1; t1 = T0; }
        }

        //@cmember gett local time range 
        void <a class="code" href="class_gtime.html#a6">GetRange</a>(float &amp;T0, float &amp;T1) { T0 = t0, T1 = t1; }

        //@cmember animation enabled ? 
        int <a class="code" href="class_gtime.html#a7">On</a>() { return ( enabled &amp;&amp; (t&gt;=t0) &amp;&amp; (t&lt;=t1)); }

        //@cmember timer enabled ? 
        int <a class="code" href="class_gtime.html#a8">Enabled</a>() { return(enabled); }

        void <a class="code" href="class_gtime.html#a9">Enable</a>() { enabled =1; }

        int <a class="code" href="class_gtime.html#a10">Paused</a>() { return(pause); }


        //@cmember get current system time in secs from 1970 GMT
        static double <a class="code" href="class_gtime.html#d0">GetGlobalTime</a>(); 

};
         

class <a class="code" href="class_gtimestack.html">GTimeStack</a> : public <a class="code" href="class_gstackableattribute.html">GStackableAttribute</a>
{
public :
   <a class="code" href="class_gfacecolorstack.html#a0">GSTACKABLE_ATTRIBUTE</a>(<a class="code" href="class_gtimestack.html">GTimeStack</a>)
   <a class="code" href="class_gtimestack.html#a1">GTimeStack</a>() : <a class="code" href="class_gstackableattribute.html">GStackableAttribute</a>() { }
   <a class="code" href="class_gtimestack.html#a1">GTimeStack</a>(const <a class="code" href="class_gtime.html">GTime</a> &amp;Time) : <a class="code" href="class_gstackableattribute.html">GStackableAttribute</a>() { time = Time; }

   <a class="code" href="class_gtime.html">GTime</a> time;

   float <a class="code" href="class_gtimestack.html#a2">T</a>() { return(time.t); }
   //double Now() { return(time.now); }
   float <a class="code" href="class_gtimestack.html#a3">Enabled</a>() { return(time.<a class="code" href="class_gtime.html#a8">Enabled</a>()); }
   
};

// predefine return codes from Traverse / Do()

// return code to signal traversal stop 
#define TRAVERSE_STOP -10

// object not yet loaded 
#define TRAVERSE_NOT_LOADED -2

// object delayed
#define TRAVERSE_DELAYED -3

// object was culled 
#define TRAVERSE_CULLED -4


// Predefined traversal actions
// register attribute Matrix

class <a class="code" href="class_ggeometrytraversal.html">GGeometryTraversal</a> : public <a class="code" href="class_gtraversal.html">GTraversal</a> {
public :

        <a class="code" href="class_gattribute.html#a0">RT</a>(<a class="code" href="class_ggeometrytraversal.html">GGeometryTraversal</a>);


        <a class="code" href="class_ggeometrytraversal.html#a1">GGeometryTraversal</a>() : <a class="code" href="class_gtraversal.html">GTraversal</a>() {
                camera = NULL; 
                physicalCamera = NULL;
        viewInfo = NULL; 
        doViewCulling=FALSE;
                traversalOrder = 0;
                //viewLocalValid= 0;
                currentMatrix = NULL;
                 
                doLodScale = gfalse;

                lodScale = 1.0f;
                drawPath = G_DRAW_NORMAL;
        };                                                                              

        <a class="code" href="class_gcamera.html">GCamera</a> *camera;                   
        <a class="code" href="class_gcamera.html">GCamera</a> *physicalCamera;   
    
        <a class="code" href="class_gviewinfo.html">GViewInfo</a> *viewInfo;    
    
        gbool doViewCulling;    
        gbool doLodScale;               
        float lodScale;                 

        typedef enum {
                G_DRAW_NORMAL,
                G_STEREO_LEFT,
                G_STEREO_RIGHT,
        } GDrawPath;
        
        GDrawPath drawPath;             


    void <a class="code" href="class_gtraversal.html#a24">InitializeAttributes</a>(); 

        <a class="code" href="class_gmatrixstack.html">GMatrixStack</a> *currentMatrix; // top of matrix stack



        inline void <a class="code" href="class_ggeometrytraversal.html#a3">AppendMatrix</a>(const <a class="code" href="class_matrix.html">Matrix</a> &amp;m) 
        {
        <a class="code" href="class_gmatrixstack.html">GMatrixStack</a> *current,*prev;
            prev = (<a class="code" href="class_gmatrixstack.html">GMatrixStack</a>*) <a class="code" href="class_gtraversal.html#a6">Get</a>(GMatrixStack::attrId);
            current = (<a class="code" href="class_gmatrixstack.html">GMatrixStack</a>*) prev-&gt;<a class="code" href="class_gstackableattribute.html#a4">NewInstance</a>();
            current-&gt;m.Multiply(m,prev-&gt;m);
            <a class="code" href="class_gtraversal.html#a16">Push</a>(current);
                currentMatrix = current;
        }
        
        
        // could be done, assume currentMatrix always valid to eleminate Get call 
        inline <a class="code" href="class_gmatrixstack.html">GMatrixStack</a> * <a class="code" href="class_ggeometrytraversal.html#a4">GetCurrentMatrix</a>() 
        {
                        <a class="code" href="class_gmatrixstack.html">GMatrixStack</a> *m= (<a class="code" href="class_gmatrixstack.html">GMatrixStack</a>*)<a class="code" href="class_gtraversal.html#a6">Get</a>(GMatrixStack::attrId);
                        currentMatrix = m;
                        return m;
        }

        
        // get current modelling matrix
        inline <a class="code" href="class_matrix.html">Matrix</a> * <a class="code" href="class_gmatrixstack.html#a4">GetMatrix</a>()  { 
                        <a class="code" href="class_gmatrixstack.html">GMatrixStack</a> *m= (<a class="code" href="class_gmatrixstack.html">GMatrixStack</a>*)<a class="code" href="class_gtraversal.html#a6">Get</a>(GMatrixStack::attrId);
                        if (m) return &amp;m-&gt;m;
                        else return NULL;
                }

        inline const <a class="code" href="class_matrix.html">Matrix</a>&amp; <a class="code" href="class_ggeometrytraversal.html#a6">GetMatrixRef</a>() const { 
                        <a class="code" href="class_gmatrixstack.html">GMatrixStack</a> *m= (<a class="code" href="class_gmatrixstack.html">GMatrixStack</a>*)<a class="code" href="class_gtraversal.html#a6">Get</a>(GMatrixStack::attrId);
                    // assume always valid !            
                        return m-&gt;<a class="code" href="class_gmatrixstack.html#a4">GetMatrix</a>();
                }
        
        inline const <a class="code" href="class_matrix.html">Matrix</a>&amp; <a class="code" href="class_gmatrixstack.html#a5">GetMatrixInverse</a>() const { 
                        <a class="code" href="class_gmatrixstack.html">GMatrixStack</a> *m= (<a class="code" href="class_gmatrixstack.html">GMatrixStack</a>*)<a class="code" href="class_gtraversal.html#a6">Get</a>(GMatrixStack::attrId);
                    // assume always valid !            
                        return m-&gt;<a class="code" href="class_gmatrixstack.html#a5">GetMatrixInverse</a>();
                }
        
        inline <a class="code" href="class_matrix.html">Matrix</a> * <a class="code" href="class_ggeometrytraversal.html#a8">GetTextureMatrix</a>() const { 
                        <a class="code" href="class_gtexturematrixstack.html">GTextureMatrixStack</a> *m= (<a class="code" href="class_gtexturematrixstack.html">GTextureMatrixStack</a>*)<a class="code" href="class_gtraversal.html#a6">Get</a>(GTextureMatrixStack::attrId);
                        if (m) return &amp;m-&gt;m;
                        else return NULL;
                }

    gbool <a class="code" href="class_ggeometrytraversal.html#a9">IsBoxVisible</a>(const <a class="code" href="class_bbox.html">BBox</a> &amp;<a class="code" href="class_box.html">box</a>) const;


        // BSP Stuff
        //gbool viewLocalValid;
        //Point viewpointLocal;         // viewpoint in local coordinate system
        //PointArray viewVolumeLocal; //  pyramid with viewPoint in local coordinate system

        <a class="code" href="class_point.html">Point</a> viewpoint;
        <a class="code" href="class_pointarray.html">PointArray</a> viewVolume; //  pyramid with viewPoint
        <a class="code" href="class_array.html">Array</a>&lt;<a class="code" href="class_plane.html">Plane</a>&gt; viewPlanes; // the viewplanes 

        int traversalOrder; // BSP traversal ort 

        // set pointer to camera
        void <a class="code" href="class_ggeometrytraversal.html#a10">SetCamera</a>(<a class="code" href="class_gcamera.html">GCamera</a> *camera);

        // set pointer to physical camera
        void <a class="code" href="class_ggeometrytraversal.html#a11">SetPhysicalCamera</a>(<a class="code" href="class_gcamera.html">GCamera</a> *camera);



};


//
//      GPathTraversal
//
//  abstract base clase for traversal maintaining the current path
class <a class="code" href="class_gpathtraversal.html">GPathTraversal</a> : public <a class="code" href="class_ggeometrytraversal.html">GGeometryTraversal</a> 
{
public :
        <a class="code" href="class_gattribute.html#a0">RT</a>(<a class="code" href="class_gpathtraversal.html">GPathTraversal</a>);

        gbool resolveRelativeUrls; // flag for some traversals to resolve local urls now to absolute url

        <a class="code" href="class_gpathtraversal.html#a1">GPathTraversal</a>() : <a class="code" href="class_ggeometrytraversal.html">GGeometryTraversal</a>() {resolveRelativeUrls = FALSE; }


        // get the current path 
        void <a class="code" href="class_gpathtraversal.html#a2">GetPath</a>(<a class="code" href="class_gpath.html">GPath</a> &amp;thePath);


        
        int <a class="code" href="class_gnode.html#a4">Do</a>(<a class="code" href="class_gnode.html">GNode</a> *n) {      return (n-&gt;<a class="code" href="class_gnode.html#a4">Do</a>(*this)); }
        //int Do(GAttribute *a)  { return (a-&gt;Do(*this)); }

        // is the node n already in the set of parents ? (recursive link)
        // gbool IsParent(GvNode *n) { if (topPath) return topPath-&gt;IsInPath(n); else return 0; }


};


//
//      GBBoxTraversal
//
// traverse graph to find bounding box
class <a class="code" href="class_gbboxtraversal.html">GBBoxTraversal</a> : public <a class="code" href="class_ggeometrytraversal.html">GGeometryTraversal</a> 
{
public :
        <a class="code" href="class_gattribute.html#a0">RT</a>(<a class="code" href="class_gbboxtraversal.html">GBBoxTraversal</a>);
        
        <a class="code" href="class_bbox.html">BBox</a> bbox;              // resulting boundingbox in global coordinates

        gbool useBBoxes; // use bbox Information of VRML Nodes


        <a class="code" href="class_gbboxtraversal.html#a1">GBBoxTraversal</a>() : <a class="code" href="class_ggeometrytraversal.html">GGeometryTraversal</a>() { 
                                                        useBBoxes = FALSE; 
                                                        // needShapes = TRUE; // to think ??
        
        }

        // return compute bounding box 
        <a class="code" href="class_bbox.html">BBox</a> &amp;<a class="code" href="class_gbboxtraversal.html#a2">GetBBox</a>() { return(bbox); }

        // add a local coordinate bounding box to current sum 
        void <a class="code" href="class_gbboxtraversal.html#a3">Union</a>(const <a class="code" href="class_bbox.html">BBox</a> &amp;b) {
                
                if (b.<a class="code" href="class_bbox.html#a10">IsEmpty</a>()) return; //  ignore if empty 

                // transform b by current matrix 
                // to do optimize ?
                <a class="code" href="class_gmatrixstack.html">GMatrixStack</a> *m= (<a class="code" href="class_gmatrixstack.html">GMatrixStack</a>*)<a class="code" href="class_gtraversal.html#a6">Get</a>(GMatrixStack::attrId);
                if (m) bbox.<a class="code" href="class_bbox.html#a14">Union</a>(m-&gt;m*b);
                else
                        bbox.<a class="code" href="class_bbox.html#a14">Union</a>(b);
        }
        
        int <a class="code" href="class_gnode.html#a4">Do</a>(<a class="code" href="class_gnode.html">GNode</a> *n) { return (n-&gt;<a class="code" href="class_gnode.html#a4">Do</a>(*this)); }
        

        //int Do(GAttribute *a)  { return (a-&gt;Do(*this)); }

        void <a class="code" href="class_ggeometrytraversal.html#a2">InitializeAttributes</a>(); 

};

class <a class="code" href="class_gframestats.html">GFrameStats</a> {
public :
         DWORD <a class="code" href="class_frame.html">frame</a>;                           // the frame counter
         int prims;                                     // number of geometric primitves
         int tris;                                      // number of triangles drawn
         
         float budget;                          // the budget used
         float quality;                         // the quality computed 
         float frameTime;                       // time used

         <a class="code" href="class_gframestats.html#a0">GFrameStats</a>() { <a class="code" href="class_gframestats.html#a1">Zero</a>(); }
         
         void <a class="code" href="class_gframestats.html#a1">Zero</a>() {
                 <a class="code" href="class_frame.html">frame</a> = 0;
                 prims=tris=0;
                 budget=0;
                 quality=0;
                 frameTime=0;
         }

};

//
// GRenderTraversal
//

// register all important rendering attributes
// Register Attributes : TextureMatrix FaceColor

enum GTransparencyMode {
                GTRANSPARENCY_NONE,             // process in normal order during render
                GTRANSPARENCY_DELAYED   // store GTransparenElement objects during render
};

class <a class="code" href="class_grendertraversal.html">GRenderTraversal</a> : public <a class="code" href="class_ggeometrytraversal.html">GGeometryTraversal</a> {
public :

        <a class="code" href="class_gattribute.html#a0">RT</a>(<a class="code" href="class_grendertraversal.html">GRenderTraversal</a>);
        
        BOOL doClipping;         // geometry need clipping to view frustrum     
        int firstLightIndex; // index of first free light 

        GTransparencyMode transparencyMode; // the processing mode for transparent shapes 

        gbool useTextures; // flag : use textures 

        gbool doProximitySensors; // process proximity sensors during rendering
        gbool doVisibilitySensors; // process visibility sensors during rendering

        <a class="code" href="class_grendertraversal.html#a1">GRenderTraversal</a>() : <a class="code" href="class_ggeometrytraversal.html">GGeometryTraversal</a>() { 
                useTextures = TRUE; 
                firstLightIndex = 0;
                doProximitySensors = TRUE;
                doVisibilitySensors = TRUE;
                needShapes = TRUE;
                doViewCulling=TRUE;
                doClipping = TRUE;
                transparencyMode = GTRANSPARENCY_NONE;
                nurbsTessellationScale = 1.0f;
                nurbsTessellationGroupS = 1.0f;
                nurbsTessellationMode=0;
        }

    void <a class="code" href="class_ggeometrytraversal.html#a2">InitializeAttributes</a>(); 

    // fully process the transparent elements, and clean list at end
        virtual int <a class="code" href="class_grendertraversal.html#a3">RenderTransparentElements</a>();

        <a class="code" href="class_gframestats.html">GFrameStats</a> lastFrameStats;             // total stats of last frame
        <a class="code" href="class_gframestats.html">GFrameStats</a> frameStats;                 // accumulated frame stats
        float nurbsTessellationScale;   // scale factor for nurbs tesselation, contains all scaling factors (group, fuzzy)
        float nurbsTessellationGroupS;  // scale factor from the nurbsGroup
        int nurbsTessellationMode;              // tessellation / feed back mode 


};


class <a class="code" href="class_renderstate.html">RenderState</a>;              // implemented in Glrender

class glMatrix;
class <a class="code" href="class_gtransparentelement.html">GTransparentElement</a>;



// 
// Register gl Attributes : Matrix TextureMatrix FaceColor



class <a class="code" href="class_gglrendertraversal.html">GglRenderTraversal</a> : public <a class="code" href="class_grendertraversal.html">GRenderTraversal</a> 
{
public :
    <a class="code" href="class_gattribute.html#a0">RT</a>(<a class="code" href="class_gglrendertraversal.html">GglRenderTraversal</a>);
    
        <a class="code" href="class_renderstate.html">RenderState</a> *glState; // Points to the current Render Context in use

        //Stack&lt;glMatrix*&gt; matrixStack;

        <a class="code" href="class_gglrendertraversal.html#a1">GglRenderTraversal</a>(<a class="code" href="class_renderstate.html">RenderState</a> * GlState=0) : <a class="code" href="class_grendertraversal.html">GRenderTraversal</a>() 
        
        {       glState = GlState;
                loadInlines = LOAD_IF_NEEDED;
                loadTextures = LOAD_IF_NEEDED;
                loadMovies = LOAD_IF_NEEDED;
                loadSounds = LOAD_IF_NEEDED;
                loadProtos = LOAD_IF_NEEDED;
        }

        int <a class="code" href="class_gnode.html#a4">Do</a>(<a class="code" href="class_gnode.html">GNode</a> *n) 
        {
                return (n-&gt;Do(*this));  // delegate to virtual function Do(GglRenderTraversal)
        }
        

        // perform check of bounding box against transformed view pyramid
        // Result : true : continue processing, false : box not visible OR bbox empty
        // bbox treated not empty if bboxSize.x &gt;0 
        gbool <a class="code" href="class_gglrendertraversal.html#a3">CullCheck</a>(<a class="code" href="class_gvsfvec3f.html">GvSFVec3f</a> &amp;bboxCenter,<a class="code" href="class_gvsfvec3f.html">GvSFVec3f</a> &amp;bboxSize); // implementend in Gv2Group.cpp
        gbool <a class="code" href="class_gglrendertraversal.html#a3">CullCheck</a>(<a class="code" href="class_bbox.html">BBox</a> &amp;bbox);


//      int Do(GAttribute *a)    { return (a-&gt;Do(*this)); }
//      int EndDo(GAttribute *a);
        
        void <a class="code" href="class_ggeometrytraversal.html#a2">InitializeAttributes</a>(); 



};

#ifdef _GFULL


typedef <a class="code" href="class_gbasenode.html">GBaseNode</a>* GKey;



// The World of Groups
class <a class="code" href="class_gworld.html">GWorld</a>    {

protected:
public:

        <a class="code" href="class_ggroup.html">GGroup</a> *root;

        <a class="code" href="class_ggroup.html">GGroup</a> *objects;        // objects to be instanced
        <a class="code" href="class_ggroup.html">GGroup</a> *styles;         // styles to be used


        <a class="code" href="class_stack.html">Stack</a>&lt;<a class="code" href="class_ggroup.html">GGroup</a>*&gt; stack;


        void <a class="code" href="class_gtraversal.html#a16">Push</a>(<a class="code" href="class_ggroup.html">GGroup</a> *s) { stack.<a class="code" href="class_stack.html#a5">Push</a>(current);  current=s; }
        void <a class="code" href="class_gtraversal.html#a17">Pop</a>() { current = stack.<a class="code" href="class_stack.html#a8">Pop</a>(); }

        int doTrace;    // trace certain operations for debugging

public:

        <a class="code" href="class_ggroup.html">GGroup</a> *current;

        <a class="code" href="class_gworld.html#a2">GWorld</a>() {
                   root = new GGroup();
                   current = NULL;
                   objects = NULL; styles = NULL;
                   doTrace = 1;
                        

                 };
        <a class="code" href="class_gworld.html#a3">~GWorld</a>();


        void G__cdecl <a class="code" href="class_gworld.html#a4">Error</a>(const char * message,...);

        <a class="code" href="class_ggroup.html">GGroup</a>* <a class="code" href="class_gworld.html#a5">Current</a>() {return(current); }
        <a class="code" href="class_ggroup.html">GGroup</a>* <a class="code" href="class_gworld.html#a6">Root</a>() { return(root); }

        int <a class="code" href="class_gworld.html#a7">SetTrace</a>(int DoTrace) { doTrace = DoTrace; return(doTrace); }

        int <a class="code" href="class_gattribute.html#a3">Traverse</a>(<a class="code" href="class_gtraversal.html">GTraversal</a> &amp;t) { return(root-&gt;<a class="code" href="class_ggroup.html#a7">Traverse</a>(t));}

        // Open (and Create) group by name 
        void <a class="code" href="class_gworld.html#a9">Open</a>(const char *PathName);
        
        // close currently open group, go back to previous
        void <a class="code" href="class_gworld.html#a10">Close</a>();

        // Open and return the key 
        GKey <a class="code" href="class_gworld.html#a11">KOpen</a>(const char *PathName);

        // Open group given a Key to a group
        void <a class="code" href="class_gworld.html#a12">OpenByKey</a>(GKey key);

        // Delete Group or geometry given the key
        void <a class="code" href="class_gworld.html#a13">DeleteByKey</a>(GKey key);

        // Open group by node 
        void <a class="code" href="class_gworld.html#a9">Open</a>(<a class="code" href="class_ggroup.html">GGroup</a> *group) { <a class="code" href="class_gworld.html#a12">OpenByKey</a>(group); }


        // Move Group or geometry to a group given by key
        void <a class="code" href="class_gworld.html#a15">MoveByKey</a>(GKey key,<a class="code" href="class_ggroup.html">GGroup</a> *target);

        // Empty current world
        void <a class="code" href="class_gworld.html#a16">Empty</a>() {
           
           if (root) root-&gt;<a class="code" href="class_ggroup.html#a18">Empty</a>();
           if (objects) objects-&gt;<a class="code" href="class_ggroup.html#a18">Empty</a>();
           if (styles)  styles-&gt;<a class="code" href="class_ggroup.html#a18">Empty</a>();
           
           stack.SetLength(0);
           current = 0;
        }

        // write World starting at root to file
        int <a class="code" href="class_gworld.html#a17">Write</a>(const char *PathName);

};

extern int <a class="code" href="gclass.h.html#a20">test</a>(int argc,char *argv[]);

#endif

void <a class="code" href="gclass.h.html#a21">GClassFreeAttributeClasses</a>();


#endif

</div></pre><hr><address><small>Generated at Thu Jan 27 18:46:51 2000 for blaxxunContact3D by
<a href="http://www.stack.nl/~dimitri/doxygen/index.html">
<img src="doxygen.gif" alt="doxygen" align=center border=0 
width=118 height=53></a> 1.0.0 written by <a href="mailto:dimitri@stack.nl">Dimitri van Heesch</a>,
 &copy; 1997-1999</small></address>
</body>
</html>
